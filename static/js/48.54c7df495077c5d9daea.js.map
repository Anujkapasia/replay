{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSetup.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/HlsjsVideoStreamer.js"],"names":["broadcastHlsInstance","instanceKeeper","preposition","hls","subscribers","forEach","subscriber","hlsjsSetup","videoElement","configuration","Promise","resolve","reject","Hls","isSupported","customConfiguration","hlsjs","hlsConfig","_objectSpread","autoStartLoad","debug","logLevel","on","Events","MEDIA_ATTACHED","attachMedia","PlaybackError","hlsjsCleanup","stopLoad","destroy","dawnOfTime","Date","minimumDvrLength","getStreamRangeHelper","_hlsjsEventHandlers","streamStartDate","liveMargin","liveEdgeMargin","levelDuration","isLive","reset","hlsjsEventHandlers","hlsjsStreamRangeHelper_defineProperty","MANIFEST_LOADING","LEVEL_LOADED","evt","data","details","live","totalduration","programDateTime","fragments","push","hlsInstance","Object","entries","_ref","_ref2","_slicedToArray","name","handler","adjustForDvrStartOffset","calculateNewState","position","Math","max","currentTime","duration","_getAbsolutePositions","startDateTime","isNaN","absolutePosition","getTime","absoluteStartPosition","getAbsolutePositions","playMode","Infinity","resolvePlayMode","isAtLiveEdge","liveSyncPosition","config","liveSyncDuration","liveSyncDurationCount","getIsAtLiveEdge","setPosition","newPosition","gotoLive","getSourceChangeHandler","nextProps","prevProps","source","normalizeSource","then","MANIFEST_PARSED","onMediaLoaded","off","startPosition","startLoad","e","loadSource","streamUrl","getDistinctPseudoTracks","audioTracks","foundKeys","filter","track","key","concat","lang","isNotAdded","indexOf","map","id","language","kind","label","origin","equalOrNoneSpecified","a","b","equalOrNotSpecified","isAudioTrackListsDifferent","length","i","getAudioTrackManager","update","mapAudioTracks","currentTracks","updateStreamStateProps","currentAudioTrack","currentHlsAudioTrack","ht","audioTrack","refresh","hlsjsAudioTrackManager_defineProperty","AUDIO_TRACK_SWITCHED","_ref3","hlsjsAudioTrackManager_slicedToArray","cleanup","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","st","groupId","matchingTrack","getBitrateAsKbps","level","ceil","bitrate","getHlsjsBitrateManager","streamer","updateStreamState","log","previousBitrates","updateBitrateProps","hlsEvent","eventData","bitrates","Array","isArray","levels","isShallowEqual","currentLevel","LEVEL_SWITCHED","startLevel","currentBitrate","hlsjsBitrateManager_defineProperty","LEVEL_UPDATED","hlsjsBitrateManager_slicedToArray","fixBitrate","nextLevel","bitrateFix","capBitrate","cap","autoLevelCapping","bitrateCap","reached","tech","ed","ErrorDetails","downloadErrors","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","AUDIO_TRACK_LOAD_ERROR","AUDIO_TRACK_LOAD_TIMEOUT","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","KEY_LOAD_ERROR","KEY_LOAD_TIMEOUT","decodeErrors","MANIFEST_PARSING_ERROR","MANIFEST_INCOMPATIBLE_CODECS_ERROR","FRAG_DECRYPT_ERROR","BUFFER_ADD_CODEC_ERROR","FRAG_PARSING_ERROR","getHlsjsEventHandlers","streamRangeHelper","applyProperties","htmlVideoHandlers","getBasicVideoEventHandlers","videoElementEventHandlers","pauseStreamRangeUpdater","lifeCycleManager","setStage","_","getStage","handleActualError","detail","severity","code","playbackError","fatal","message","type","reason","buildMessage","props","onPlaybackError","error","playState","isBuffering","isSeeking","stop","hlsjsEventHandlers_defineProperty","ERROR","BUFFER_STALLED_ERROR","BUFFER_SEEK_OVER_HOLE","BUFFER_NUDGE_ON_STALL","url","endsWith","initialPlaybackProps","_streamer$props$initi","isMuted","volume","muted","isPipAvailable","FRAG_BUFFERED","_streamer$props$initi2","isPaused","pause","hlsjsEventHandlers_slicedToArray","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","onError","setLifeCycleManager","manager","HlsjsVideoStreamer","createVideoStreamerComponent","onTrackElementDataChange","getFilteredStreamStateUpdater","textTrackManager","getTextTrackManager","audioTrackManager","getHlsjsAudioTrackManager","bitrateManager","getArrayLogger","window","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","thirdPartyPlayer","render","renderWithoutSource"],"mappings":"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","file":"static/js/48.e132d5c0.js","sourcesContent":["// @flow\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport { PlaybackError } from '../types';\n\nexport function broadcastHlsInstance(instanceKeeper: HlsjsInstanceKeeper, preposition: 'on' | 'off') {\n  const { hls } = instanceKeeper;\n  hls && instanceKeeper.subscribers.forEach(subscriber => subscriber(hls, preposition));\n}\n\nexport function hlsjsSetup(\n  videoElement: HTMLVideoElement,\n  configuration: ?HlsjsVideoStreamerConfiguration\n): Promise<Hls> {\n  return new Promise((resolve, reject) => {\n    if (Hls.isSupported()) {\n      const customConfiguration = configuration && configuration.hlsjs && configuration.hlsjs.customConfiguration;\n      const hlsConfig: any = {\n        autoStartLoad: false,\n        debug: configuration && configuration.logLevel === 'DEBUG',\n        ...customConfiguration\n      };\n      const hls = new Hls(hlsConfig);\n      hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n        resolve(hls);\n      });\n      hls.attachMedia(videoElement);\n    } else {\n      reject(\n        new PlaybackError('STREAM_ERROR_TECHNOLOGY_UNSUPPORTED', 'hlsjs', 'Hls.js is not supported in this browser.')\n      );\n    }\n  });\n}\n\nexport function hlsjsCleanup(instanceKeeper: HlsjsInstanceKeeper) {\n  const { hls } = instanceKeeper;\n  if (hls) {\n    hls.stopLoad();\n    broadcastHlsInstance(instanceKeeper, 'off');\n    return Promise.resolve(hls.destroy());\n  } else {\n    return Promise.resolve();\n  }\n}\n","// @flow\nimport type { PlayMode } from '../types';\nimport Hls from 'hls.js';\nimport type { StreamRangeHelper } from '../common/types';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: ?Date,\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (isLive) {\n    if (!(startDateTime instanceof Date) || isNaN(startDateTime)) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: new Date(startDateTime.getTime() + position * 1000),\n        absoluteStartPosition: startDateTime\n      };\n    }\n  } else {\n    return {\n      absolutePosition: dawnOfTime,\n      absoluteStartPosition: dawnOfTime\n    };\n  }\n}\n\nfunction getIsAtLiveEdge(hls, videoElement, isLive, liveMargin) {\n  if (isLive) {\n    if (hls.liveSyncPosition) {\n      return videoElement.currentTime > hls.liveSyncPosition - liveMargin;\n    } else if (hls.config && hls.config.liveSyncDuration) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n    } else if (hls.config && hls.config.liveSyncDurationCount) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n  let levelDuration = 0;\n  let streamStartDate: ?Date;\n  let isLive = false;\n  let hls;\n\n  function calculateNewState() {\n    let position;\n\n    if (levelDuration) {\n      position = Math.max((videoElement.currentTime || 0) - Math.max(videoElement.duration - levelDuration, 0), 0);\n    } else {\n      position = videoElement.currentTime || 0;\n    }\n    const duration = levelDuration || videoElement.duration;\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(isLive, streamStartDate, position);\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = hls && getIsAtLiveEdge(hls, videoElement, isLive, liveMargin);\n\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    /* Handled by hls.js itself? */\n  }\n\n  function setPosition(newPosition: number) {\n    if (\n      !(\n        isNaN(newPosition) ||\n        newPosition === Infinity ||\n        isNaN(videoElement.duration) ||\n        videoElement.duration === Infinity\n      )\n    ) {\n      if (levelDuration) {\n        videoElement.currentTime = newPosition + videoElement.duration - levelDuration;\n      } else {\n        videoElement.currentTime = newPosition;\n      }\n    }\n  }\n\n  function gotoLive() {\n    if (isLive && hls) {\n      if (hls.liveSyncPosition) {\n        videoElement.currentTime = hls.liveSyncPosition;\n      } else if (hls.config && hls.config.liveSyncDuration) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n      } else if (hls.config && hls.config.liveSyncDurationCount) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n      } else {\n        videoElement.currentTime = videoElement.duration - liveMargin;\n      }\n    }\n  }\n\n  function reset() {\n    streamStartDate = null;\n    levelDuration = 0;\n    isLive = false;\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.LEVEL_LOADED]: (evt, data) => {\n      isLive = data.details.live;\n      levelDuration = data.details.totalduration;\n      // updateDuration();\n      const programDateTime =\n        data.details &&\n        data.details.fragments &&\n        data.details.fragments[0] &&\n        data.details.fragments[0].programDateTime;\n      if (programDateTime) {\n        streamStartDate = new Date(programDateTime);\n        // updatePosition();\n      }\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport Hls from 'hls.js';\nimport { PlaybackError } from '../types';\nimport { broadcastHlsInstance, hlsjsCleanup, hlsjsSetup } from './hlsjsSetup';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport normalizeSource from '../common/sourceNormalizer';\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  configuration?: ?C\n};\n\nconst getSourceChangeHandler = (instanceKeeper: HlsjsInstanceKeeper) => <\n  C: HlsjsVideoStreamerConfiguration,\n  P: Props<C>\n>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const { videoElement } = instanceKeeper;\n  hlsjsCleanup(instanceKeeper);\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    return hlsjsSetup(videoElement, nextProps.configuration).then(hls => {\n      instanceKeeper.hls = hls;\n      // window.hls = hls;\n      broadcastHlsInstance(instanceKeeper, 'on');\n      return new Promise((resolve, reject) => {\n        const onMediaLoaded = () => {\n          hls.off(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          try {\n            if (source.startPosition) {\n              hls.startLoad(source.startPosition);\n            } else {\n              hls.startLoad();\n            }\n            resolve();\n          } catch (e) {\n            reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load start failed.', 'FATAL', e));\n          }\n        };\n        try {\n          hls.stopLoad();\n          hls.on(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          hls.loadSource(source.streamUrl);\n        } catch (e) {\n          reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load failed.', 'FATAL', e));\n        }\n      });\n    });\n  } /* else if (prevProps && prevProps.source) {\n    // And no new source.\n    return Promise.resolve(instanceKeeper.hls && instanceKeeper.hls.stopLoad());\n  }*/ else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { AudioTrackManager } from '../common/types';\nimport type { HlsjsAudioTrack } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\n// http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\nconst getDistinctPseudoTracks = (audioTracks: ?Array<HlsjsAudioTrack>): Array<AvailableTrack> => {\n  const foundKeys = [];\n  return audioTracks\n    ? audioTracks\n        .filter(track => {\n          const key = `${track.lang || ''}!${track.name || ''}`;\n          const isNotAdded = foundKeys.indexOf(key) < 0;\n          if (isNotAdded) {\n            foundKeys.push(key);\n          }\n          return isNotAdded;\n        })\n        .map(track => ({\n          id: track.id,\n          language: track.lang || 'unknown',\n          kind: '',\n          label: track.name || 'unknown',\n          origin: 'in-stream'\n        }))\n    : [];\n};\n\nconst equalOrNoneSpecified = (a: ?(string | number), b: ?(string | number)) => (!a && !b) || a === b;\nconst equalOrNotSpecified = (a: ?(string | number), b: ?(string | number)) => !a || !b || a === b;\n\nconst isAudioTrackListsDifferent = (a: Array<AvailableTrack>, b: Array<AvailableTrack>) => {\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (\n        !equalOrNoneSpecified(a[i].id, b[i].id) ||\n        !equalOrNoneSpecified(a[i].language, b[i].language) ||\n        !equalOrNoneSpecified(a[i].label, b[i].label)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return true;\n  }\n};\n\nconst getAudioTrackManager = (\n  instanceKeeper: HlsjsInstanceKeeper,\n  update: VideoStreamState => void\n): AudioTrackManager => {\n  let audioTracks: Array<AvailableTrack> = [];\n  let hls;\n\n  function mapAudioTracks() {\n    if (hls) {\n      const currentTracks = getDistinctPseudoTracks(hls.audioTracks);\n      if (isAudioTrackListsDifferent(currentTracks, audioTracks)) {\n        audioTracks = currentTracks;\n      }\n    }\n  }\n\n  function updateStreamStateProps() {\n    let currentAudioTrack = null;\n    if (hls) {\n      const currentHlsAudioTrack = hls.audioTracks.filter(ht => ht.id === hls.audioTrack)[0];\n      if (currentHlsAudioTrack) {\n        const { name, lang } = currentHlsAudioTrack;\n        currentAudioTrack = audioTracks.filter(({ label, language }) => label === name && language === lang)[0];\n      }\n    }\n    update({ audioTracks, currentAudioTrack });\n  }\n\n  function refresh() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const st = selectedAudioTrack;\n    if (hls && hls.audioTracks && st) {\n      const groupId = (hls.audioTracks[hls.audioTrack] || {}).groupId;\n      const matchingTrack = hls.audioTracks.filter(\n        ht =>\n          equalOrNotSpecified(ht.groupId, groupId) &&\n          equalOrNotSpecified(ht.name, st.label) &&\n          equalOrNotSpecified(ht.lang, st.language)\n      )[0];\n      if (matchingTrack) {\n        hls.audioTrack = matchingTrack.id;\n      }\n    }\n  }\n\n  function reset() {\n    audioTracks = [];\n  }\n\n  function handleSourceChange() {\n    refresh();\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.MANIFEST_PARSED]: refresh,\n    [Hls.Events.AUDIO_TRACK_SWITCHED]: handleTrackChange\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    cleanup: () => {},\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getAudioTrackManager;\n","// @flow\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\nimport type { HlsjsQualityLevel } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsKbps(level: HlsjsQualityLevel) {\n  return (level && Math.ceil(level.bitrate / 1000)) || 0;\n}\n\nconst getHlsjsBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  instanceKeeper: HlsjsInstanceKeeper,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n  let hls;\n\n  function updateBitrateProps(hlsEvent, eventData) {\n    if (hls) {\n      let bitrates = Array.isArray(hls.levels) ? hls.levels.map(getBitrateAsKbps) : [];\n      if (isShallowEqual(previousBitrates, bitrates)) {\n        bitrates = previousBitrates;\n      }\n      const currentLevel =\n        hlsEvent === Hls.Events.LEVEL_SWITCHED\n          ? eventData.level\n          : hls.currentLevel === -1\n          ? hls.startLevel\n          : hls.currentLevel;\n      if (currentLevel === -1) {\n        log && log('No hls.js level reported currently or selected for start.');\n        updateStreamState({\n          bitrates\n        });\n      } else {\n        const currentBitrate = getBitrateAsKbps(hls.levels[currentLevel]);\n        updateStreamState({\n          currentBitrate,\n          bitrates\n        });\n      }\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (hls) {\n      if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n        log && log('Resetting restrictions for bitrate.');\n        hls.autoLevelCapping = -1;\n        updateStreamState({ bitrateCap: null });\n      } else {\n        if (Array.isArray(hls.levels)) {\n          let reached = false;\n          for (let i = 0; i < hls.levels.length; i++) {\n            const bitrate = getBitrateAsKbps(hls.levels[i]);\n            if (bitrate === cap) {\n              hls.autoLevelCapping = i;\n              updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i]) });\n              log && log('Desired bitrate cap ' + cap + ' is equal to level on index ' + i + ' in hls.js.', hls.levels);\n              reached = true;\n              break;\n            } else if (bitrate > cap) {\n              if (i > 0) {\n                hls.autoLevelCapping = i - 1;\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i - 1]) });\n                log &&\n                  log(\n                    'Desired bitrate cap ' + cap + ' is closest to level on index ' + (i - 1) + ' in hls.js.',\n                    hls.levels\n                  );\n              } else {\n                hls.autoLevelCapping = 0;\n                log &&\n                  log(\n                    'Desired bitrate cap ' +\n                      cap +\n                      ' appears to be lower than the lowest HLS level. Aligning to lowest level.',\n                    hls.levels\n                  );\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[0]) });\n              }\n              reached = true;\n              break;\n            }\n          }\n          if (!reached) {\n            log &&\n              log('Desired bitrate cap appears to be higher than the higher HLS level. Not applicable.', hls.levels);\n          }\n        } else {\n          log && log('Found no HLS levels from where bitrate capping can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (hls) {\n      if (bitrate === 'min') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = 0;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[0]) });\n          log && log('Fixing bitrate to lowest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate === 'max') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = hls.levels.length - 1;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[hls.levels.length - 1]) });\n          log && log('Fixing bitrate to highest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate == null || isNaN(bitrate) || bitrate < 0 || !bitrate) {\n        log && log('Resetting fixing of bitrate.');\n        hls.nextLevel = -1;\n        updateStreamState({ bitrateFix: null });\n      } else if (typeof bitrate === 'string') {\n        log &&\n          log(\n            'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n            bitrate\n          );\n      } else {\n        if (Array.isArray(hls.levels)) {\n          for (var i = 0; i < hls.levels.length; i++) {\n            if (getBitrateAsKbps(hls.levels[i]) === bitrate) {\n              hls.nextLevel = i;\n              log && log('Fixing bitrate to HLS level ' + i, hls.levels);\n              updateStreamState({ bitrateFix: bitrate });\n              return;\n            }\n          }\n          log &&\n            log(\n              \"Desired bitrate lock didn't match any bitrates specified in the hls.levels list. Not applied.\",\n              hls.levels\n            );\n        } else {\n          log && log('Found no HLS levels from where bitrate fixing can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      previousBitrates = [];\n    },\n    [Hls.Events.MANIFEST_PARSED]: updateBitrateProps,\n    [Hls.Events.LEVEL_SWITCHED]: updateBitrateProps,\n    [Hls.Events.LEVEL_UPDATED]: updateBitrateProps\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getHlsjsBitrateManager;\n","// @flow\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport { PlaybackError } from '../types';\n\nconst tech = 'hlsjs';\nconst ed = Hls.ErrorDetails;\n\nconst downloadErrors = [\n  ed.MANIFEST_LOAD_ERROR,\n  ed.MANIFEST_LOAD_TIMEOUT,\n  ed.LEVEL_LOAD_ERROR,\n  ed.LEVEL_LOAD_TIMEOUT,\n  ed.AUDIO_TRACK_LOAD_ERROR,\n  ed.AUDIO_TRACK_LOAD_TIMEOUT,\n  ed.FRAG_LOAD_ERROR,\n  ed.FRAG_LOOP_LOADING_ERROR,\n  ed.FRAG_LOAD_TIMEOUT,\n  ed.KEY_LOAD_ERROR,\n  ed.KEY_LOAD_TIMEOUT\n];\nconst decodeErrors = [\n  ed.MANIFEST_PARSING_ERROR,\n  ed.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n  ed.FRAG_DECRYPT_ERROR,\n  ed.BUFFER_ADD_CODEC_ERROR,\n  ed.FRAG_PARSING_ERROR\n];\n/*const generalErrors = [\n    t.BUFFER_APPEND_ERROR,\n    t.BUFFER_APPENDING_ERROR,\n    t.BUFFER_FULL_ERROR,\n    t.INTERNAL_EXCEPTION,\n    t.LEVEL_SWITCH_ERROR,\n    t.REMUX_ALLOC_ERROR\n];*/\n\nfunction buildMessage(data: HlsjsErrorData) {\n  const message = (data.type ? data.type + '/' : '') + (data.details || '');\n  if (typeof data.reason === 'string') {\n    return message + ': ' + data.reason;\n  } else {\n    return message;\n  }\n}\n\nexport function mapHlsjsError(isStarted: boolean, data: HlsjsErrorData) {\n  const severity = data.fatal ? 'FATAL' : 'WARNING';\n  const code =\n    (data && data.details && (downloadErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DOWNLOAD')) ||\n    (decodeErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DECODE') ||\n    'STREAM_ERROR';\n  return new PlaybackError(code, tech, buildMessage(data), severity, data);\n}\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport { mapHlsjsError } from './hlsjsErrorMapper';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getHlsjsEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  instanceKeeper,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  function handleActualError(detail) {\n    log && log('hlsjs.error');\n    const playbackError = mapHlsjsError(lifeCycleManager.getStage() === 'started', detail);\n    if (streamer.props.onPlaybackError) {\n      streamer.props.onPlaybackError(playbackError);\n    }\n    if (videoElement.error) {\n      updateStreamState({ error: videoElement.error });\n    }\n    if (playbackError.severity === 'FATAL') {\n      lifeCycleManager.setStage('dead');\n      updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.ERROR]: (evt: any, data: HlsjsErrorData) => {\n      switch (data.details) {\n        case Hls.ErrorDetails.BUFFER_STALLED_ERROR:\n          updateStreamState({ isBuffering: true });\n          if (lifeCycleManager.getStage() === 'started') {\n            updateStreamState({ playState: 'buffering' });\n          }\n          break;\n        case Hls.ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n        case Hls.ErrorDetails.BUFFER_NUDGE_ON_STALL:\n          break;\n        case Hls.ErrorDetails.MANIFEST_PARSING_ERROR:\n          if (data.url && !data.url.endsWith('undefined')) {\n            handleActualError(data);\n          }\n          break;\n        default:\n          handleActualError(data);\n      }\n    },\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      log && log('hlsjs.loading');\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    [Hls.Events.FRAG_BUFFERED]: () => {\n      updateStreamState({ isBuffering: false });\n    },\n    [Hls.Events.MANIFEST_PARSED]: () => {\n      log && log('hlsjs.parsed');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        if (isPaused) {\n          videoElement.pause();\n        }\n        applyProperties({ bitrateFix, bitrateCap });\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n      updateStreamState(streamRangeHelper.calculateNewState());\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded,\n    onError // We still want HTML video element error mapping.\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded,\n      onError\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager\n  };\n};\n\nexport default getHlsjsEventHandlers;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport { hlsjsCleanup } from './hlsjsSetup';\nimport getStreamRangeHelper from './hlsjsStreamRangeHelper';\nimport getSourceChangeHandler from './hlsjsSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts, TrackElementData } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getHlsjsAudioTrackManager from './hlsjsAudioTrackManager';\nimport Hls from 'hls.js';\nimport getTextTrackManager from '../BasicVideoStreamer/textTrackManager';\nimport getHlsjsBitrateManager from './hlsjsBitrateManager';\nimport getHlsjsEventHandlers from './hlsjsEventHandlers';\n\nexport type HlsjsInstanceKeeper = {\n  hls?: Hls,\n  videoElement: HTMLVideoElement,\n  subscribers: Array<(Hls, 'on' | 'off') => void>\n};\n\nexport type HlsjsVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  hlsjs: {\n    customConfiguration?: any\n  }\n};\nexport type HlsjsVideoStreamerProps = VideoStreamerImplProps<HlsjsVideoStreamerConfiguration>;\n\nfunction resolveImplementation(\n  streamer: SimplifiedVideoStreamer<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps>,\n  configuration: ?HlsjsVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement,\n  onTrackElementDataChange: (Array<TrackElementData>) => void\n): Promise<StreamerImplementationParts<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps, HlsjsInstanceKeeper>> {\n  const instanceKeeper = {\n    videoElement,\n    subscribers: []\n  };\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, instanceKeeper, configuration);\n  const handleSourceChange = getSourceChangeHandler(instanceKeeper);\n  const updateStreamState = getFilteredStreamStateUpdater(streamer);\n\n  const textTrackManager = getTextTrackManager(videoElement, updateStreamState, onTrackElementDataChange);\n  const audioTrackManager = getHlsjsAudioTrackManager(instanceKeeper, updateStreamState);\n  const bitrateManager = getHlsjsBitrateManager(\n    streamer,\n    instanceKeeper,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const hlsjsEventHandlers = getHlsjsEventHandlers({\n    streamer,\n    videoElement,\n    instanceKeeper,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = hlsjsEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    hlsjsEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    return hlsjsCleanup(instanceKeeper);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = instanceKeeper;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n}\n\nconst HlsjsVideoStreamer = createVideoStreamerComponent('HlsjsVideoStreamer', resolveImplementation);\n\nexport default HlsjsVideoStreamer;\n"],"sourceRoot":""}