{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaTextTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/ShakaVideoStreamer.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSetup.js"],"names":["dawnOfTime","Date","getStreamRangeHelper","videoElement","shakaPlayer","configuration","liveMargin","liveEdgeMargin","adjustForDvrStartOffset","paused","isLive","seekableStart","seekRange","start","currentTime","calculateNewState","startDateTime","getPresentationStartTimeAsDate","position","duration","end","Infinity","isNaN","playMode","resolvePlayMode","isAtLiveEdge","absolutePosition","absoluteStartPosition","getTime","getAbsolutePositions","setPosition","newPosition","gotoLive","errorFromCodeMappings","shakaError","data","classification","defaultError","reverseLookup","numeric","mappings","Object","keys","filter","key","parseInt","getSeverity","isStarted","code","test","category","mapShakaError","userAgent","location","PlaybackError","mapping","Math","floor","getFromDeclarativeMapping","message","indexOf","protocol","hostname","isEmeBlocked","shaka","util","Error","Code","Category","buildMessage","prepareDrm","source","licenseUrl","details","licenseAcquisitionDetails","serviceCertificate","widevineServiceCertificateUrl","licenseAcquisition","widevine","serviceCertificateUrl","emeAttributes","audioRobustness","videoRobustness","_classification","getEmeAttributes","navigator","licenseRequestHeaders","length","getNetworkingEngine","registerRequestFilter","type","request","net","NetworkingEngine","RequestType","LICENSE","entries","forEach","value","headers","addLicenseRequestFilters","configure","drm","servers","advanced","serverCertificate","Promise","resolve","getSourceChangeHandler","nextProps","prevProps","shakaRequestFilter","shakaResponseFilter","normalizeSource","networkingEngine","clearAllRequestFilters","clearAllResponseFilters","registerResponseFilter","prepareFilters","then","load","streamUrl","startPosition","catch","err","LOAD_INTERRUPTED","document","unload","getShakaEventHandlers","streamer","streamRangeHelper","applyProperties","updateStreamState","log","htmlVideoHandlers","getBasicVideoEventHandlers","thirdPartyPlayer","videoElementEventHandlers","pauseStreamRangeUpdater","lifeCycleManager","setStage","_","getStage","shakaEventHandlers","error","detail","playbackError","props","onPlaybackError","severity","playState","isBuffering","isSeeking","stop","loading","initialPlaybackProps","isMuted","volume","muted","isPipAvailable","streaming","isPaused","bitrateFix","bitrateCap","pause","buffering","toString","name","handler","addEventListener","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","setLifeCycleManager","manager","cleanup","removeEventListener","getBitrateAsBps","track","bandwidth","numericSort","a","b","bandwidthSort","getBitrateAsKbps","ceil","isActiveTrack","active","isUnique","item","index","arr","resetConfiguration","abr","enabled","restrictions","maxBandwidth","getShakaBitrateManager","previousBitrates","updateBitrateProps","variantTracks","getVariantTracks","currentBitrate","bitrates","map","sort","updates","isShallowEqual","adaptation","trackschanged","fixBitrate","bitrate","sortedTracks","slice","desiredVariantTrack","selectVariantTrack","e","matchingTrack","capBitrate","cap","lowestBitrate","max","trackPropKeys","isShakaTrackEqual","Number","isEqual","createSelectableTrack","id","origin","shakaTrack","kind","label","language","supportedContentTypes","isContentTypeSupported","sourceTrack","contentType","ct","getShakaTextTrackManager","managedTextTracks","selectableTextTracks","emptyTracks","getActiveShakaTrack","getTextTracks","update","allProps","currentTextTrack","selectedTrack","isTextTrackVisible","managedSelectedTrack","managedTrack","isBlacklisted","selectableTrack","textTracks","m","emptyManagedTextTrackList","addTracks","tracks","supportedTracks","tracksBeingAdded","newManagedTracks","trackBeingAdded","isLoaded","shakaLoadPromise","addPromise","src","concat","all","nmt","updateManagedTrackListFromAddedTracks","managedTrackMatches","managedTextTrack","addedTrack","loadPromise","charsetPos","substr","addTextTrack","blacklistExistingSideLoadedTracks","setTextTrackVisibility","shakaTracks","newManagedTrackList","isRemoving","texttrackvisibility","handleSelectedTextTrackChange","textTrack","mt","window","setTimeout","fullShakaTrack","updatedTrack","selectTextTrack","handleTextTracksPropChange","Array","isArray","handleSourcePropChange","newTracks","clear","createManagedTrack","role","getShakaAudioTrackManager","managedTracks","updateCurrentAudioTrack","activeShakaTrack","currentAudioTrack","roles","isTrackMatchingLanguageAndRole","updateAudioTracks","getAudioLanguagesAndRoles","audioTracks","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","selectAudioLanguage","ShakaVideoStreamer","createVideoStreamerComponent","MediaSource","isTypeSupported","shakaPlayerConfig","installPolyfills","polyfill","installAll","Player","customConfiguration","shakaSetup","reject","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","bitrateManager","getArrayLogger","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","render","renderWithoutSource","destroy","shakaCleanup"],"mappings":"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","file":"static/js/3.ff89e76e.js","sourcesContent":["// @flow\nimport type { PlayMode } from '../types';\nimport type { ShakaPlayer } from './types';\nimport type { StreamRangeHelper } from '../common/types';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\nconst dvrStartCorrection = 10; // yep, seconds\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: Date,\n  seekRange: { start: number, end: number },\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (isLive) {\n    if (isNaN(startDateTime)) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: new Date(startDateTime.getTime() + (position + seekRange.start) * 1000),\n        absoluteStartPosition: new Date(startDateTime.getTime() + seekRange.start * 1000)\n      };\n    }\n  } else {\n    return {\n      absolutePosition: dawnOfTime,\n      absoluteStartPosition: dawnOfTime\n    };\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n\n  function calculateNewState() {\n    const seekRange = shakaPlayer.seekRange();\n    const isLive = shakaPlayer.isLive();\n    const startDateTime = isLive ? shakaPlayer.getPresentationStartTimeAsDate() : new Date();\n    const position = videoElement.currentTime - seekRange.start;\n    const duration =\n      seekRange.end !== 0 || seekRange.start !== 0\n        ? seekRange.end - seekRange.start\n        : videoElement.duration === Infinity || isNaN(videoElement.duration)\n        ? 0\n        : videoElement.duration;\n\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = isLive && position > duration - liveMargin;\n\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(\n      isLive,\n      startDateTime,\n      seekRange,\n      position\n    );\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    if (videoElement && videoElement.paused && shakaPlayer.isLive()) {\n      const seekableStart = shakaPlayer.seekRange().start || 0;\n      if (seekableStart >= videoElement.currentTime) {\n        videoElement.currentTime = seekableStart + dvrStartCorrection;\n      }\n    }\n  }\n\n  function setPosition(newPosition: number) {\n    if (!(isNaN(newPosition) && newPosition === Infinity)) {\n      videoElement.currentTime = shakaPlayer.seekRange().start + newPosition;\n    }\n  }\n\n  function gotoLive() {\n    if (shakaPlayer.isLive()) {\n      videoElement.currentTime = shakaPlayer.seekRange().end;\n    }\n  }\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { ErrorCode, Severity } from '../types';\nimport shaka from 'shaka-player';\nimport type { ShakaError } from './types';\nimport { PlaybackError } from '../types';\n\nconst errorTechnology = 'shaka';\n\nconst STREAM_ERROR = 'STREAM_ERROR';\nconst STREAM_ERROR_DRM_CLIENT_UNAVAILABLE = 'STREAM_ERROR_DRM_CLIENT_UNAVAILABLE';\nconst STREAM_ERROR_DOWNLOAD = 'STREAM_ERROR_DOWNLOAD';\nconst STREAM_ERROR_DECODE = 'STREAM_ERROR_DECODE';\nconst STREAM_ERROR_DRM_OUTPUT_BLOCKED = 'STREAM_ERROR_DRM_OUTPUT_BLOCKED';\n\nconst errorFromCodeMappings = {\n  '3016': function(shakaError) {\n    if (shakaError.data && shakaError.data[0]) {\n      if (shakaError.data[0] === 3) {\n        return { classification: STREAM_ERROR_DECODE };\n      }\n    }\n    return { classification: STREAM_ERROR };\n  },\n  '4012': { classification: STREAM_ERROR },\n  '6001': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6002': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6003': { classification: STREAM_ERROR },\n  '6007': { classification: STREAM_ERROR_DOWNLOAD },\n  '6008': { classification: STREAM_ERROR_DOWNLOAD },\n  '6013': { classification: STREAM_ERROR },\n  '7000': { classification: '' },\n\n  // Error codes starting with the following digits, are grouped together.\n  '1': { classification: STREAM_ERROR_DOWNLOAD },\n  '2': { classification: STREAM_ERROR_DECODE },\n  '3': { classification: STREAM_ERROR_DECODE },\n  '4': { classification: STREAM_ERROR_DECODE },\n  '5': { classification: STREAM_ERROR_DECODE },\n  '6': { classification: STREAM_ERROR_DECODE }\n};\n\nconst defaultError = { classification: STREAM_ERROR };\n\nfunction reverseLookup(numeric: string | number, mappings: { [string]: string }) {\n  return Object.keys(mappings).filter(key => {\n    return mappings[key] === parseInt(numeric, 10);\n  })[0];\n}\n\nfunction buildMessage(shakaError: ShakaError, classification: ErrorCode) {\n  if (shakaError.code === 1001 && shakaError.data[1] != null) {\n    return 'Shaka request failed with status ' + shakaError.data[1] + ' for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1002) {\n    return 'Shaka request could not be performed for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1003) {\n    return 'Shaka request timed out for URL ' + shakaError.data[0];\n  }\n  if (shakaError.message) {\n    return shakaError.message;\n  }\n  if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE) {\n    return 'Playback of protected content appears to be disabled in the browser.';\n  }\n  if (classification === STREAM_ERROR_DRM_OUTPUT_BLOCKED) {\n    return 'Playback of protected content appears to be disallowed, perhaps due to a non-secure or HDCP-less screen being connected.';\n  }\n  const code = reverseLookup(shakaError.code, shaka.util.Error.Code),\n    category = reverseLookup(shakaError.category, shaka.util.Error.Category);\n  const message = 'Shaka error ' + category + '/' + code + ' reported';\n\n  if (shakaError.data[0]) {\n    if (shakaError.data[0].message) {\n      return message + ': ' + shakaError.data[0].message;\n    } else {\n      return message + '. See the sourceError property for more details.';\n    }\n  } else {\n    return message + ' with no further details.';\n  }\n}\n\nfunction getSeverity(isStarted: boolean, shakaError: ShakaError): Severity {\n  if (shakaError.code === 1001 && shakaError.data) {\n    if (shakaError.data[0] && /\\.ttml|\\.vtt|\\.srt|subtitle/.test(shakaError.data[0])) {\n      // Dirty check for subtitles requests failing. That's not fatal.\n      return 'WARNING';\n    } else if (shakaError.data[1] === 502) {\n      return 'FATAL';\n    }\n  }\n  if (shakaError.code === 4012) {\n    return 'WARNING';\n  }\n  if ((isStarted && shakaError.code < 2000) || shakaError.category === 2) {\n    return 'WARNING';\n  }\n  return 'FATAL';\n}\n\nfunction getFromDeclarativeMapping(shakaError) {\n  if (shakaError.code) {\n    const mapping = errorFromCodeMappings[shakaError.code] || errorFromCodeMappings[Math.floor(shakaError.code / 1000)];\n    if (typeof mapping === 'function') {\n      return mapping(shakaError) || defaultError;\n    } else {\n      return mapping || defaultError;\n    }\n  } else {\n    return defaultError;\n  }\n}\n\nfunction isEmeBlocked(userAgent: ?string, location: ?Location) {\n  return (\n    location &&\n    location.protocol === 'http:' &&\n    location.hostname.indexOf('localhost') !== 0 &&\n    userAgent &&\n    userAgent.indexOf('Edge') < 0 &&\n    userAgent.indexOf('Chrome') > 0\n  );\n}\n\nfunction mapShakaError(isStarted: boolean, shakaError: ShakaError, userAgent?: string, location?: Location) {\n  if (shakaError instanceof PlaybackError) {\n    return shakaError;\n  }\n  const classification = getFromDeclarativeMapping(shakaError).classification;\n  if ((shakaError.message || '').indexOf('MediaSource') >= 0) {\n    return new PlaybackError(\n      'STREAM_ERROR_TECHNOLOGY_UNSUPPORTED',\n      'shaka',\n      'This browser does not support playing MPEG-DASH streams with Shaka Player.',\n      'FATAL',\n      shakaError\n    );\n  } else if (classification) {\n    if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE && isEmeBlocked(userAgent, location)) {\n      const message = 'DRM playback is blocked in Chrome. Likely reason: This page is not served with HTTPS.';\n      return new PlaybackError(STREAM_ERROR, errorTechnology, message, getSeverity(isStarted, shakaError), shakaError);\n    } else {\n      return new PlaybackError(\n        classification,\n        errorTechnology,\n        buildMessage(shakaError, classification),\n        getSeverity(isStarted, shakaError),\n        shakaError\n      );\n    }\n  } else {\n    return new PlaybackError(\n      STREAM_ERROR,\n      errorTechnology,\n      'Unknown error reported from Shaka Player.',\n      'WARNING',\n      shakaError\n    );\n  }\n}\n\nexport default mapShakaError;\n","// @flow\nimport type { AdvancedPlaybackSource, PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport type { ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport mapShakaError from './shakaErrorMapper';\nimport shaka from 'shaka-player';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter,\n  configuration?: ?C\n};\n\nfunction getEmeAttributes(userAgent, serviceCertificate) {\n  // For now, only deals with Chrome and Android Chrome distinctions.\n  if (/Android(.*)Chrome/.test(userAgent)) {\n    // Lowest level, SW_SECURE_CRYPTO, also for video.\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_CRYPTO',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Android Chrome 58 and newer'\n    };\n  } else {\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_DECODE',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Desktop'\n    };\n  }\n}\n\nfunction addLicenseRequestFilters(shakaPlayer: ShakaPlayer, licenseRequestHeaders: { [string]: string }) {\n  shakaPlayer.getNetworkingEngine().registerRequestFilter((type: string, request) => {\n    if (type === shaka.net.NetworkingEngine.RequestType.LICENSE) {\n      Object.entries(licenseRequestHeaders).forEach(([key: string, value: string]) => {\n        request.headers[key] = value;\n      });\n    }\n  });\n}\n\nfunction prepareDrm(\n  shakaPlayer: ShakaPlayer,\n  source: AdvancedPlaybackSource,\n  configuration: ?VideoStreamerConfiguration\n) {\n  const licenseUrl = source.licenseUrl;\n  const details = source.licenseAcquisitionDetails || {};\n  const serviceCertificate =\n    details.widevineServiceCertificateUrl ||\n    (configuration &&\n      configuration.licenseAcquisition &&\n      configuration.licenseAcquisition.widevine &&\n      configuration.licenseAcquisition.widevine.serviceCertificateUrl);\n  const emeAttributes = getEmeAttributes(navigator.userAgent, serviceCertificate);\n  const { licenseRequestHeaders } = details;\n  if (licenseRequestHeaders && Object.keys(licenseRequestHeaders).length > 0) {\n    addLicenseRequestFilters(shakaPlayer, licenseRequestHeaders);\n  }\n  shakaPlayer.configure({\n    drm: {\n      servers: {\n        'com.widevine.alpha': licenseUrl,\n        'com.microsoft.playready': licenseUrl\n      },\n      advanced: {\n        'com.widevine.alpha': {\n          audioRobustness: emeAttributes.audioRobustness,\n          videoRobustness: emeAttributes.videoRobustness,\n          serverCertificate: emeAttributes.serviceCertificate\n        },\n        'com.microsoft.playready': {\n          videoRobustness: 'SW_SECURE_DECODE',\n          audioRobustness: 'SW_SECURE_CRYPTO'\n        }\n      }\n    }\n  });\n  return Promise.resolve();\n}\n\nfunction prepareFilters(\n  shakaPlayer: ShakaPlayer,\n  shakaRequestFilter: ?ShakaRequestFilter,\n  shakaResponseFilter: ?ShakaResponseFilter\n) {\n  const networkingEngine = shakaPlayer.getNetworkingEngine();\n  if (networkingEngine) {\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    if (shakaRequestFilter) {\n      networkingEngine.registerRequestFilter(shakaRequestFilter);\n    }\n    if (shakaResponseFilter) {\n      networkingEngine.registerResponseFilter(shakaResponseFilter);\n    }\n  }\n  // To be leaved for plugging in: Credentials, request headers, license request headers, manifest modification, manifest corrections.\n  return Promise.resolve();\n}\n\nconst getSourceChangeHandler = (shakaPlayer: ShakaPlayer) => <C: VideoStreamerConfiguration, P: Props<C>>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const { shakaRequestFilter, shakaResponseFilter } = nextProps;\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    return prepareFilters(shakaPlayer, shakaRequestFilter, shakaResponseFilter)\n      .then(() => prepareDrm(shakaPlayer, source, nextProps.configuration))\n      .then(() => shakaPlayer.load(source.streamUrl, source.startPosition))\n      .catch(err => {\n        if (err && err.code !== shaka.util.Error.Code.LOAD_INTERRUPTED) {\n          throw mapShakaError(false, err, navigator.userAgent, document.location);\n        }\n      });\n  } else if (prevProps && prevProps.source) {\n    // And no new source.\n    const networkingEngine = shakaPlayer.getNetworkingEngine();\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    return shakaPlayer.unload();\n  } else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport type { ShakaPlayer } from './types';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport mapShakaError from './shakaErrorMapper';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getShakaEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  shakaPlayer,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    thirdPartyPlayer: shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  const shakaEventHandlers = {\n    error: ({ detail }: { detail: any }) => {\n      log && log('shaka.error');\n      const playbackError = mapShakaError(\n        lifeCycleManager.getStage() === 'started',\n        detail,\n        navigator.userAgent,\n        document.location\n      );\n      if (streamer.props.onPlaybackError) {\n        streamer.props.onPlaybackError(playbackError);\n      }\n      if (videoElement.error) {\n        updateStreamState({ error: videoElement.error });\n      }\n      if (playbackError.severity === 'FATAL') {\n        lifeCycleManager.setStage('dead');\n        updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n      }\n      pauseStreamRangeUpdater.stop();\n    },\n    loading: () => {\n      log && log('shaka.loading');\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    streaming: () => {\n      log && log('shaka.streaming');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        applyProperties({ bitrateFix, bitrateCap });\n        if (isPaused) {\n          videoElement.pause();\n        }\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n\n      updateStreamState({\n        isMuted: videoElement.muted,\n        volume: videoElement.volume,\n        ...streamRangeHelper.calculateNewState()\n      });\n    },\n    buffering: ({ buffering }: { buffering: boolean }) => {\n      log && log('shaka.buffering.' + buffering.toString());\n      if (buffering && lifeCycleManager.getStage() === 'started') {\n        updateStreamState({ isBuffering: buffering, playState: 'buffering' });\n      } else {\n        updateStreamState({ isBuffering: buffering });\n      }\n    }\n  };\n\n  function cleanup() {\n    htmlVideoHandlers.cleanup();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager,\n    cleanup\n  };\n};\n\nexport default getShakaEventHandlers;\n","// @flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsBps(track) {\n  return (track && track.bandwidth) || 0;\n}\n\nfunction numericSort(a, b) {\n  return a - b;\n}\n\nfunction bandwidthSort(a: ShakaTrack, b: ShakaTrack) {\n  return a.bandwidth - b.bandwidth;\n}\n\nfunction getBitrateAsKbps(track: ShakaTrack) {\n  return (track && Math.ceil(track.bandwidth / 1000)) || 0;\n}\n\nfunction isActiveTrack(track: ShakaTrack) {\n  return track && track.active && track.type === 'variant';\n}\n\nfunction isUnique(item, index, arr) {\n  return arr.indexOf(item) === index;\n}\n\nconst resetConfiguration = { abr: { enabled: true, restrictions: { maxBandwidth: Infinity } } };\n\nconst getShakaBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n\n  function updateBitrateProps() {\n    let variantTracks: Array<ShakaTrack> = shakaPlayer.getVariantTracks();\n    /*const maxBandwidth = shakaPlayer.getConfiguration().abr['restrictions'] && shakaPlayer.getConfiguration().abr['restrictions'].maxBandwidth;\n    if (maxBandwidth && maxBandwidth !== Infinity && variantTracks.length > previousVariantTracks.length) {\n      variantTracks = previousVariantTracks;\n    }// else {\n    // previousVariantTracks = variantTracks;\n    //}*/\n    const currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    const bitrates = variantTracks\n      .map(getBitrateAsKbps)\n      .filter(isUnique)\n      .sort(numericSort);\n\n    const updates: Object = {};\n    if (currentBitrate) {\n      updates.currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    }\n    if (!isShallowEqual(previousBitrates, bitrates)) {\n      previousBitrates = bitrates;\n      updates.bitrates = bitrates;\n    }\n    if (Object.keys(updates).length > 0) {\n      updateStreamState(updates);\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n      log && log('Resetting restrictions for bitrate.');\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateCap: null });\n    } else {\n      const lowestBitrate = shakaPlayer\n        .getVariantTracks()\n        .map(getBitrateAsBps)\n        .sort(numericSort)[0];\n      if (lowestBitrate) {\n        const maxBandwidth = Math.max(cap * 1000, lowestBitrate);\n        const restrictions = { maxBandwidth };\n        shakaPlayer.configure({ abr: { enabled: true, restrictions: restrictions } });\n        updateStreamState({ bitrateCap: Math.ceil(maxBandwidth / 1000) });\n        if (restrictions.maxBandwidth === lowestBitrate) {\n          log && log('Applying restrictions for bitrate, but aligning to lowest available bitrate.', restrictions);\n        } else {\n          log && log('Applying restrictions for bitrate.', restrictions);\n        }\n      } else {\n        log &&\n          log(\n            'Bitrate range not found. Not safe to applying restrictions for bitrate.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (typeof bitrate === 'string') {\n      try {\n        const sortedTracks = shakaPlayer\n          .getVariantTracks()\n          .slice(0)\n          .sort(bandwidthSort);\n        const desiredVariantTrack =\n          bitrate === 'min' ? sortedTracks[0] : bitrate === 'max' ? sortedTracks[sortedTracks.length - 1] : null;\n        if (desiredVariantTrack) {\n          shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n          shakaPlayer.selectVariantTrack(desiredVariantTrack);\n          updateStreamState({ bitrateFix: getBitrateAsKbps(desiredVariantTrack) });\n        } else {\n          shakaPlayer.configure(resetConfiguration);\n          updateStreamState({ bitrateFix: null });\n          log &&\n            log(\n              'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n              bitrate\n            );\n        }\n      } catch (e) {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Attempting to set ' + bitrate + 'imum bitrate, but no tracks found. A bit too early, maybe?',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    } else if (isNaN(bitrate) || bitrate == null || bitrate < 0 || !bitrate) {\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateFix: null });\n      log && log('Resetting bitrate locking.');\n    } else {\n      const matchingTrack = shakaPlayer.getVariantTracks().filter(function(track) {\n        return getBitrateAsKbps(track) === bitrate;\n      })[0];\n      if (matchingTrack) {\n        shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n        shakaPlayer.selectVariantTrack(matchingTrack);\n        updateStreamState({ bitrateFix: getBitrateAsKbps(matchingTrack) });\n        log && log('Locking at bitrate ' + bitrate + '.', matchingTrack);\n      } else {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Could not finding matching track for specified lock bitrate ' + bitrate + '.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  const shakaEventHandlers = {\n    loading: () => {\n      previousBitrates = [];\n    },\n    streaming: updateBitrateProps,\n    adaptation: updateBitrateProps,\n    trackschanged: updateBitrateProps\n  };\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  return {\n    cleanup,\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getShakaBitrateManager;\n","//@flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { ManagedTextTrack } from '../BasicVideoStreamer/textTrackManager';\nimport type { TextTrackManager } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedShakaTextTrack = ManagedTextTrack & {\n  shakaTrack: ?ShakaTrack,\n  shakaLoadPromise?: Promise<?ShakaTrack>\n};\n\nfunction isEqual(a, b) {\n  return a === b || (a == null && b == null ? true : Number.isNaN(a) && Number.isNaN(b));\n}\n\nconst trackPropKeys = ['id', 'language', 'kind', 'label'];\n\nfunction isShakaTrackEqual(a, b) {\n  return (a && b && trackPropKeys.filter(key => isEqual(a[key], b[key])).length === trackPropKeys.length) || (!a && !b);\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  shakaTrack: ShakaTrack\n): AvailableTrack {\n  const kind = shakaTrack.kind === 'subtitle' ? 'subtitles' : shakaTrack.kind || '';\n  return {\n    id,\n    kind,\n    label: shakaTrack.label || '',\n    language: shakaTrack.language || '',\n    origin\n  };\n}\n\nconst supportedContentTypes = ['text/vtt', 'application/ttml+xml'];\n\nfunction isContentTypeSupported(sourceTrack) {\n  const contentType = sourceTrack.contentType;\n  return contentType && supportedContentTypes.filter(ct => contentType.indexOf(ct) === 0).length > 0;\n}\n\nfunction getShakaTextTrackManager(\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): TextTrackManager {\n  let managedTextTracks: Array<ManagedShakaTextTrack> = [];\n  let selectableTextTracks = emptyTracks;\n\n  function getActiveShakaTrack() {\n    return (shakaPlayer.getTextTracks() || []).filter(track => track.active)[0];\n  }\n\n  function update(allProps: boolean) {\n    let currentTextTrack = null;\n    let selectedTrack = null;\n    try {\n      // In case of errors, this might fail due to early cleanup.\n      selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    } catch(e) {}\n    if (selectedTrack) {\n      const managedSelectedTrack = managedTextTracks.filter(\n        managedTrack =>\n          !managedTrack.isBlacklisted &&\n          managedTrack.selectableTrack != null &&\n          isShakaTrackEqual(managedTrack.shakaTrack, selectedTrack)\n      )[0];\n      currentTextTrack = managedSelectedTrack ? managedSelectedTrack.selectableTrack : null;\n    }\n    if (allProps) {\n      const textTracks = managedTextTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n      if (isShallowEqual(textTracks, selectableTextTracks)) {\n        // $FlowFixMe Complaints about null entries, despite filter above.\n        updateStreamState({\n          textTracks: selectableTextTracks,\n          currentTextTrack\n        });\n      } else {\n        selectableTextTracks = textTracks;\n        updateStreamState({\n          textTracks,\n          currentTextTrack\n        });\n      }\n    } else {\n      updateStreamState({\n        currentTextTrack\n      });\n    }\n  }\n\n  function emptyManagedTextTrackList() {\n    managedTextTracks.length = 0;\n    update(true);\n  }\n\n  function ingestAndFilterEarlierAddedTracks(sourceTracks: Array<SourceTrack>) {\n    return sourceTracks.filter(sourceTrack => {\n      const managedTrackMatches = managedTextTracks.filter(\n        managedTextTrack =>\n          managedTextTrack.sourceTrack &&\n          managedTextTrack.sourceTrack.src === sourceTrack.src &&\n          managedTextTrack.shakaTrack\n      );\n      if (managedTrackMatches.length === 0) {\n        return true;\n      } else {\n        const addedTrack = managedTrackMatches[0];\n        const shakaTrack = addedTrack.shakaTrack;\n        if (shakaTrack) {\n          addedTrack.sourceTrack = sourceTrack;\n          addedTrack.isBlacklisted = false;\n          addedTrack.isLoaded = true;\n          if (addedTrack.shakaTrack)\n            addedTrack.selectableTrack = createSelectableTrack(\n              addedTrack.shakaTrack.id,\n              'side-loaded',\n              addedTrack.shakaTrack\n            );\n          addedTrack.error = null;\n          addedTrack.loadPromise = Promise.resolve();\n          return false;\n        }\n        return false;\n      }\n    });\n  }\n\n  function updateManagedTrackListFromAddedTracks(tracksBeingAdded) {\n    const newManagedTracks = tracksBeingAdded.map(trackBeingAdded => {\n      const managedTrack: ManagedShakaTextTrack = {\n        id: null,\n        sourceTrack: trackBeingAdded.sourceTrack,\n        shakaTrack: null,\n        isBlacklisted: false, // When a track is explicitly added, we don't assume or check for duplicates, thus blacklisting should not be relevant.\n        isLoaded: false,\n        error: null,\n        selectableTrack: null,\n        shakaLoadPromise: trackBeingAdded.addPromise.then(\n          shakaTrack => {\n            managedTrack.isLoaded = true;\n            managedTrack.shakaTrack = shakaTrack;\n            managedTrack.selectableTrack = createSelectableTrack(shakaTrack.id, 'side-loaded', shakaTrack);\n            return shakaTrack;\n          },\n          error => {\n            managedTrack.error =\n              error || new Error('Shaka rejected adding a track with the URL ' + trackBeingAdded.sourceTrack.src);\n            managedTrack.isBlacklisted = true;\n            managedTrack.isLoaded = true;\n            return null;\n          }\n        )\n      };\n      return managedTrack;\n    });\n    managedTextTracks = managedTextTracks.concat(newManagedTracks);\n    return Promise.all(newManagedTracks.map(nmt => nmt.shakaLoadPromise));\n  }\n\n  function selectShakaTrack(shakaTrack: ?ShakaTrack) {\n    // setTextTrackVisibility() (and some other internal Shaka methods) is not dealing well with different text tracks having the same language code.\n    // This method needs to complete async tasks (promises?) before we can select the correct track.\n    if (shakaTrack) {\n      shakaPlayer.removeEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      if (!shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(true);\n      }\n      window.setTimeout(() => {\n        // Shaka tracks contain incomplete data and an updated version needs to be looked up:\n        const fullShakaTrack = (shakaPlayer.getTextTracks() || []).filter(updatedTrack => {\n          return isShakaTrackEqual(updatedTrack, shakaTrack);\n        })[0];\n        if (fullShakaTrack) {\n          shakaPlayer.selectTextTrack(fullShakaTrack);\n        } else {\n          shakaTrack && shakaPlayer.selectTextTrack(shakaTrack);\n        }\n        update(false);\n        shakaPlayer.addEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      }, 1);\n    } else {\n      if (shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(false);\n      }\n    }\n  }\n\n  function addTracks(tracks: Array<SourceTrack>) {\n    const supportedTracks = tracks.filter(isContentTypeSupported);\n\n    // We don't want updates to videoModel for each track during load.\n    shakaPlayer.removeEventListener('trackschanged', shakaEventHandlers.trackschanged);\n\n    // If the same source track was added earlier, and is readded, then just refurbish and un-blacklist the entry.\n    const freshTracks = ingestAndFilterEarlierAddedTracks(supportedTracks);\n    return updateManagedTrackListFromAddedTracks(\n      freshTracks.map(sourceTrack => {\n        let contentType = sourceTrack.contentType;\n        const charsetPos = contentType ? contentType.indexOf(';charset') : -1;\n        if (charsetPos > 0) {\n          contentType = contentType && contentType.substr(0, charsetPos);\n        }\n        return {\n          addPromise: shakaPlayer.addTextTrack(\n            sourceTrack.src,\n            sourceTrack.language,\n            sourceTrack.kind,\n            contentType,\n            null,\n            sourceTrack.label\n          ),\n          sourceTrack: sourceTrack\n        };\n      })\n    ).then(() => {\n      // Now we are ready again for other track change events coming from the stream etc.\n      shakaPlayer.addEventListener('trackschanged', shakaEventHandlers.trackschanged);\n      update(true);\n    });\n  }\n\n  function updateFromShakaTextTracks() {\n    const shakaTracks = shakaPlayer.getTextTracks() || [];\n    //logger.debug('trackschanged fired.', shakaTracks);\n    if (shakaTracks.length === 0) {\n      // Don't spend CPU cycles comparing the old and new track list when the new list is empty.\n      /*if (managedTextTracks.length === 0) {\n        logger.debug('No Shaka text tracks reported.');\n      } else {\n        logger.debug('No Shaka text tracks reported. Emptying the list.');\n      }*/\n      emptyManagedTextTrackList();\n    } else {\n      // Keep existing managed tracks untouched. This includes blacklisting.\n      const newManagedTrackList = managedTextTracks.filter(managedTrack => {\n        const equalTracks = shakaTracks.filter(shakaTrack => isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack));\n        return equalTracks.length === 1;\n      });\n\n      const isRemoving = newManagedTrackList.length < managedTextTracks.length;\n      const isAdding = shakaTracks.length > newManagedTrackList.length;\n\n      if (isAdding) {\n        const freshTracks = shakaTracks.filter(shakaTrack => {\n          const equalTracks = newManagedTrackList.filter(managedTrack =>\n            isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack)\n          );\n          return equalTracks.length === 0;\n        });\n        const newManagedTracks = freshTracks.map(shakaTrack => ({\n          sourceTrack: null,\n          shakaTrack: shakaTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(shakaTrack.id, 'in-stream', shakaTrack),\n          isLoaded: true,\n          error: null\n        }));\n        managedTextTracks = newManagedTrackList.concat(newManagedTracks);\n        update(true);\n      } else if (isRemoving) {\n        managedTextTracks = newManagedTrackList;\n        update(true);\n      }\n    }\n  }\n\n  function blacklistExistingSideLoadedTracks() {\n    const selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    managedTextTracks\n      .filter(managedTrack => {\n        return managedTrack.sourceTrack != null;\n      })\n      .forEach(managedTrack => {\n        if (managedTrack.selectableTrack) {\n          managedTrack.selectableTrack = null;\n        }\n        if (\n          selectedTrack &&\n          managedTrack.shakaTrack &&\n          managedTrack.shakaTrack.active &&\n          isShakaTrackEqual(selectedTrack, managedTrack.shakaTrack)\n        ) {\n          shakaPlayer.setTextTrackVisibility(false);\n        }\n        managedTrack.isBlacklisted = true;\n      });\n  }\n\n  function handleSourcePropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    const source = normalizeSource(props.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    blacklistExistingSideLoadedTracks();\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    blacklistExistingSideLoadedTracks();\n  }\n\n  function handleSelectedTextTrackChange(textTrack: ?AvailableTrack) {\n    const managedTrack = textTrack && managedTextTracks.filter(mt => mt.selectableTrack === textTrack)[0];\n    selectShakaTrack(managedTrack && managedTrack.shakaTrack);\n  }\n\n  const shakaEventHandlers = {\n    loading: emptyManagedTextTrackList,\n    trackschanged: updateFromShakaTextTracks,\n    texttrackvisibility: () => update(false)\n  };\n\n  function cleanup() {\n    emptyManagedTextTrackList();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n}\n\nexport default getShakaTextTrackManager;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { ShakaLanguageRole, ShakaPlayer, ShakaTrack } from './types';\nimport type { AudioTrackManager } from '../common/types';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedAudioTrack = {\n  language: string,\n  role: string,\n  selectableTrack: AvailableTrack\n};\n\nconst createManagedTrack = ({ language, role }: ShakaLanguageRole, index: number): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: language + role || index,\n      kind: role,\n      label: '',\n      language: language,\n      origin: 'in-stream'\n    },\n    language,\n    role\n  };\n};\n\nconst isTrackMatchingLanguageAndRole = (shakaTrack: ShakaTrack, { language, role }: ShakaLanguageRole) => {\n  return shakaTrack.language === language && (!role || (shakaTrack.roles && shakaTrack.roles.indexOf(role) >= 0));\n};\n\nconst getShakaAudioTrackManager = (\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function updateCurrentAudioTrack() {\n    const activeShakaTrack = shakaPlayer.getVariantTracks().filter(track => track.active)[0];\n    const currentAudioTrack =\n      activeShakaTrack &&\n      managedTracks.filter(mt => isTrackMatchingLanguageAndRole(activeShakaTrack, mt)).map(mt => mt.selectableTrack)[0];\n    updateStreamState({ currentAudioTrack });\n  }\n\n  function updateAudioTracks() {\n    managedTracks = shakaPlayer.getAudioLanguagesAndRoles().map(createManagedTrack);\n    const audioTracks = managedTracks.map(mt => mt.selectableTrack);\n    updateStreamState({\n      audioTracks\n    });\n    updateCurrentAudioTrack();\n  }\n\n  const shakaEventHandlers = {\n    loading: updateAudioTracks,\n    trackschanged: updateAudioTracks,\n    adaptation: updateCurrentAudioTrack\n  };\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      shakaPlayer.selectAudioLanguage(managedTrack.language, managedTrack.role);\n      updateCurrentAudioTrack();\n    }\n  }\n\n  function handleSourceChange() {\n    managedTracks.length = 0;\n  }\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getShakaAudioTrackManager;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport type { ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport { shakaSetup, shakaCleanup } from './shakaSetup';\nimport getStreamRangeHelper from './shakaStreamRangeHelper';\nimport getSourceChangeHandler from './shakaSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport getShakaEventHandlers from './shakaEventHandlers';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getShakaBitrateManager from './shakaBitrateManager';\nimport getShakaTextTrackManager from './shakaTextTrackManager';\nimport getShakaAudioTrackManager from './shakaAudioTrackManager';\nimport mapShakaError from './shakaErrorMapper';\n\nexport type ShakaVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  shakaPlayer?: ?{\n    installPolyfills?: boolean,\n    customConfiguration?: any // Actually the config structure that can be passed to shaka.Player::configure.\n  }\n};\n\nexport type ShakaVideoStreamerProps = VideoStreamerImplProps<ShakaVideoStreamerConfiguration> & {\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter\n};\n\nfunction resolveImplementation(\n  streamer: SimplifiedVideoStreamer<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps>,\n  configuration: ?ShakaVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement\n): Promise<StreamerImplementationParts<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps, ShakaPlayer>> {\n  let shakaPlayer;\n  try {\n    shakaPlayer = shakaSetup(videoElement, configuration);\n  } catch (e) {\n    return Promise.reject(mapShakaError(false, e));\n  }\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, shakaPlayer, configuration); // S\n  const handleSourceChange = getSourceChangeHandler(shakaPlayer); // S\n  const updateStreamState = getFilteredStreamStateUpdater(streamer); // G\n\n  const textTrackManager = getShakaTextTrackManager(shakaPlayer, updateStreamState);\n  const audioTrackManager = getShakaAudioTrackManager(shakaPlayer, updateStreamState);\n  const bitrateManager = getShakaBitrateManager(\n    streamer,\n    shakaPlayer,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const shakaEventHandlers = getShakaEventHandlers({\n    streamer,\n    videoElement,\n    shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = shakaEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    shakaEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    audioTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    shakaEventHandlers.cleanup();\n    bitrateManager.cleanup();\n    return shakaCleanup(shakaPlayer);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = shakaPlayer;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n}\n\nconst ShakaVideoStreamer = createVideoStreamerComponent('ShakaVideoStreamer', resolveImplementation);\n\nexport default ShakaVideoStreamer;\n","// @flow\nimport type { ShakaPlayer } from './types';\nimport shaka from 'shaka-player';\nimport type { ShakaVideoStreamerConfiguration } from './ShakaVideoStreamer';\nimport { PlaybackError } from '../types';\n\nexport function shakaSetup(\n  videoElement: HTMLVideoElement,\n  configuration: ?ShakaVideoStreamerConfiguration\n): ShakaPlayer {\n  if (!!window.MediaSource && !!MediaSource.isTypeSupported) {\n    const shakaPlayerConfig = configuration && configuration.shakaPlayer;\n    if (shakaPlayerConfig && shakaPlayerConfig.installPolyfills) {\n      shaka.polyfill.installAll();\n    }\n    const shakaPlayer = new shaka.Player(videoElement);\n    if (shakaPlayerConfig && shakaPlayerConfig.customConfiguration) {\n      shakaPlayer.configure(shakaPlayerConfig.customConfiguration);\n    }\n    return shakaPlayer;\n  } else {\n    throw new PlaybackError(\n      'STREAM_ERROR_TECHNOLOGY_UNSUPPORTED',\n      'shaka',\n      'MPEG-DASH playback with Shaka Player is not supported in this browser.'\n    );\n  }\n}\n\nexport function shakaCleanup(shakaPlayer: ShakaPlayer) {\n  return Promise.resolve(shakaPlayer && shakaPlayer.destroy());\n}\n"],"sourceRoot":""}