{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/HtmlVideoStreamer/fairPlaySourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/HtmlVideoStreamer/HtmlVideoStreamer.js"],"names":["keyStr","technology","RequestError","status","url","message","method","_this","_classCallCheck","this","_getPrototypeOf","call","_defineProperty","_assertThisInitialized","Error","getRequestError","xhr","arguments","length","undefined","PlaybackError","stringToArray","string","buffer","ArrayBuffer","array","Uint16Array","i","strLen","charCodeAt","arrayToString","String","fromCharCode","apply","base64EncodeUint8Array","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","output","Number","NaN","isNaN","charAt","concatInitDataIdAndCertificate","isBase64","initData","contentId","cert","offset","byteLength","dataView","DataView","Uint8Array","set","setUint32","idArray","getFairPlayLicenseAcquirer","videoElement","acquisitionDetails","onError","log","window","keySystem","contentIdExtractMatch","fairPlayCertificateUrl","licenseRequestHeaders","Object","entries","map","_ref","_ref2","_slicedToArray","name","value","isBinary","requestFormat","certificate","licenseUrl","addEventListener","onNeedKey","cleanup","event","idString","replace","regex","RegExp","exec","matches","extractContentId","webkitKeys","webkitSetMediaKeys","WebKitMediaKeys","substring","indexOf","createKeySession","handleError","request","XMLHttpRequest","responseType","response","open","send","keySession","createSession","licenseRequestReady","onkeyadded","onkeyerror","session","target","arrayBuffer","update","keyText","responseText","trim","substr","slice","raw","atob","rawLength","base64DecodeUint8Array","forEach","_ref3","setRequestHeader","spc","encodeURIComponent","toString","formatRequestPayloadAsPostParameters","code","error","removeEventListener","playbackError","getSourceChangeHandler","previousSession","handleBasicSourceChange","getBasicSourceChangeHandler","nextProps","prevProps","source","configuration","normalizedSource","normalizeSource","config","licenseAcquisition","fairPlay","licenseAcquisitionDetails","serviceCertificateUrl","fairPlayRequestFormat","hydrateLicenseAquisitionDetails","onPlaybackError","HtmlVideoStreamer","createVideoStreamerComponent","getImplementationResolver"],"mappings":"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","file":"static/js/49.6ed5c347.js","sourcesContent":["// @flow\nimport { PlaybackError } from '../types';\nimport type { FairPlayRequestFormat, PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport getBasicSourceChangeHandler from '../BasicVideoStreamer/sourceChangeHandler';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype LicenseAcquisitionDetails = {\n  licenseUrl: string,\n  licenseRequestHeaders?: { [string]: string },\n  fairPlayCertificateUrl: string,\n  requestFormat: FairPlayRequestFormat,\n  contentId: ?(string | number),\n  contentIdExtractMatch: ?(RegExp | string)\n};\n\nconst keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst technology = 'html';\n\nclass RequestError extends Error {\n  constructor(status: number, url: string, message: string, method: 'GET' | 'POST') {\n    super(message);\n    this.status = status;\n    this.url = url;\n    this.method = method;\n  }\n  status: number;\n  url: string;\n  method: 'GET' | 'POST';\n}\n\nfunction getRequestError(xhr, url, message, method = 'GET') {\n  return new PlaybackError(\n    'STREAM_ERROR_DOWNLOAD',\n    technology,\n    message,\n    'FATAL',\n    new RequestError(xhr.status, url, message, method)\n  );\n}\n\nfunction stringToArray(string: string) {\n  const buffer = new ArrayBuffer(string.length * 2); // 2 bytes for each char\n  const array = new Uint16Array(buffer);\n  for (let i = 0, strLen = string.length; i < strLen; i++) {\n    array[i] = string.charCodeAt(i);\n  }\n  return array;\n}\n\nfunction arrayToString(array) {\n  return String.fromCharCode.apply(null, new Uint16Array(array.buffer));\n}\n\nfunction base64DecodeUint8Array(input) {\n  const raw = window.atob(input);\n  const rawLength = raw.length;\n  const array = new Uint8Array(new ArrayBuffer(rawLength));\n  for (let i = 0; i < rawLength; i++) {\n    array[i] = raw.charCodeAt(i);\n  }\n  return array;\n}\n\nfunction base64EncodeUint8Array(input) {\n  let output = '';\n  let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n  let i = 0;\n\n  while (i < input.length) {\n    chr1 = input[i++];\n    chr2 = i < input.length ? input[i++] : Number.NaN;\n    chr3 = i < input.length ? input[i++] : Number.NaN;\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2)) {\n      enc3 = enc4 = 64;\n    } else if (isNaN(chr3)) {\n      enc4 = 64;\n    }\n    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);\n  }\n  return output;\n}\n\nfunction extractContentId(initData, contentIdExtractMatch: ?(string | RegExp)) {\n  const url = arrayToString(initData);\n  const regex = contentIdExtractMatch\n    ? typeof contentIdExtractMatch === 'string'\n      ? new RegExp(contentIdExtractMatch)\n      : contentIdExtractMatch\n    : /([0-9]+)$/;\n  if (regex.exec) {\n    const matches = regex.exec(url);\n    return matches && matches[0];\n  }\n}\n\nfunction concatInitDataIdAndCertificate(\n  isBase64: boolean,\n  initData: Uint8Array,\n  contentId: Uint16Array | string | number,\n  cert: Uint8Array\n) {\n  if (typeof contentId === 'string') {\n    contentId = stringToArray(contentId);\n  } else if (typeof contentId === 'number') {\n    contentId = stringToArray('' + contentId);\n  }\n  // layout is [initData][4 byte: idLength][idLength byte: contentId][4 byte:certLength][certLength byte: cert]\n  let offset = 0;\n  const buffer = new ArrayBuffer(initData.byteLength + 4 + contentId.byteLength + 4 + cert.byteLength);\n  const dataView = new DataView(buffer);\n\n  const initDataArray = new Uint8Array(buffer, offset, initData.byteLength);\n  initDataArray.set(initData);\n  offset += initData.byteLength;\n\n  dataView.setUint32(offset, contentId.byteLength, true);\n  offset += 4;\n\n  const idArray = isBase64\n    ? new Uint8Array(buffer, offset, contentId.byteLength)\n    : new Uint16Array(buffer, offset, contentId.length);\n  idArray.set(contentId);\n  offset += idArray.byteLength;\n\n  dataView.setUint32(offset, cert.byteLength, true);\n  offset += 4;\n\n  const certArray = new Uint8Array(buffer, offset, cert.byteLength);\n  certArray.set(cert);\n\n  return new Uint8Array(buffer, 0, buffer.byteLength);\n}\n\nfunction formatRequestPayloadAsPostParameters(spc, contentId?: ?(string | number)) {\n  if (contentId) {\n    return (\n      'contentId=' + encodeURIComponent(contentId.toString()) + 'spc=' + encodeURIComponent(base64EncodeUint8Array(spc))\n    );\n  } else {\n    return 'spc=' + encodeURIComponent(base64EncodeUint8Array(spc));\n  }\n}\n\nconst getFairPlayLicenseAcquirer = (\n  videoElement: HTMLVideoElement,\n  acquisitionDetails: LicenseAcquisitionDetails,\n  onError: ?(PlaybackError) => void,\n  log?: (string, any) => void\n) => {\n  if (!(acquisitionDetails && 'WebKitMediaKeys' in window)) {\n    return;\n  }\n  const keySystem = 'com.apple.fps.1_0';\n  const { contentIdExtractMatch, fairPlayCertificateUrl } = acquisitionDetails;\n  const licenseRequestHeaders =\n    (acquisitionDetails.licenseRequestHeaders &&\n      Object.entries(acquisitionDetails.licenseRequestHeaders).map(([name, value]) => ({\n        name,\n        value\n      }))) ||\n    [];\n  const isBinary = acquisitionDetails.requestFormat === 'binary';\n  const isBase64 = acquisitionDetails.requestFormat === 'base64';\n  let certificate = null;\n  let { contentId, licenseUrl } = acquisitionDetails;\n\n  function onNeedKey(event: { initData: Uint8Array }) {\n    const initData = event.initData;\n    const idString = isBinary\n      ? arrayToString(initData).replace(/^.*:\\/\\//, '')\n      : contentId || extractContentId(initData, contentIdExtractMatch);\n\n    if (isBinary) {\n      log && log('Content ID extracted from initData.', contentId);\n    } else if (!contentId) {\n      log && log('Content ID extracted from initData.', contentId);\n    }\n\n    // $FlowFixMe\n    if (!videoElement.webkitKeys) {\n      // $FlowFixMe\n      videoElement.webkitSetMediaKeys(new window.WebKitMediaKeys(keySystem));\n    }\n\n    // $FlowFixMe\n    if (!videoElement.webkitKeys) {\n      handleError(\n        new PlaybackError('STREAM_ERROR_DRM_CLIENT_UNAVAILABLE', technology, 'Safari EME API not available.')\n      );\n      return;\n    }\n\n    if (!licenseUrl) {\n      const url = arrayToString(initData).substring(1);\n      licenseUrl = url.substring(url.indexOf('/', url.indexOf('://') + 3));\n    }\n    if (idString) {\n      if (certificate) {\n        if (!createKeySession(idString, concatInitDataIdAndCertificate(isBase64, initData, idString, certificate))) {\n          handleError(\n            new PlaybackError('STREAM_ERROR_DRM_CLIENT_UNAVAILABLE', technology, 'Could not create key session.')\n          );\n          return;\n        }\n      } else {\n        // load certificate\n        const request = new XMLHttpRequest();\n        request.responseType = 'arraybuffer';\n        request.addEventListener('load', () => {\n          if (request.status && request.status < 400) {\n            certificate = new Uint8Array(request.response);\n            if (createKeySession(idString, concatInitDataIdAndCertificate(isBase64, initData, idString, certificate))) {\n              handleError(\n                new PlaybackError('STREAM_ERROR_DRM_CLIENT_UNAVAILABLE', technology, 'Could not create key session.')\n              );\n              return;\n            }\n          } else {\n            handleError(getRequestError(request, fairPlayCertificateUrl, 'Download of FairPlay certificate failed.'));\n            return;\n          }\n        });\n        request.addEventListener(\n          'error',\n          () =>\n            handleError(\n              getRequestError(request, fairPlayCertificateUrl, 'Download of FairPlay certificate was blocked.')\n            ),\n          false\n        );\n        request.addEventListener(\n          'timeout',\n          () =>\n            handleError(\n              getRequestError(request, fairPlayCertificateUrl, 'Download of FairPlay certificate timed out.')\n            ),\n          false\n        );\n        request.open('GET', fairPlayCertificateUrl, true);\n        request.send();\n      }\n    } else {\n      handleError(\n        new PlaybackError(\n          'STREAM_ERROR',\n          technology,\n          'No content ID available. Cannot complete FairPlay license acquisition.',\n          'FATAL'\n        )\n      );\n    }\n  }\n\n  function createKeySession(contentId, initData) {\n    // $FlowFixMe Safari specific APIs.\n    const keySession = videoElement.webkitKeys.createSession('video/mp4', initData);\n    if (!keySession) {\n      return false;\n    }\n    keySession.contentId = contentId;\n    // keySession.licenseURL = licenseUrl;\n    keySession.addEventListener('webkitkeymessage', licenseRequestReady, false);\n    keySession.addEventListener('webkitkeyadded', onkeyadded, false);\n    keySession.addEventListener('webkitkeyerror', onkeyerror, false);\n  }\n\n  function licenseRequestReady(event) {\n    log && log('Key session ready for license request.');\n    const session = event.target;\n    const message = event.message;\n    const request = new XMLHttpRequest();\n    request.responseType = isBinary ? 'arraybuffer' : 'text';\n\n    request.addEventListener('load', () => {\n      if (request.status && request.status < 400) {\n        if (isBinary) {\n          const arrayBuffer = request.response;\n          session.update(new Uint8Array(arrayBuffer));\n        } else {\n          // response can be of the form: '\\n<ckc>base64encoded</ckc>\\n'\n          // so trim the excess:\n          let keyText = request.responseText.trim();\n          if (keyText.substr(0, 5) === '<ckc>' && keyText.substr(-6) === '</ckc>') {\n            keyText = keyText.slice(5, -6);\n          }\n          session.update(base64DecodeUint8Array(keyText));\n        }\n      } else {\n        handleError(getRequestError(request, licenseUrl, 'Acquisition of FairPlay license failed.', 'POST'));\n      }\n    });\n    request.addEventListener(\n      'error',\n      () =>\n        handleError(getRequestError(request, fairPlayCertificateUrl, 'Acquisition of FairPlay license was blocked.')),\n      false\n    );\n    request.addEventListener(\n      'timeout',\n      () => handleError(getRequestError(request, fairPlayCertificateUrl, 'Acquisition of FairPlay license timed out.')),\n      false\n    );\n\n    request.open('POST', licenseUrl, true);\n    licenseRequestHeaders.forEach(function({ name, value }) {\n      request.setRequestHeader(name, value);\n    });\n    if (isBinary) {\n      request.setRequestHeader('Content-type', 'application/octet-stream');\n      request.send(message);\n    } else if (isBase64) {\n      request.send(base64EncodeUint8Array(message));\n    } else {\n      request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n      request.send(formatRequestPayloadAsPostParameters(message, contentId));\n    }\n  }\n\n  function onkeyadded(event) {\n    log && log('Decryption key added', event);\n  }\n\n  function onkeyerror(event: any) {\n    const code = (event.target && event.target.error && event.target.error.code) || 0;\n    if (code === 6 || code === 4) {\n      const message =\n        'FairPlay blocked the playback because of non-secure output path, e.g. external VGA screen connected.';\n      handleError(\n        new PlaybackError(\n          'STREAM_ERROR_DRM_OUTPUT_BLOCKED',\n          technology,\n          message,\n          'FATAL',\n          event.target && event.target.error\n        )\n      );\n    } else {\n      handleError(\n        new PlaybackError(\n          'STREAM_ERROR_DECODE',\n          technology,\n          'Could not decrypt FairPlay stream.',\n          'FATAL',\n          event.target && event.target.error\n        )\n      );\n    }\n    cleanup();\n  }\n\n  // $FlowFixMe Safari EME specific stuff.\n  videoElement.addEventListener('webkitneedkey', onNeedKey, false);\n\n  function cleanup() {\n    // $FlowFixMe Safari EME specific stuff.\n    videoElement.removeEventListener('webkitneedkey', onNeedKey, false);\n  }\n\n  function handleError(playbackError) {\n    if (onError) {\n      onError(playbackError);\n    }\n    cleanup();\n  }\n\n  return {\n    cleanup\n  };\n};\n\nfunction hydrateLicenseAquisitionDetails(source: ?PlaybackSource, configuration: ?VideoStreamerConfiguration) {\n  const normalizedSource = normalizeSource(source);\n  if (normalizedSource && normalizedSource.licenseUrl) {\n    const licenseUrl = normalizedSource.licenseUrl;\n    const config =\n      (configuration && configuration.licenseAcquisition && configuration.licenseAcquisition.fairPlay) || {};\n    const licenseAcquisitionDetails = normalizedSource.licenseAcquisitionDetails || {};\n\n    const fairPlayCertificateUrl = licenseAcquisitionDetails.fairPlayCertificateUrl || config.serviceCertificateUrl;\n    const contentIdExtractMatch = licenseAcquisitionDetails.contentIdExtractMatch || config.contentIdExtractMatch;\n\n    const requestFormat = licenseAcquisitionDetails.fairPlayRequestFormat || config.requestFormat || 'formdata';\n    const licenseRequestHeaders = licenseAcquisitionDetails.licenseRequestHeaders;\n    const contentId = licenseAcquisitionDetails.contentId;\n\n    if (!fairPlayCertificateUrl) {\n      return null;\n    }\n    return {\n      licenseUrl,\n      licenseRequestHeaders,\n      fairPlayCertificateUrl,\n      requestFormat,\n      contentId,\n      contentIdExtractMatch\n    };\n  } else {\n    return null;\n  }\n}\n\nfunction getSourceChangeHandler(videoElement: HTMLVideoElement) {\n  const handleBasicSourceChange = getBasicSourceChangeHandler(videoElement);\n  let previousSession;\n\n  const handleSourceChange = <\n    P: {\n      source?: ?PlaybackSource,\n      configuration?: ?VideoStreamerConfiguration,\n      onPlaybackError?: PlaybackError => void\n    }\n  >(\n    nextProps: P,\n    prevProps: ?P\n  ) => {\n    if (previousSession) {\n      previousSession.cleanup();\n    }\n    const acquisitionDetails = hydrateLicenseAquisitionDetails(nextProps.source, nextProps.configuration);\n    if (acquisitionDetails) {\n      previousSession = getFairPlayLicenseAcquirer(videoElement, acquisitionDetails, nextProps.onPlaybackError);\n    }\n    return handleBasicSourceChange(nextProps, prevProps);\n  };\n  return handleSourceChange;\n}\n\nexport default getSourceChangeHandler;\n","// @flow\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport { getImplementationResolver } from '../BasicVideoStreamer/BasicVideoStreamer';\nimport getSourceChangeHandler from './fairPlaySourceChangeHandler';\n\nconst HtmlVideoStreamer = createVideoStreamerComponent(\n  'HtmlVideoStreamer',\n  getImplementationResolver(getSourceChangeHandler)\n);\n\nexport default HtmlVideoStreamer;\n"],"sourceRoot":""}