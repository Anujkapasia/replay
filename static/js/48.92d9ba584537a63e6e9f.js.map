{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSetup.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsTextTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/HlsjsVideoStreamer.js"],"names":["broadcastHlsInstance","instanceKeeper","preposition","hls","subscribers","forEach","subscriber","hlsjsSetup","videoElement","configuration","Promise","resolve","reject","Hls","isSupported","customConfiguration","hlsjs","hlsConfig","_objectSpread","autoStartLoad","debug","logLevel","enableWorker","on","Events","MEDIA_ATTACHED","attachMedia","PlaybackError","hlsjsCleanup","stopLoad","destroy","dawnOfTime","Date","minimumDvrLength","getStreamRangeHelper","_hlsjsEventHandlers","streamStartDate","liveMargin","liveEdgeMargin","levelDuration","isLive","reset","hlsjsEventHandlers","hlsjsStreamRangeHelper_defineProperty","MANIFEST_LOADING","LEVEL_LOADED","evt","data","details","live","totalduration","programDateTime","fragments","push","hlsInstance","Object","entries","_ref","_ref2","_slicedToArray","name","handler","adjustForDvrStartOffset","calculateNewState","position","Math","max","currentTime","duration","_getAbsolutePositions","startDateTime","isNaN","absolutePosition","getTime","absoluteStartPosition","getAbsolutePositions","playMode","Infinity","resolvePlayMode","isAtLiveEdge","liveSyncPosition","config","liveSyncDuration","liveSyncDurationCount","getIsAtLiveEdge","setPosition","newPosition","gotoLive","getSourceChangeHandler","nextProps","prevProps","source","normalizeSource","then","MANIFEST_PARSED","onMediaLoaded","off","startPosition","startLoad","e","loadSource","streamUrl","getDistinctPseudoTracks","audioTracks","foundKeys","filter","track","key","concat","lang","isNotAdded","indexOf","map","id","language","kind","label","origin","equalOrNoneSpecified","a","b","equalOrNotSpecified","isAudioTrackListsDifferent","length","i","getAudioTrackManager","update","mapAudioTracks","currentTracks","updateStreamStateProps","currentAudioTrack","currentHlsAudioTrack","ht","audioTrack","refresh","hlsjsAudioTrackManager_defineProperty","AUDIO_TRACK_SWITCHED","_ref3","hlsjsAudioTrackManager_slicedToArray","cleanup","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","st","groupId","matchingTrack","trackModeMappings","getTrackMode","textTrack","mode","setTrackMode","newMode","isEqual","Number","createSelectableTrack","videoElementTrack","getHlsjsTextTrackManager","updateTrackElementData","managedTracks","currentTextTrack","selectableTextTracks","emptyTracks","unique","Cue","window","VTTCue","TextTrackCue","notifyPropertyChanges","m","selectableTrack","textTracks","isShallowEqual","addTracks","sourceTracks","Array","isArray","removeEventListener","handleTrackAdd","handleTrackRemove","freshManagedTracks","sourceTrack","managedTrackMatches","managedTrack","cues","ac","bc","cue","index","start","end","content","src","isSourceTracksEqual","isBlacklisted","alreadyAddedTrack","isLoaded","addTextTrack","addCue","loadPromise","trackElementData","srclang","onRef","trackElement","t","handleLoad","handleError","addEventListener","undefined","all","updateFromVideoElement","textTracksList","videoElementTracks","cleanedUpManagedTracks","cleanupTracks","isNewSession","vt","removeCue","handleSelectedTextTrackChange","selectedTextTrack","mt","subtitleDisplay","handleTextTracksPropChange","newProps","handleSourcePropChange","newTracks","clear","getBitrateAsKbps","level","ceil","bitrate","getHlsjsBitrateManager","streamer","updateStreamState","log","previousBitrates","updateBitrateProps","hlsEvent","eventData","bitrates","levels","currentLevel","LEVEL_SWITCHED","startLevel","currentBitrate","hlsjsBitrateManager_defineProperty","LEVEL_UPDATED","hlsjsBitrateManager_slicedToArray","fixBitrate","nextLevel","bitrateFix","capBitrate","cap","autoLevelCapping","bitrateCap","reached","tech","ed","ErrorDetails","downloadErrors","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","AUDIO_TRACK_LOAD_ERROR","AUDIO_TRACK_LOAD_TIMEOUT","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","KEY_LOAD_ERROR","KEY_LOAD_TIMEOUT","decodeErrors","MANIFEST_PARSING_ERROR","MANIFEST_INCOMPATIBLE_CODECS_ERROR","FRAG_DECRYPT_ERROR","BUFFER_ADD_CODEC_ERROR","FRAG_PARSING_ERROR","getHlsjsEventHandlers","streamRangeHelper","applyProperties","htmlVideoHandlers","getBasicVideoEventHandlers","videoElementEventHandlers","pauseStreamRangeUpdater","lifeCycleManager","setStage","_","getStage","handleActualError","detail","severity","code","playbackError","fatal","message","type","reason","buildMessage","props","onPlaybackError","error","playState","isBuffering","isSeeking","stop","hlsjsEventHandlers_defineProperty","ERROR","BUFFER_STALLED_ERROR","BUFFER_SEEK_OVER_HOLE","BUFFER_NUDGE_ON_STALL","url","endsWith","initialPlaybackProps","_streamer$props$initi","isMuted","volume","muted","isPipAvailable","FRAG_BUFFERED","_streamer$props$initi2","isPaused","pause","hlsjsEventHandlers_slicedToArray","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","onError","setLifeCycleManager","manager","HlsjsVideoStreamer","createVideoStreamerComponent","onTrackElementDataChange","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","getHlsjsAudioTrackManager","bitrateManager","getArrayLogger","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","thirdPartyPlayer","render","renderWithoutSource"],"mappings":"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","file":"static/js/48.2c5a2f49.js","sourcesContent":["// @flow\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport { PlaybackError } from '../types';\n\nexport function broadcastHlsInstance(instanceKeeper: HlsjsInstanceKeeper, preposition: 'on' | 'off') {\n  const { hls } = instanceKeeper;\n  hls && instanceKeeper.subscribers.forEach(subscriber => subscriber(hls, preposition));\n}\n\nexport function hlsjsSetup(\n  videoElement: HTMLVideoElement,\n  configuration: ?HlsjsVideoStreamerConfiguration\n): Promise<Hls> {\n  return new Promise((resolve, reject) => {\n    if (Hls.isSupported()) {\n      const customConfiguration = configuration && configuration.hlsjs && configuration.hlsjs.customConfiguration;\n      const hlsConfig: any = {\n        autoStartLoad: false,\n        debug: configuration && configuration.logLevel === 'DEBUG',\n        enableWorker: false,\n        ...customConfiguration\n      };\n      const hls = new Hls(hlsConfig);\n      hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n        resolve(hls);\n      });\n      hls.attachMedia(videoElement);\n    } else {\n      reject(\n        new PlaybackError('STREAM_ERROR_TECHNOLOGY_UNSUPPORTED', 'hlsjs', 'Hls.js is not supported in this browser.')\n      );\n    }\n  });\n}\n\nexport function hlsjsCleanup(instanceKeeper: HlsjsInstanceKeeper) {\n  const { hls } = instanceKeeper;\n  if (hls) {\n    hls.stopLoad();\n    broadcastHlsInstance(instanceKeeper, 'off');\n    return Promise.resolve(hls.destroy());\n  } else {\n    return Promise.resolve();\n  }\n}\n","// @flow\nimport type { PlayMode } from '../types';\nimport Hls from 'hls.js';\nimport type { StreamRangeHelper } from '../common/types';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: ?Date,\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (isLive) {\n    if (!(startDateTime instanceof Date) || isNaN(startDateTime)) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: new Date(startDateTime.getTime() + position * 1000),\n        absoluteStartPosition: startDateTime\n      };\n    }\n  } else {\n    return {\n      absolutePosition: dawnOfTime,\n      absoluteStartPosition: dawnOfTime\n    };\n  }\n}\n\nfunction getIsAtLiveEdge(hls, videoElement, isLive, liveMargin) {\n  if (isLive) {\n    if (hls.liveSyncPosition) {\n      return videoElement.currentTime > hls.liveSyncPosition - liveMargin;\n    } else if (hls.config && hls.config.liveSyncDuration) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n    } else if (hls.config && hls.config.liveSyncDurationCount) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n  let levelDuration = 0;\n  let streamStartDate: ?Date;\n  let isLive = false;\n  let hls;\n\n  function calculateNewState() {\n    let position;\n\n    if (levelDuration) {\n      position = Math.max((videoElement.currentTime || 0) - Math.max(videoElement.duration - levelDuration, 0), 0);\n    } else {\n      position = videoElement.currentTime || 0;\n    }\n    const duration = levelDuration || videoElement.duration;\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(isLive, streamStartDate, position);\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = hls && getIsAtLiveEdge(hls, videoElement, isLive, liveMargin);\n\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    /* Handled by hls.js itself? */\n  }\n\n  function setPosition(newPosition: number) {\n    if (\n      !(\n        isNaN(newPosition) ||\n        newPosition === Infinity ||\n        isNaN(videoElement.duration) ||\n        videoElement.duration === Infinity\n      )\n    ) {\n      if (levelDuration) {\n        videoElement.currentTime = newPosition + videoElement.duration - levelDuration;\n      } else {\n        videoElement.currentTime = newPosition;\n      }\n    }\n  }\n\n  function gotoLive() {\n    if (isLive && hls) {\n      if (hls.liveSyncPosition) {\n        videoElement.currentTime = hls.liveSyncPosition;\n      } else if (hls.config && hls.config.liveSyncDuration) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n      } else if (hls.config && hls.config.liveSyncDurationCount) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n      } else {\n        videoElement.currentTime = videoElement.duration - liveMargin;\n      }\n    }\n  }\n\n  function reset() {\n    streamStartDate = null;\n    levelDuration = 0;\n    isLive = false;\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.LEVEL_LOADED]: (evt, data) => {\n      isLive = data.details.live;\n      levelDuration = data.details.totalduration;\n      // updateDuration();\n      const programDateTime =\n        data.details &&\n        data.details.fragments &&\n        data.details.fragments[0] &&\n        data.details.fragments[0].programDateTime;\n      if (programDateTime) {\n        streamStartDate = new Date(programDateTime);\n        // updatePosition();\n      }\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport Hls from 'hls.js';\nimport { PlaybackError } from '../types';\nimport { broadcastHlsInstance, hlsjsCleanup, hlsjsSetup } from './hlsjsSetup';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport normalizeSource from '../common/sourceNormalizer';\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  configuration?: ?C\n};\n\nconst getSourceChangeHandler = (instanceKeeper: HlsjsInstanceKeeper) => <\n  C: HlsjsVideoStreamerConfiguration,\n  P: Props<C>\n>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const { videoElement } = instanceKeeper;\n  hlsjsCleanup(instanceKeeper);\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    return hlsjsSetup(videoElement, nextProps.configuration).then(hls => {\n      instanceKeeper.hls = hls;\n      // window.hls = hls;\n      broadcastHlsInstance(instanceKeeper, 'on');\n      return new Promise((resolve, reject) => {\n        const onMediaLoaded = () => {\n          hls.off(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          try {\n            if (source.startPosition) {\n              hls.startLoad(source.startPosition);\n            } else {\n              hls.startLoad();\n            }\n            resolve();\n          } catch (e) {\n            reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load start failed.', 'FATAL', e));\n          }\n        };\n        try {\n          hls.on(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          hls.loadSource(source.streamUrl);\n        } catch (e) {\n          reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load failed.', 'FATAL', e));\n        }\n      });\n    });\n  } /* else if (prevProps && prevProps.source) {\n    // And no new source.\n    return Promise.resolve(instanceKeeper.hls && instanceKeeper.hls.stopLoad());\n  }*/ else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { AudioTrackManager } from '../common/types';\nimport type { HlsjsAudioTrack } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\n// http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\nconst getDistinctPseudoTracks = (audioTracks: ?Array<HlsjsAudioTrack>): Array<AvailableTrack> => {\n  const foundKeys = [];\n  return audioTracks\n    ? audioTracks\n        .filter(track => {\n          const key = `${track.lang || ''}!${track.name || ''}`;\n          const isNotAdded = foundKeys.indexOf(key) < 0;\n          if (isNotAdded) {\n            foundKeys.push(key);\n          }\n          return isNotAdded;\n        })\n        .map(track => ({\n          id: track.id,\n          language: track.lang || 'unknown',\n          kind: '',\n          label: track.name || 'unknown',\n          origin: 'in-stream'\n        }))\n    : [];\n};\n\nconst equalOrNoneSpecified = (a: ?(string | number), b: ?(string | number)) => (!a && !b) || a === b;\nconst equalOrNotSpecified = (a: ?(string | number), b: ?(string | number)) => !a || !b || a === b;\n\nconst isAudioTrackListsDifferent = (a: Array<AvailableTrack>, b: Array<AvailableTrack>) => {\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (\n        !equalOrNoneSpecified(a[i].id, b[i].id) ||\n        !equalOrNoneSpecified(a[i].language, b[i].language) ||\n        !equalOrNoneSpecified(a[i].label, b[i].label)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return true;\n  }\n};\n\nconst getAudioTrackManager = (\n  instanceKeeper: HlsjsInstanceKeeper,\n  update: VideoStreamState => void\n): AudioTrackManager => {\n  let audioTracks: Array<AvailableTrack> = [];\n  let hls;\n\n  function mapAudioTracks() {\n    if (hls) {\n      const currentTracks = getDistinctPseudoTracks(hls.audioTracks);\n      if (isAudioTrackListsDifferent(currentTracks, audioTracks)) {\n        audioTracks = currentTracks;\n      }\n    }\n  }\n\n  function updateStreamStateProps() {\n    let currentAudioTrack = null;\n    if (hls) {\n      const currentHlsAudioTrack = hls.audioTracks.filter(ht => ht.id === hls.audioTrack)[0];\n      if (currentHlsAudioTrack) {\n        const { name, lang } = currentHlsAudioTrack;\n        currentAudioTrack = audioTracks.filter(({ label, language }) => label === name && language === lang)[0];\n      }\n    }\n    update({ audioTracks, currentAudioTrack });\n  }\n\n  function refresh() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const st = selectedAudioTrack;\n    if (hls && hls.audioTracks && st) {\n      const groupId = (hls.audioTracks[hls.audioTrack] || {}).groupId;\n      const matchingTrack = hls.audioTracks.filter(\n        ht =>\n          equalOrNotSpecified(ht.groupId, groupId) &&\n          equalOrNotSpecified(ht.name, st.label) &&\n          equalOrNotSpecified(ht.lang, st.language)\n      )[0];\n      if (matchingTrack) {\n        hls.audioTrack = matchingTrack.id;\n      }\n    }\n  }\n\n  function reset() {\n    audioTracks = [];\n  }\n\n  function handleSourceChange() {\n    refresh();\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.MANIFEST_PARSED]: refresh,\n    [Hls.Events.AUDIO_TRACK_SWITCHED]: handleTrackChange\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    cleanup: () => {},\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getAudioTrackManager;\n","// @flow\n\n// https://github.com/video-dev/hls.js/issues/2147\n// https://github.com/video-dev/hls.js/issues/2198\n\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { TextTrackManager, TrackElementData } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\nexport type ManagedTextTrack = {\n  isBlacklisted: boolean,\n  sourceTrack: ?SourceTrack,\n  videoElementTrack?: ?TextTrack,\n  selectableTrack: ?AvailableTrack,\n  trackElementData?: ?TrackElementData,\n  loadPromise?: Promise<?TextTrack>,\n  isLoaded: boolean,\n  error?: any\n};\n\ntype HTMLTextTrackMode = 'disabled' | 'hidden' | 'showing';\n\n/*export type TextTracksStateProps = {\n  currentTextTrack?: ?AvailableTrack,\n  textTracks?: Array<AvailableTrack>\n};*/\n\nconst trackModeMappings = ['disabled', 'hidden', 'showing']; // Index corresponds with \"enum\" value.\n\nfunction getTrackMode(textTrack: TextTrack) {\n  const mode = textTrack.mode;\n  return typeof mode === 'number' ? trackModeMappings[mode] : mode;\n}\n\nfunction setTrackMode(textTrack: TextTrack, newMode: HTMLTextTrackMode) {\n  // $FlowFixMe Some browsers use numbers mapping to modes.\n  textTrack.mode = typeof textTrack.mode === 'number' ? trackModeMappings.indexOf(newMode) : newMode;\n}\n\nfunction isEqual(a: any, b: any): boolean {\n  return (Number.isNaN(a) && Number.isNaN(b)) || (a == null && b == null) || a === b;\n}\n\nfunction isVideoElementTrackValid(textTrack: TextTrack) {\n  // Detecting empty dummy tracks originating from HLS streams in Safari.\n  return (\n    (textTrack.kind !== 'metadata' && !('inBandMetadataTrackDispatchType' in textTrack)) ||\n    (textTrack.cues && textTrack.cues.length) ||\n    textTrack.label ||\n    textTrack.language\n  );\n}\n\nfunction isSourceTracksEqual(a: ?SourceTrack, b: ?SourceTrack): boolean {\n  if (a && b) {\n    if (a.cues && b.cues) {\n      const ac = a.cues,\n        bc = b.cues;\n      if (ac.length === bc.length) {\n        const isCuesDifferent =\n          ac.filter(\n            (cue, index) =>\n              cue.start === bc[index].start && cue.end === bc[index].end && cue.content === bc[index].content\n          ).length !== ac.length;\n        if (isCuesDifferent) {\n          return false;\n        }\n      }\n    }\n    return (\n      isEqual(a.language, b.language) && isEqual(a.kind, b.kind) && isEqual(a.label, b.label) && isEqual(a.src, b.src)\n    );\n  } else {\n    return isEqual(a, b);\n  }\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  videoElementTrack: TextTrack\n): AvailableTrack {\n  return {\n    id,\n    kind: videoElementTrack.kind || '',\n    label: videoElementTrack.label || '',\n    language: videoElementTrack.language || '',\n    origin\n  };\n}\n\nconst getHlsjsTextTrackManager = (\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  update: <T: VideoStreamState>(props: T) => void,\n  updateTrackElementData: (Array<TrackElementData>) => void\n): TextTrackManager => {\n  // Should use TextTracksStateProps above.\n  let managedTracks: Array<ManagedTextTrack> = [];\n  let currentTextTrack = null;\n  let selectableTextTracks = emptyTracks;\n  let unique = 0;\n  const Cue = window.VTTCue || window.TextTrackCue;\n\n  function notifyPropertyChanges() {\n    currentTextTrack = managedTracks\n      .filter(m => m.videoElementTrack != null && getTrackMode(m.videoElementTrack) === 'showing')\n      .map(m => m.selectableTrack)[0];\n\n    const textTracks = managedTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n    if (isShallowEqual(textTracks, selectableTextTracks)) {\n      // $FlowFixMe Complaints about null entries, despite filter above.\n      update({\n        currentTextTrack,\n        textTracks: selectableTextTracks\n      });\n    } else {\n      selectableTextTracks = textTracks;\n      update({\n        currentTextTrack,\n        textTracks\n      });\n    }\n  }\n\n  function addTracks(sourceTracks?: Array<SourceTrack>) {\n    if (Array.isArray(sourceTracks)) {\n      videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n      videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n\n      const freshSourceTracks = sourceTracks.filter(sourceTrack => {\n        const managedTrackMatches = managedTracks.filter(managedTrack => {\n          return isSourceTracksEqual(managedTrack.sourceTrack, sourceTrack) && !managedTrack.isBlacklisted;\n        });\n        if (managedTrackMatches.length === 0) {\n          return true;\n        } else {\n          const alreadyAddedTrack = managedTrackMatches[0];\n          alreadyAddedTrack.sourceTrack = sourceTrack;\n          alreadyAddedTrack.isBlacklisted = false;\n          alreadyAddedTrack.isLoaded = true; // Is this assumption correct?\n          return false;\n        }\n      });\n\n      const freshManagedTracks: Array<ManagedTextTrack> = freshSourceTracks.map(sourceTrack => {\n        const id = ++unique;\n        if (Array.isArray(sourceTrack.cues)) {\n          const cues = sourceTrack.cues;\n          const videoElementTrack = videoElement.addTextTrack('subtitles', sourceTrack.label, sourceTrack.language);\n          cues.forEach(cue => {\n            videoElementTrack.addCue(new Cue(cue.start, cue.end, cue.content));\n          });\n          return {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack,\n            selectableTrack: createSelectableTrack(id, 'side-loaded', videoElementTrack),\n            loadPromise: Promise.resolve(videoElementTrack),\n            isLoaded: true\n          };\n        } else {\n          const trackElementData: TrackElementData = {\n            src: sourceTrack.src,\n            srclang: sourceTrack.language,\n            kind: sourceTrack.kind || 'subtitles',\n            label: sourceTrack.label\n          };\n          const loadPromise = new Promise(resolve => {\n            trackElementData.onRef = (trackElement: ?HTMLTrackElement) => {\n              const t = trackElement;\n              if (t) {\n                setTrackMode(t.track, 'hidden');\n                const handleLoad = () => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve(t.track);\n                };\n                const handleError = (e: Event) => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve();\n                };\n                t.addEventListener('load', handleLoad);\n                t.addEventListener('error', handleError);\n              }\n            };\n          });\n          const managedTrack = {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack: undefined,\n            selectableTrack: undefined,\n            trackElementData,\n            loadPromise,\n            isLoaded: false\n          };\n          loadPromise.then(videoElementTrack => {\n            if (videoElementTrack != null) {\n              managedTrack.videoElementTrack = videoElementTrack;\n              managedTrack.selectableTrack = createSelectableTrack(id, 'side-loaded', videoElementTrack);\n            }\n            managedTrack.isLoaded = true;\n          });\n          return managedTrack;\n        }\n      });\n\n      managedTracks = managedTracks.concat(freshManagedTracks);\n\n      updateTrackElementData(\n        // $FlowFixMe Filtering away null/undefined isn't recognised.\n        managedTracks.filter(t => t.trackElementData && !t.isBlacklisted).map(t => t.trackElementData)\n      );\n\n      return Promise.all(freshManagedTracks.map(managedTrack => managedTrack.loadPromise)).then(() => {\n        videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n        videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n        notifyPropertyChanges();\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function updateFromVideoElement(textTracksList: TextTrackList) {\n    if (textTracksList.length === 0 && managedTracks.length === 0) {\n      return;\n    }\n\n    const videoElementTracks: Array<TextTrack> = [];\n    for (let i = 0; i < textTracksList.length; i++) {\n      // Awkward for-loop because Flow doesn't understand Array.from().\n      videoElementTracks.push(textTracksList[i]);\n    }\n\n    const cleanedUpManagedTracks = managedTracks.filter(managedTrack => {\n      return videoElementTracks.indexOf(managedTrack.videoElementTrack) >= 0;\n    });\n\n    //const isRemoving = cleanedUpManagedTracks.length < managedTracks.length;\n    //const isAdding = videoElementTracks.length > cleanedUpManagedTracks.length;\n\n    if (videoElementTracks.length > cleanedUpManagedTracks.length) {\n      const freshVideoElementTracks = videoElementTracks.filter(\n        videoElementTrack =>\n          isVideoElementTrackValid(videoElementTrack) &&\n          cleanedUpManagedTracks.filter(function(managedTrack) {\n            return videoElementTrack === managedTrack.videoElementTrack;\n          }).length === 0\n      );\n      const freshManagedTracks: Array<ManagedTextTrack> = freshVideoElementTracks.map(videoElementTrack => {\n        const id = ++unique;\n        return {\n          id,\n          sourceTrack: null,\n          videoElementTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(id, 'in-stream', videoElementTrack),\n          isLoaded: true\n        };\n      });\n      managedTracks = cleanedUpManagedTracks.concat(freshManagedTracks);\n    } else {\n      managedTracks = cleanedUpManagedTracks;\n    }\n  }\n\n  function cleanupTracks(isNewSession: boolean) {\n    updateFromVideoElement(videoElement.textTracks);\n    managedTracks.forEach(m => {\n      // Blacklisting and removing side-loaded tracks.\n      if (isNewSession || m.sourceTrack != null) {\n        m.isBlacklisted = true;\n      }\n      if (m.videoElementTrack != null && isNewSession) {\n        const vt = m.videoElementTrack;\n        if (vt.cues) {\n          while (vt.cues.length) {\n            vt.removeCue(vt.cues[0]);\n          }\n        }\n        setTrackMode(vt, 'disabled');\n      }\n      m.selectableTrack = null;\n    });\n    selectableTextTracks = emptyTracks;\n    updateTrackElementData([]);\n  }\n\n  function handleSourcePropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    updateFromVideoElement(videoElement.textTracks);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    const source = normalizeSource(newProps.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    cleanupTracks(false);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    cleanupTracks(true);\n  }\n\n  function handleSelectedTextTrackChange(selectedTextTrack: ?AvailableTrack) {\n    managedTracks\n      .filter(mt => mt.videoElementTrack && getTrackMode(mt.videoElementTrack) === 'showing')\n      .forEach(mt => mt.videoElementTrack && setTrackMode(mt.videoElementTrack, 'hidden'));\n    if (selectedTextTrack) {\n      if (instanceKeeper.hls) {\n        instanceKeeper.hls.subtitleDisplay = true;\n      }\n      const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedTextTrack)[0];\n      if (managedTrack && managedTrack.videoElementTrack) {\n        setTrackMode(managedTrack.videoElementTrack, 'showing');\n      }\n    } else if (instanceKeeper.hls) {\n      instanceKeeper.hls.subtitleDisplay = false;\n    }\n    notifyPropertyChanges();\n  }\n\n  function handleTrackAdd() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function handleTrackRemove() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function cleanup() {\n    videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n  }\n\n  function initialize() {\n    videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n  }\n\n  initialize();\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n};\n\nexport default getHlsjsTextTrackManager;\n","// @flow\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\nimport type { HlsjsQualityLevel } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsKbps(level: HlsjsQualityLevel) {\n  return (level && Math.ceil(level.bitrate / 1000)) || 0;\n}\n\nconst getHlsjsBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  instanceKeeper: HlsjsInstanceKeeper,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n  let hls;\n\n  function updateBitrateProps(hlsEvent, eventData) {\n    if (hls) {\n      let bitrates = Array.isArray(hls.levels) ? hls.levels.map(getBitrateAsKbps) : [];\n      if (isShallowEqual(previousBitrates, bitrates)) {\n        bitrates = previousBitrates;\n      }\n      const currentLevel =\n        hlsEvent === Hls.Events.LEVEL_SWITCHED\n          ? eventData.level\n          : hls.currentLevel === -1\n          ? hls.startLevel\n          : hls.currentLevel;\n      if (currentLevel === -1) {\n        log && log('No hls.js level reported currently or selected for start.');\n        updateStreamState({\n          bitrates\n        });\n      } else {\n        const currentBitrate = getBitrateAsKbps(hls.levels[currentLevel]);\n        updateStreamState({\n          currentBitrate,\n          bitrates\n        });\n      }\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (hls) {\n      if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n        log && log('Resetting restrictions for bitrate.');\n        hls.autoLevelCapping = -1;\n        updateStreamState({ bitrateCap: null });\n      } else {\n        if (Array.isArray(hls.levels)) {\n          let reached = false;\n          for (let i = 0; i < hls.levels.length; i++) {\n            const bitrate = getBitrateAsKbps(hls.levels[i]);\n            if (bitrate === cap) {\n              hls.autoLevelCapping = i;\n              updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i]) });\n              log && log('Desired bitrate cap ' + cap + ' is equal to level on index ' + i + ' in hls.js.', hls.levels);\n              reached = true;\n              break;\n            } else if (bitrate > cap) {\n              if (i > 0) {\n                hls.autoLevelCapping = i - 1;\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i - 1]) });\n                log &&\n                  log(\n                    'Desired bitrate cap ' + cap + ' is closest to level on index ' + (i - 1) + ' in hls.js.',\n                    hls.levels\n                  );\n              } else {\n                hls.autoLevelCapping = 0;\n                log &&\n                  log(\n                    'Desired bitrate cap ' +\n                      cap +\n                      ' appears to be lower than the lowest HLS level. Aligning to lowest level.',\n                    hls.levels\n                  );\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[0]) });\n              }\n              reached = true;\n              break;\n            }\n          }\n          if (!reached) {\n            log &&\n              log('Desired bitrate cap appears to be higher than the higher HLS level. Not applicable.', hls.levels);\n          }\n        } else {\n          log && log('Found no HLS levels from where bitrate capping can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (hls) {\n      if (bitrate === 'min') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = 0;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[0]) });\n          log && log('Fixing bitrate to lowest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate === 'max') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = hls.levels.length - 1;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[hls.levels.length - 1]) });\n          log && log('Fixing bitrate to highest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate == null || isNaN(bitrate) || bitrate < 0 || !bitrate) {\n        log && log('Resetting fixing of bitrate.');\n        hls.nextLevel = -1;\n        updateStreamState({ bitrateFix: null });\n      } else if (typeof bitrate === 'string') {\n        log &&\n          log(\n            'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n            bitrate\n          );\n      } else {\n        if (Array.isArray(hls.levels)) {\n          for (var i = 0; i < hls.levels.length; i++) {\n            if (getBitrateAsKbps(hls.levels[i]) === bitrate) {\n              hls.nextLevel = i;\n              log && log('Fixing bitrate to HLS level ' + i, hls.levels);\n              updateStreamState({ bitrateFix: bitrate });\n              return;\n            }\n          }\n          log &&\n            log(\n              \"Desired bitrate lock didn't match any bitrates specified in the hls.levels list. Not applied.\",\n              hls.levels\n            );\n        } else {\n          log && log('Found no HLS levels from where bitrate fixing can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      previousBitrates = [];\n    },\n    [Hls.Events.MANIFEST_PARSED]: updateBitrateProps,\n    [Hls.Events.LEVEL_SWITCHED]: updateBitrateProps,\n    [Hls.Events.LEVEL_UPDATED]: updateBitrateProps\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getHlsjsBitrateManager;\n","// @flow\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport { PlaybackError } from '../types';\n\nconst tech = 'hlsjs';\nconst ed = Hls.ErrorDetails;\n\nconst downloadErrors = [\n  ed.MANIFEST_LOAD_ERROR,\n  ed.MANIFEST_LOAD_TIMEOUT,\n  ed.LEVEL_LOAD_ERROR,\n  ed.LEVEL_LOAD_TIMEOUT,\n  ed.AUDIO_TRACK_LOAD_ERROR,\n  ed.AUDIO_TRACK_LOAD_TIMEOUT,\n  ed.FRAG_LOAD_ERROR,\n  ed.FRAG_LOOP_LOADING_ERROR,\n  ed.FRAG_LOAD_TIMEOUT,\n  ed.KEY_LOAD_ERROR,\n  ed.KEY_LOAD_TIMEOUT\n];\nconst decodeErrors = [\n  ed.MANIFEST_PARSING_ERROR,\n  ed.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n  ed.FRAG_DECRYPT_ERROR,\n  ed.BUFFER_ADD_CODEC_ERROR,\n  ed.FRAG_PARSING_ERROR\n];\n/*const generalErrors = [\n    t.BUFFER_APPEND_ERROR,\n    t.BUFFER_APPENDING_ERROR,\n    t.BUFFER_FULL_ERROR,\n    t.INTERNAL_EXCEPTION,\n    t.LEVEL_SWITCH_ERROR,\n    t.REMUX_ALLOC_ERROR\n];*/\n\nfunction buildMessage(data: HlsjsErrorData) {\n  const message = (data.type ? data.type + '/' : '') + (data.details || '');\n  if (typeof data.reason === 'string') {\n    return message + ': ' + data.reason;\n  } else {\n    return message;\n  }\n}\n\nexport function mapHlsjsError(isStarted: boolean, data: HlsjsErrorData) {\n  const severity = data.fatal ? 'FATAL' : 'WARNING';\n  const code =\n    (data && data.details && (downloadErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DOWNLOAD')) ||\n    (decodeErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DECODE') ||\n    'STREAM_ERROR';\n  return new PlaybackError(code, tech, buildMessage(data), severity, data);\n}\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport { mapHlsjsError } from './hlsjsErrorMapper';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getHlsjsEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  instanceKeeper,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  function handleActualError(detail) {\n    log && log('hlsjs.error');\n    const playbackError = mapHlsjsError(lifeCycleManager.getStage() === 'started', detail);\n    if (streamer.props.onPlaybackError) {\n      streamer.props.onPlaybackError(playbackError);\n    }\n    if (videoElement.error) {\n      updateStreamState({ error: videoElement.error });\n    }\n    if (playbackError.severity === 'FATAL') {\n      lifeCycleManager.setStage('dead');\n      updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.ERROR]: (evt: any, data: HlsjsErrorData) => {\n      switch (data.details) {\n        case Hls.ErrorDetails.BUFFER_STALLED_ERROR:\n          updateStreamState({ isBuffering: true });\n          if (lifeCycleManager.getStage() === 'started') {\n            updateStreamState({ playState: 'buffering' });\n          }\n          break;\n        case Hls.ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n        case Hls.ErrorDetails.BUFFER_NUDGE_ON_STALL:\n          break;\n        case Hls.ErrorDetails.MANIFEST_PARSING_ERROR:\n          if (data.url && !data.url.endsWith('undefined')) {\n            handleActualError(data);\n          }\n          break;\n        default:\n          handleActualError(data);\n      }\n    },\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      log && log('hlsjs.loading');\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    [Hls.Events.FRAG_BUFFERED]: () => {\n      updateStreamState({ isBuffering: false });\n    },\n    [Hls.Events.MANIFEST_PARSED]: () => {\n      log && log('hlsjs.parsed');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        if (isPaused) {\n          videoElement.pause();\n        }\n        applyProperties({ bitrateFix, bitrateCap });\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n      updateStreamState(streamRangeHelper.calculateNewState());\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded,\n    onError // We still want HTML video element error mapping.\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded,\n      onError\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager\n  };\n};\n\nexport default getHlsjsEventHandlers;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport { hlsjsCleanup } from './hlsjsSetup';\nimport getStreamRangeHelper from './hlsjsStreamRangeHelper';\nimport getSourceChangeHandler from './hlsjsSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts, TrackElementData } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getHlsjsAudioTrackManager from './hlsjsAudioTrackManager';\nimport Hls from 'hls.js';\nimport getHlsjsTextTrackManager from './hlsjsTextTrackManager';\nimport getHlsjsBitrateManager from './hlsjsBitrateManager';\nimport getHlsjsEventHandlers from './hlsjsEventHandlers';\n\nexport type HlsjsInstanceKeeper = {\n  hls?: Hls,\n  videoElement: HTMLVideoElement,\n  subscribers: Array<(Hls, 'on' | 'off') => void>\n};\n\nexport type HlsjsVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  hlsjs: {\n    customConfiguration?: any\n  }\n};\nexport type HlsjsVideoStreamerProps = VideoStreamerImplProps<HlsjsVideoStreamerConfiguration>;\n\nfunction resolveImplementation(\n  streamer: SimplifiedVideoStreamer<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps>,\n  configuration: ?HlsjsVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement,\n  onTrackElementDataChange: (Array<TrackElementData>) => void\n): Promise<StreamerImplementationParts<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps, HlsjsInstanceKeeper>> {\n  const instanceKeeper = {\n    videoElement,\n    subscribers: []\n  };\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, instanceKeeper, configuration);\n  const handleSourceChange = getSourceChangeHandler(instanceKeeper);\n  const updateStreamState = getFilteredStreamStateUpdater(streamer);\n\n  const textTrackManager = getHlsjsTextTrackManager(\n    videoElement,\n    instanceKeeper,\n    updateStreamState,\n    onTrackElementDataChange\n  );\n  const audioTrackManager = getHlsjsAudioTrackManager(instanceKeeper, updateStreamState);\n  const bitrateManager = getHlsjsBitrateManager(\n    streamer,\n    instanceKeeper,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const hlsjsEventHandlers = getHlsjsEventHandlers({\n    streamer,\n    videoElement,\n    instanceKeeper,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = hlsjsEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    hlsjsEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    return hlsjsCleanup(instanceKeeper);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = instanceKeeper;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n}\n\nconst HlsjsVideoStreamer = createVideoStreamerComponent('HlsjsVideoStreamer', resolveImplementation);\n\nexport default HlsjsVideoStreamer;\n"],"sourceRoot":""}