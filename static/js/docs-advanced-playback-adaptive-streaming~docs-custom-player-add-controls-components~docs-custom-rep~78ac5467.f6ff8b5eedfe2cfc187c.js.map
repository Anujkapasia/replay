{"version":3,"sources":["webpack:///./src/replay/components/controls/AirPlayButton/AirPlayButton.js","webpack:///./src/replay/components/controls/AudioSelector/AudioSelector.js","webpack:///./src/replay/components/controls/BufferingIndicator/BufferingIndicator.js","webpack:///./src/replay/components/generic/Container/Container.js","webpack:///./src/replay/components/controls/ControlsBar/ControlsBar.js","webpack:///./src/replay/components/controls/ExitButton/ExitButton.js","webpack:///./src/replay/components/controls/FullscreenButton/FullscreenButton.js","webpack:///./src/replay/components/controls/GotoLiveButton/GotoLiveButton.js","webpack:///./src/replay/components/controls/PipButton/PipButton.js","webpack:///./src/replay/components/controls/PlayPauseButton/PlayPauseButton.js","webpack:///./src/replay/components/controls/PlaybackMonitor/PlaybackMonitor.js","webpack:///./src/replay/components/controls/SkipButton/SkipButton.js","webpack:///./src/replay/components/controls/SubtitlesSelector/SubtitlesSelector.js","webpack:///./src/replay/components/controls/TimeDisplay/TimeDisplay.js","webpack:///./src/replay/components/controls/Timeline/Timeline.js","webpack:///./src/replay/components/controls/TimelineInformation/TimelineInformation.js","webpack:///./src/replay/components/controls/Volume/Volume.js","webpack:///./src/replay/components/generic/Button/Button.js","webpack:///./src/replay/components/player/PlayerController/ControllerContext.js","webpack:///./src/replay/components/player/PlayerController/connectControl.js","webpack:///./src/replay/components/player/containment-helpers/AspectRatio.js","webpack:///./src/replay/components/player/containment-helpers/InteractionDetector.js","webpack:///./src/replay/components/player/containment-helpers/KeyboardShortcuts.js","webpack:///./src/replay/components/player/containment-helpers/playerStateClassNameBuilder.js","webpack:///./src/replay/components/player/containment-helpers/PlayerStateClassNames.js","webpack:///./src/replay/components/player/containment-helpers/ResponsiveClassNames.js","webpack:///./src/replay/components/player/PlayerUIContainer/PlayerUIContainer.js","webpack:///./src/replay/components/player/settings-helpers/settingsStorage.js","webpack:///./src/replay/components/player/PlayerController/connectedControls.js","webpack:///./src/replay/components/player/VideoStreamer/BasicVideoStreamer/streamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/BasicVideoStreamer/textTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/BasicVideoStreamer/audioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/BasicVideoStreamer/BasicVideoStreamer.js","webpack:///./src/replay/components/player/VideoStreamer/BasicVideoStreamer/errorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/BasicVideoStreamer/basicVideoEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/BasicVideoStreamer/sourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/common/createVideoStreamerComponent.js","webpack:///./src/replay/components/player/VideoStreamer/common/filteredStreamStateUpdater.js","webpack:///./src/replay/components/player/VideoStreamer/common/logger.js","webpack:///./src/replay/components/player/VideoStreamer/common/playbackLifeCycleManager.js","webpack:///./src/replay/components/player/VideoStreamer/common/propertyApplier.js","webpack:///./src/replay/components/player/VideoStreamer/common/renderers.js","webpack:///./src/replay/components/player/VideoStreamer/common/sourceNormalizer.js","webpack:///./src/replay/components/player/VideoStreamer/types.js","webpack:///./src/replay/components/player/containment-helpers/ponyfills/crossBrowserFullscreen.js","webpack:///./src/replay/components/player/containment-helpers/Fullscreen.js","webpack:///./src/replay/components/player/settings-helpers/PreferredSettingsApplicator.js","webpack:///./src/replay/default-player/baseConfiguration.js","webpack:///./src/replay/default-player/default-skin/LoadingAnimation.js","webpack:///./src/replay/default-player/default-skin/graphics.js","webpack:///./src/replay/default-player/strings.js","webpack:///./src/replay/components/player/PlayerController/PlayerController.js","webpack:///./src/replay/components/player/RenderIfEnabled.js","webpack:///./src/replay/default-player/playerUI.js","webpack:///./src/replay/playerComposer.js","webpack:///./src/replay/version.js"],"names":["AirPlayButton","_this","props","setProperties","isAirPlayTargetPickerVisible","React","this","isAirPlayAvailable","_this$props","isAirPlayActive","airPlayActiveContent","airPlayInactiveContent","label","classNamePrefix","react__WEBPACK_IMPORTED_MODULE_0__","_generic_ToggleButton_ToggleButton__WEBPACK_IMPORTED_MODULE_1__","isOn","className","onToggle","handleToggle","toggledOnContent","toggledOffContent","defaultClassNamePrefix","displayName","buildId","_len","arguments","length","str","Array","_key","filter","s","join","audioTrackToItem","track","id","language","_ref","_ref$kind","kind","_ref$language","concat","data","AudioSelector","item","selectedAudioTrack","audioTracks","currentAudioTrack","toggleContent","isArray","selectedItem","selectedIndex","indexOf","_generic_Selector_Selector__WEBPACK_IMPORTED_MODULE_1__","items","itemMapper","onSelect","handleSelect","reverseOrder","expandedToggleContent","collapsedToggleContent","__webpack_require__","_common__WEBPACK_IMPORTED_MODULE_1__","BufferingIndicator","children","content","isBuffering","isSeeking","playState","_ref$renderStrategy","renderStrategy","_ref$classNamePrefix","isActive","title","prefixClassNames","streamStateKeysForObservation","Container","classes","container","selectClasses","classNames","hydrateClassNames","baseClassName","react","useDefaultClassNaming","ControlsBar","ExitButton","onClick","_generic_Button_Button__WEBPACK_IMPORTED_MODULE_1__","FullscreenButton","value","isFullscreen","fullscreenContent","normalContent","GotoLiveButton","isAtLiveEdge","playMode","isAtLiveEdgeContent","isNotAtLiveEdgeContent","PipButton","isPipActive","isPipAvailable","pipActiveContent","pipInactiveContent","PlayPauseButton","isPaused","pausedContent","playingContent","orderedPropertyNames","formatValue","val","Date","isNaN","getTime","toString","toISOString","toFixed","Error","parts","message","push","code","severity","map","JSON","stringify","replace","PropTableRow","_React$Component","_classCallCheck","_possibleConstructorReturn","_getPrototypeOf","call","state","currentValue","inspect","propertyName","_inherits","_createClass","key","prefixedClassNames","_this$state","previousValue","formattedCurrentValue","formattedPreviousValue","propName","nextProps","prevState","isDifferent","connectedComponents","forEach","connectControl","TableHeaderRow","headerRow","PlaybackMonitor","_this2","_defineProperty","_assertThisInitialized","setState","isMonitorVisible","keyboardEvent","ctrlKey","altKey","configuration","playbackMonitor","visibleAtStart","document","addEventListener","handleKeyDown","removeEventListener","_this$props2","closeButtonContent","_generic_Button_Button__WEBPACK_IMPORTED_MODULE_2__","handleCloseClick","replayVersion","ConnectedPropRow","renderTableRows","SkipButton","position","offset","handleClick","buildLabel","textTrackToItem","noTrack","origin","SubtitlesSelector","selectedTextTrack","noSubtitlesItem","noSubtitlesLabel","textTracks","currentTextTrack","formatAndLimitTime","time","negativeMark","zeroAndBelow","undefined","formatTime","Math","TimeDisplay","date","duration","absolutePosition","_ref$liveDisplayMode","liveDisplayMode","positionLabel","durationLabel","clockTimeLabel","formatClockTime","Timeline","isDragging","timeoutId","clearTimeout","setTimeout","handleContent","trackContent","reduceDragGlitch","_generic_Slider_Slider__WEBPACK_IMPORTED_MODULE_2__","maxValue","isUpdateBlocked","onValueChange","handleSliderChange","onDrag","handleDrag","trackClassName","handleClassName","TimelineInformation","absoluteStartPosition","previewValue","isPointerInside","timeDisplay","getTimeDisplay","left","prefixedClassName","prefixedTooltipClassNames","style","Volume","isMuted","volume","isIos","navigator","userAgent","match","volumeSliderLabel","muteToggleLabel","mutedContent","unmutedContent","volumeSliderHandleContent","volumeSliderTrackContent","_generic_ToggleButton_ToggleButton__WEBPACK_IMPORTED_MODULE_2__","handleMuteToggleClick","_generic_Slider_Slider__WEBPACK_IMPORTED_MODULE_3__","handleVolumeSliderChange","button","Button","getKeyboardShortcutBlocker","preventDefault","onKeyDown","onKeyUp","handleKeyUp","role","tabIndex","ControllerContext","videoStreamer","observe","unobserve","registerObservers","keys","onChange","p","ControlledVideoStreamer","_ControllerContext__WEBPACK_IMPORTED_MODULE_1__","Consumer","_ref2","Control","stateKeys","resolvedStateKeys","name","Observer","prop","currentState","initialState","update","_objectSpread","passdownProps","ConnectedControl","outerStyle","maxHeight","helperStyle","display","width","paddingTop","pointerEvents","getHelperStyle","memoize","aspectRatio","vertical","horizontal","AspectRatio","render","_ref$rootClassName","rootClassName","aspectFixClassName","beforeStyle","getDelaySeconds","interactionDetector","inactivityDelay","InteractionDetector","InteractionDetector_defineProperty","isMouseMoved","isTouched","isTouching","isEntered","clientX","clientY","evt","flags","isFixed","isUserActive","focusEvent","target","currentTarget","nudge","inactivityTimeoutId","setInactive","intervalId","setInterval","updateActivity","prevProps","delaySeconds","clearInterval","handleMouseMove","handleTouchStart","handleTouchEnd","handleFocus","toggleFixedUserActive","matchKeyCaseSafely","eventKey","toLowerCase","getMatchingOperationFromKeyMap","config","keyMap","Object","entries","_slicedToArray","mappedKeys","entry","KeyboardShortcuts","fullscreenState","inspectedState","keyboardShortcuts","skipOffset","volumeStep","operation","max","targetPosition","min","volumeMappings","playerStateClassNameBuilder","classNameDefinitions","error","extraClassNames","cd","resultingClassNames","isStreamOpen","isPlaying","isStarting","isOnDemand","isLive","isDvrEnabled","volumePrefix","i","floor","isUserInactive","isFailed","apply","_toConsumableArray","PlayerStateClassNames","playerStateProps","_objectWithoutProperties","PlayerStateClassNames_toConsumableArray","ResponsiveClassNames","ResponsiveClassNames_classCallCheck","ResponsiveClassNames_getPrototypeOf","ResponsiveClassNames_defineProperty","ResponsiveClassNames_assertThisInitialized","element","resizeObserver","disconnect","responsivenessRules","ResizeObserver","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","onSizeChange","contentRect","err","return","onRef","elementWidth","elementHeight","height","responsiveClassNames","range","responsivenessPrefix","noConnect","Component","getConnectedPlayerUIContainer","_class","_temp","connector","ConnectedPlayerStateClassNames","ConnectedKeyboardShortcuts","PlayerUIContainer","PlayerUIContainer_classCallCheck","PlayerUIContainer_possibleConstructorReturn","PlayerUIContainer_getPrototypeOf","PlayerUIContainer_inherits","playerClassName","substr","containment_helpers_AspectRatio","Fullscreen","PlayerUIContainer_objectWithoutProperties","containment_helpers_InteractionDetector","interactionState","_ref3","containment_helpers_ResponsiveClassNames","_ref4","assign","ref","onMouseMove","onTouchStart","onTouchEnd","onFocus","getStoredSettings","storage","storedStr","getItem","parse","e","withStorage","storagePolicy","sessionSettings","localSettings","callback","withSettingsStorage","localStorage","window","sessionStorage","SettingsStorage","_getPrototypeOf2","settingsStorage_classCallCheck","args","settingsStorage_getPrototypeOf","settingsStorage_defineProperty","settingsStorage_assertThisInitialized","userSetProps","userSettingsConfig","userSettings","storageKey","settingsStoragePolicy","settings","textTrackLanguage","textTrackKind","audioTrackLanguage","audioTrackKind","setItem","settingsStorage_inherits","remainder","settingsStorage_objectWithoutProperties","isEnabled","d","__webpack_exports__","connectedControls_PlayerUIContainer","connectedControls_PlayPauseButton","connectedControls_SkipButton","connectedControls_Timeline","connectedControls_TimeDisplay","connectedControls_TimelineInformation","connectedControls_GotoLiveButton","connectedControls_PipButton","connectedControls_AirPlayButton","connectedControls_QualitySelector","connectedControls_BufferingIndicator","connectedControls_SettingsStorage","UnconnectedPlayPauseButton","UnconnectedSkipButton","UnconnectedTimeline","UnconnectedTimeDisplay","UnconnectedTimelineInformation","UnconnectedGotoLiveButton","UnconnectedPipButton","UnconnectedAirPlayButton","QualitySelector","UnconnectedVolume","UnconnectedAudioSelector","UnconnectedSubtitlesSelector","UnconnectedQualitySelector","UnconnectedBufferingIndicator","dawnOfTime","minimumDvrLength","dvrStartCorrection","getStartOffset","videoElement","seekable","start","getStreamRangeHelper","liveMargin","liveEdgeMargin","adjustForDvrStartOffset","paused","Infinity","seekableStart","currentTime","calculateNewState","seekableRange","end","getSeekableNetRange","getPosition","getDuration","resolvePlayMode","_getAbsolutePositions","startDate","getStartDate","getAbsolutePositions","setPosition","newPosition","gotoLive","trackModeMappings","getTrackMode","textTrack","mode","setTrackMode","newMode","isEqual","a","b","Number","createSelectableTrack","videoElementTrack","getTextTrackManager","updateTrackElementData","managedTracks","selectableTextTracks","emptyTracks","unique","Cue","VTTCue","TextTrackCue","notifyPropertyChanges","m","selectableTrack","isShallowEqual","addTracks","sourceTracks","handleTrackAdd","handleTrackRemove","freshManagedTracks","sourceTrack","managedTrackMatches","managedTrack","cues","ac","bc","cue","index","src","isSourceTracksEqual","isBlacklisted","alreadyAddedTrack","isLoaded","addTextTrack","addCue","loadPromise","Promise","resolve","trackElementData","srclang","trackElement","t","handleLoad","handleError","then","all","updateFromVideoElement","textTracksList","videoElementTracks","cleanedUpManagedTracks","cleanupTracks","isNewSession","vt","removeCue","handleSelectedTextTrackChange","mt","handleTextTracksPropChange","newProps","source","handleSourcePropChange","newTracks","normalizeSource","clear","cleanup","createManagedTrack","getAudioTrackManager","updateStreamStateProps","selectedTrack","enabled","handleTrackAddOrRemove","from","handleTrackChange","handleSourceChange","handleSelectedAudioTrackChange","getImplementationResolver","sourceChangeHandlerFactory","streamer","onTrackElementDataChange","streamRangeHelper","updateStreamState","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","applyProperties","getPropertyApplier","log","getArrayLogger","basicHandlers","getBasicVideoEventHandlers","videoElementEventHandlers","setLifeCycleManager","playbackLifeCycleManager","getPlaybackLifeCycleManager","pauseStreamRangeUpdater","startPlaybackSession","endPlaybackSession","renderWithoutSource","BasicVideoStreamer","createVideoStreamerComponent","getSourceChangeHandler","videoErrorCodes","mapError","isDesktopSafari","errorCode","sourceError","sourceErrorCode","PlaybackError","calculateBufferedAhead","buffered","ahead","isSafariOrEdge","lifeCycleManager","setStage","_","getStage","pictureInPictureEnabled","disablePictureInPicture","webkitSupportsPresentationMode","webkitSetPresentationMode","handleEnterPictureInPicture","handleLeavePictureInPicture","handlePlaybackTargetAvailabilityChanged","availability","handleCurrentPlaybackTargetIsWirelessChanged","webkitCurrentPlaybackTargetIsWireless","handlePresentationModeChanged","webkitPresentationMode","getIntervalRunner","pauseUpdateInterval","onLoadStart","initialPlaybackProps","_streamer$props$initi","bitrateFix","bitrateCap","muted","onLoadedMetadata","pause","normalizedSource","startPosition","seekToInitialPosition","onCanPlay","stage","bufferedAhead","onWaiting","onStalled","onPlaying","stop","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onError","playbackError","onPlaybackError","onEnded","manager","streamUrl","removeAttribute","load","resolveImplementation","VideoStreamer","playbackProps","implementation","catch","videoRef","current","handleTrackElementDataChange","thirdPartyPlayer","onReady","pictureInPictureElement","exitPictureInPicture","previousVideoElement","pipElement","presentationMode","wasPipActive","snapshot","_this3","playsInline","saneNumberFilter","defaultFilters","filters","currentValues","property","onStreamStateChange","saneValue","obj","location","search","emptyBitrates","lifeCycleStage","newValue","bitrates","notifyInitialState","endStage","notifyTerminalState","bitrateManager","play","fixBitrate","capBitrate","requestPictureInPicture","webkitShowPlaybackTargetPicker","createTrackElement","srcLang","autoPlay","controls","_Error","technology","_wrapNativeSuper","getFullscreenElement","fullScreenElement","fullscreenElement","webkitFullscreenElement","webkitFullScreenElement","mozFullScreenElement","msFullscreenElement","handler","fullscreenEventNames","fullscreenTarget","requestFullscreen","mozRequestFullScreen","msRequestFullscreen","webkitRequestFullscreen","Element","ALLOW_KEYBOARD_INPUT","webkitRequestFullScreen","getElementsByTagName","webkitEnterFullscreen","exitFullscreen","mozCancelFullScreen","webkitExitFullscreen","webkitExitFullScreen","msExitFullscreen","enterFullscreen","unsubscribe","onFullscreenChange","eventName","noop","getTrackToSelect","preferredLanguage","preferredKind","prevTracks","nextTracks","ignorableTrackListLength","tracks","ignorableLength","getTrackFromLanguageAndKind","onPropsChanged","programmaticSettings","mergedSettings","hasPrecedence","mergePreferredSettings","propsToBeUpdated","prevPlayState","nextPlayState","prevAudioTracks","prevTextTracks","nextAudioTracks","nextTextTracks","preferredSettings","updates","audioTrackToSelect","textTrackToSelect","getPropsToBeUpdated","PreferredSettingsApplicator","getPreferredSettingsApplicator","baseConfiguration","logLevel","togglePause","toggleFullscreen","decreaseVolume","increaseVolume","skipBack","skipForward","toggleUserActive","toggleMute","skipButtonOffset","qualitySelectionStrategy","LoadingAnimation","viewBox","stroke","fill","fillRule","transform","strokeWidth","strokeOpacity","cx","cy","r","react_feather__WEBPACK_IMPORTED_MODULE_1__","_LoadingAnimation__WEBPACK_IMPORTED_MODULE_2__","_strings__WEBPACK_IMPORTED_MODULE_3__","graphics","playPauseButton","skipButton","strings","seconds","timeline","gotoLiveButton","audioSelector","subtitlesSelector","qualitySelector","pipButton","airPlayButton","fullscreenButton","bufferingIndicator","exitButton","autoLabel","formatBitrateLabel","bitrate","getObserveManager","observers","splice","unobserveAll","handlers","pop","PlayerController","inspectableStreamState","override","observeManager","videoStreamerProps","onVideoStreamerReady","onStreamerError","onPlaybackActionsReady","setVolume","setIsMuted","mute","unmute","showAirPlayTargetPicker","setSelectedAudioTrack","setSelectedTextTrack","externalProps","options","mergedConfiguration","mergeConfiguration","controllerApi","child","Provider","RenderIfEnabled","childName","type","startIndex","charAt","extractChildName","getLiveDisplayMode","conf","getQSStrategy","getPlayerUIRenderer","u","merged","playerUI_slicedToArray","control","playerUI_objectSpread","merge","_ref5","prefix","includedControlsList","includeControls","connectedControls","_ref6","player_RenderIfEnabled","onExit","selectionStrategy","defaultVideoStreamerResolver","composePlayer","videoStreamerComponent","uiRenderMethod","_ref$resolveVideoStre","resolveVideoStreamerMethod","_ref$configuration","_ref$version","version","renderUI","ComposedPlayer","player_PlayerController_PlayerController","playerComposer_objectSpread"],"mappings":"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","file":"static/js/docs-advanced-playback-adaptive-streaming~docs-custom-player-add-controls-components~docs-custom-rep~78ac5467.7545fff6.js","sourcesContent":["// @flow\nimport * as React from 'react';\nimport ToggleButton from '../../generic/ToggleButton/ToggleButton';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** If true, this button will be rendered. */\n  isAirPlayAvailable?: boolean,\n  /** The current AirPlay state, as reported from a video streamer. */\n  isAirPlayActive?: boolean,\n  /** Intended for the setProperties method passed from the player controller through connectControl(). When the button is clicked, this callback is invoked with an object having an isAirPlayTargetPickerVisible property equal to true. */\n  setProperties?: ({ isAirPlayTargetPickerVisible: true }) => void,\n  /** The button content to be displayed while isAirPlayActive is true. */\n  airPlayActiveContent: React.Node,\n  /** The button content to be displayed while isAirPlayActive is false. */\n  airPlayInactiveContent: React.Node\n};\n\nconst className = 'airplay-button';\n\nclass AirPlayButton extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['isAirPlayAvailable', 'isAirPlayActive'];\n\n  handleToggle = () => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ isAirPlayTargetPickerVisible: true });\n    }\n  };\n\n  render() {\n    if (this.props.isAirPlayAvailable) {\n      const { isAirPlayActive, airPlayActiveContent, airPlayInactiveContent, label, classNamePrefix } = this.props;\n      return (\n        <ToggleButton\n          classNamePrefix={classNamePrefix}\n          isOn={isAirPlayActive}\n          className={className}\n          label={label}\n          onToggle={this.handleToggle}\n          toggledOnContent={airPlayActiveContent}\n          toggledOffContent={airPlayInactiveContent}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nAirPlayButton.displayName = 'AirPlayButton';\nexport default AirPlayButton;\n","// @flow\nimport * as React from 'react';\nimport Selector from '../../generic/Selector/Selector';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { AvailableTrack } from '../../player/VideoStreamer/types';\nimport type { CommonProps } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The list of audio tracks available for selection. */\n  audioTracks?: Array<AvailableTrack>,\n  /** ⇘ The currently playing audio track (if known). Must be strict equal one of the items in the audio track list, or null. */\n  currentAudioTrack?: AvailableTrack,\n  /** ⇗ When one item is clicked, this callback is invoked with an object having an selectedAudioTrack property with the audioTrack object corresponding to the selection. */\n  setProperties?: ({ selectedAudioTrack: AvailableTrack }) => void,\n  /** Element displayed in the control bar for expanding/collapsing the selector items. */\n  toggleContent: React.Node\n};\n\nconst className = 'audio-selector';\n\nconst buildId = (...str: Array<?string>) => str.filter(s => s).join('.');\nconst buildLabel = ({ label, kind = '', language = 'unknown' }: AvailableTrack) =>\n  label || (kind ? `[${language}] ${kind}` : `[${language}]`);\n\nconst audioTrackToItem = (track: AvailableTrack) => {\n  return { id: track.id || buildId(track.language, track.label) || track.label, label: buildLabel(track), data: track };\n};\n\nclass AudioSelector extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['audioTracks', 'currentAudioTrack'];\n\n  handleSelect = (item: any) => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ selectedAudioTrack: item });\n    }\n  };\n\n  render() {\n    const { audioTracks, currentAudioTrack, label, toggleContent, classNamePrefix } = this.props;\n    if (Array.isArray(audioTracks) && audioTracks.length > 1) {\n      // TODO: Consider optimization, memoizing the array and all props involved in rendering.\n      let selectedItem = audioTracks[0];\n      if (currentAudioTrack) {\n        const selectedIndex = audioTracks.indexOf(currentAudioTrack);\n        if (selectedIndex >= 0) {\n          selectedItem = audioTracks[selectedIndex]; // Ugly construct, but leaving it for now.\n        }\n      }\n      return (\n        <Selector\n          items={audioTracks}\n          itemMapper={audioTrackToItem}\n          classNamePrefix={classNamePrefix}\n          className={className}\n          selectedItem={selectedItem}\n          label={label}\n          onSelect={this.handleSelect}\n          reverseOrder={true}\n          expandedToggleContent={toggleContent}\n          collapsedToggleContent={toggleContent}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nAudioSelector.displayName = 'AudioSelector';\nexport default AudioSelector;\n","// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix, prefixClassNames } from '../../common';\nimport type { PlayState } from '../../player/VideoStreamer/types';\nimport type { CommonProps } from '../../common';\nimport type { ObservingControlStaticProps } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** ⇘︎ If true, the buffering indicator is shown or the root element has a class name indicating buffering. */\n  isBuffering?: boolean,\n  /** ⇘︎ If true, the buffering indicator is shown or the root element has a class name indicating buffering. */\n  isSeeking?: boolean,\n  /** ⇘︎ If set to 'starting', 'buffering', or 'seeking', the buffering indicator is shown or the root element has a class name indicating buffering. */\n  playState?: PlayState,\n  /** The content to show if buffering, or always if renderingStrategy is 'always'. */\n  children?: React.Node,\n  /** Alternative to specifying children. Other Replay controls use content as the convention. */\n  content?: React.Node,\n  /** When set to 'always', the content is always rendered, but buffering is indicated through a class name on the component's root element. This option is used when controlling display through CSS. */\n  renderStrategy?: 'when-buffering' | 'always'\n};\n\nconst className = 'buffering-indicator';\nconst isActiveClassName = 'buffering';\n\ntype BufferingIndicatorType = React.StatelessFunctionalComponent<Props> & ObservingControlStaticProps;\n\nconst BufferingIndicator: BufferingIndicatorType = ({\n  children,\n  content,\n  isBuffering,\n  isSeeking,\n  playState,\n  renderStrategy = 'when-buffering',\n  label,\n  classNamePrefix = defaultClassNamePrefix\n}: Props) => {\n  const isActive =\n    isBuffering || isSeeking || playState === 'starting' || playState === 'buffering' || playState === 'seeking';\n  if (renderStrategy === 'always') {\n    if (isActive) {\n      return (\n        <div title={label} className={prefixClassNames(classNamePrefix, className, isActiveClassName)}>\n          {children || content}\n        </div>\n      );\n    } else {\n      return <div className={prefixClassNames(classNamePrefix, className)}>{children || content}</div>;\n    }\n  } else {\n    if (isActive) {\n      return (\n        <div title={label} className={prefixClassNames(classNamePrefix, className, isActiveClassName)}>\n          {children || content}\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n};\n\nBufferingIndicator.streamStateKeysForObservation = ['isBuffering', 'isSeeking', 'playState'];\nBufferingIndicator.displayName = 'BufferingIndicator';\n\nexport default BufferingIndicator;\n","// @flow\nimport * as React from 'react';\nimport { hydrateClassNames, type CommonGenericProps, defaultClassNamePrefix } from '../../common';\n\ntype Props = CommonGenericProps & {\n  /** The controls to be included in the container. */\n  children: React.Node\n};\n\nclass Container extends React.Component<Props> {\n  baseClassName = 'container';\n  selectClasses: ({ [string]: ?string }) => ?string | ?Array<?string> = classes => classes.container;\n\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix,\n    useDefaultClassNaming: true\n  };\n\n  render() {\n    const { className, classNamePrefix, classes, children }: Props = this.props;\n    const { selectClasses } = this;\n    const classNames = hydrateClassNames({\n      classes,\n      selectClasses,\n      classNamePrefix,\n      classNames: [className, this.baseClassName]\n    });\n    return <div className={classNames}>{children}</div>;\n  }\n}\n\nexport default Container;\n","// @flow\n//import * as React from 'react';\nimport Container from '../../generic/Container/Container';\n\nclass ControlsBar extends Container {\n  baseClassName = 'controls-bar';\n}\n\nControlsBar.displayName = 'ControlsBar';\nexport default ControlsBar;\n","// @flow\nimport * as React from 'react';\nimport Button from '../../generic/Button/Button';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\n\ntype Props = CommonProps & {\n  /** The graphics or similar for the button. */\n  content: React.Node,\n  /** Callback invoked when the button is clicked. */\n  onClick: () => void\n};\n\nconst className = 'exit-button';\n\nclass ExitButton extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  render() {\n    const { content, label, classNamePrefix, onClick } = this.props;\n    if (onClick) {\n      return (\n        <Button\n          classNamePrefix={classNamePrefix}\n          className={className}\n          label={label}\n          onClick={onClick}\n          content={content}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nExitButton.displayName = 'ExitButton';\nexport default ExitButton;\n","// @flow\nimport * as React from 'react';\nimport ToggleButton from '../../generic/ToggleButton/ToggleButton';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\n\ntype Props = CommonProps & {\n  /** The current fullscreen state, as reported in the render method of the Fullscreen helper component. */\n  isFullscreen?: boolean,\n  /** Intended for the setProperties method passed in the render method of the Fullscreen helper component. When the button is clicked, this callback is invoked with an object having an isFullscreen property with the opposite boolean value as the isFullscreen prop. */\n  setProperties?: ({ isFullscreen: boolean }) => void,\n  /** The button content to be displayed while isFullscreen is true. */\n  fullscreenContent: React.Node,\n  /** The button content to be displayed while isFullscreen is false. */\n  normalContent: React.Node\n};\n\nconst className = 'fullscreen-button';\n\nclass FullscreenButton extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  handleToggle = (value: boolean) => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ isFullscreen: value });\n    }\n  };\n\n  render() {\n    const { isFullscreen, fullscreenContent, normalContent, label, classNamePrefix } = this.props;\n    return (\n      <ToggleButton\n        classNamePrefix={classNamePrefix}\n        isOn={isFullscreen}\n        className={className}\n        label={label}\n        onToggle={this.handleToggle}\n        toggledOnContent={fullscreenContent}\n        toggledOffContent={normalContent}\n      />\n    );\n  }\n}\n\nFullscreenButton.displayName = 'FullscreenButton';\nexport default FullscreenButton;\n","// @flow\nimport * as React from 'react';\nimport ToggleButton from '../../generic/ToggleButton/ToggleButton';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { PlayMode } from '../../player/VideoStreamer/types';\nimport type { CommonProps } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The current timeshift state of the playback. False means timeshifting. */\n  isAtLiveEdge?: boolean,\n  /** ⇘︎ The stream mode. Must be 'livedvr' in order for this control to render. */\n  playMode?: PlayMode,\n  /** ⇗ When the button is clicked, and the isAtLiveEdge prop is false, this callback is invoked with an object containing an isAtLiveEdge property with the value true. */\n  setProperties?: ({ isAtLiveEdge: true }) => void,\n  /** The button content to be displayed while isAtLiveEdge is true. */\n  isAtLiveEdgeContent: React.Node,\n  /** The button content to be displayed while isAtLiveEdge is false, i.e. when timeshifting. */\n  isNotAtLiveEdgeContent: React.Node\n};\n\nconst className = 'goto-live-button';\n\nclass GotoLiveButton extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['isAtLiveEdge', 'playMode'];\n\n  handleToggle = (value: boolean) => {\n    if (value && this.props.setProperties) {\n      this.props.setProperties({ isAtLiveEdge: true });\n    }\n  };\n\n  render() {\n    const { playMode, isAtLiveEdge, isAtLiveEdgeContent, isNotAtLiveEdgeContent, label, classNamePrefix } = this.props;\n    return playMode === 'livedvr' ? (\n      <ToggleButton\n        classNamePrefix={classNamePrefix}\n        isOn={isAtLiveEdge}\n        className={className}\n        label={label}\n        onToggle={this.handleToggle}\n        toggledOnContent={isAtLiveEdgeContent}\n        toggledOffContent={isNotAtLiveEdgeContent}\n      />\n    ) : null;\n  }\n}\n\nGotoLiveButton.displayName = 'GotoLiveButton';\nexport default GotoLiveButton;\n","// @flow\nimport * as React from 'react';\nimport ToggleButton from '../../generic/ToggleButton/ToggleButton';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** If true, this button will be rendered. */\n  isPipAvailable?: boolean,\n  /** The current picture-in-picture state, as reported from a video streamer. */\n  isPipActive?: boolean,\n  /** Intended for the setProperties method passed from the player controller through connectControl(). When the button is clicked, this callback is invoked with an object having an isPipActive property with the opposite boolean value as the isPipActive prop. */\n  setProperties?: ({ isPipActive: boolean }) => void,\n  /** The button content to be displayed while isPipActive is true. */\n  pipActiveContent: React.Node,\n  /** The button content to be displayed while isPipActive is false. */\n  pipInactiveContent: React.Node\n};\n\nconst className = 'pip-button';\n\nclass PipButton extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['isPipAvailable', 'isPipActive'];\n\n  handleToggle = (value: boolean) => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ isPipActive: value });\n    }\n  };\n\n  render() {\n    if (this.props.isPipAvailable) {\n      const { isPipActive, pipActiveContent, pipInactiveContent, label, classNamePrefix } = this.props;\n      return (\n        <ToggleButton\n          classNamePrefix={classNamePrefix}\n          isOn={isPipActive}\n          className={className}\n          label={label}\n          onToggle={this.handleToggle}\n          toggledOnContent={pipActiveContent}\n          toggledOffContent={pipInactiveContent}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nPipButton.displayName = 'PipButton';\nexport default PipButton;\n","// @flow\nimport * as React from 'react';\nimport ToggleButton from '../../generic/ToggleButton/ToggleButton';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  isPaused?: boolean,\n  setProperties?: ({ isPaused: boolean }) => void,\n\n  playingContent: React.Node,\n  pausedContent: React.Node\n};\n\nconst className = 'play-pause-button';\n\nclass PlayPauseButton extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['isPaused'];\n\n  handleToggle = (value: boolean) => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ isPaused: value });\n    }\n  };\n\n  render() {\n    const { isPaused, pausedContent, playingContent, label, classNamePrefix } = this.props;\n    return (\n      <ToggleButton\n        classNamePrefix={classNamePrefix}\n        isOn={isPaused}\n        className={className}\n        useDefaultClassNaming={true}\n        label={label}\n        onToggle={this.handleToggle}\n        toggledOnContent={pausedContent}\n        toggledOffContent={playingContent}\n      />\n    );\n  }\n}\n\nPlayPauseButton.displayName = 'PlayPauseButton';\nexport default PlayPauseButton;\n","// @flow\n\nimport * as React from 'react';\nimport type { CommonProps } from '../../common';\nimport type { VideoStreamState } from '../../player/VideoStreamer/types';\nimport { defaultClassNamePrefix, isDifferent, prefixClassNames } from '../../common';\nimport Button from '../../generic/Button/Button';\nimport connectControl from '../../player/PlayerController/connectControl';\nimport type { InspectMethod } from '../../player/PlayerController/ControllerContext';\nimport replayVersion from '../../../version';\n\ntype PlaybackMonitorConfiguration = {\n  visibleAtStart?: boolean\n};\n\ntype Props = CommonProps & {\n  /** Optional object containing the property playbackMonitor: { visibleAtStart: true } in order to display it immediately. */\n  configuration?: {\n    playbackMonitor?: PlaybackMonitorConfiguration\n  },\n  /** The content of the overlay's close button. */\n  closeButtonContent: ?React.Node\n};\n\ntype State = {\n  isMonitorVisible: boolean\n};\n\ntype PrefixedClassNames = {\n  propName: string,\n  currentValue: string,\n  previousValue: string,\n  headerRow: string\n};\n\ntype TableRowProps = VideoStreamState & {\n  propertyName: string,\n  inspect: InspectMethod,\n  prefixedClassNames: PrefixedClassNames\n};\n\ntype TableRowState = {\n  currentValue: any,\n  previousValue?: any\n};\n\nconst orderedPropertyNames = [\n  'playMode',\n  'playState',\n  'isPaused',\n  'isBuffering',\n  'isSeeking',\n  'position',\n  'duration',\n  'absolutePosition',\n  'absoluteStartPosition',\n  'isAtLiveEdge',\n  'isPipAvailable',\n  'isPipActive',\n  'isAirPlayAvailable',\n  'isAirPlayActive',\n  'bufferedAhead',\n  'bitrateFix',\n  'bitrateCap',\n  'currentBitrate',\n  'bitrates',\n  'currentTextTrack',\n  'textTracks',\n  'currentAudioTrack',\n  'audioTracks',\n  'volume',\n  'isMuted',\n  'error'\n];\n\nconst className = 'playback-monitor';\nconst tableClassName = 'playback-monitor-stream-state';\nconst headerRowClassName = 'playback-monitor-table-header';\nconst propNameClassName = 'playback-monitor-property-name';\nconst currentValueClassName = 'playback-monitor-current-value';\nconst previousValueClassName = 'playback-monitor-previous-value';\nconst closeButtonClassName = 'playback-monitor-close-button';\nconst headerClassName = 'playback-monitor-header';\nconst versionClassName = 'playback-monitor-version';\n\nconst closeButtonLabel = 'Close';\n\nconst formatValue = (val: any): string => {\n  if (val instanceof Date) {\n    if (isNaN(val.getTime())) {\n      return val.toString();\n    } else {\n      return val.toISOString();\n    }\n  } else if (typeof val === 'number') {\n    if (val % 1 !== 0) {\n      return val.toFixed(2);\n    } else {\n      return val;\n    }\n  } else if (typeof val === 'function') {\n    return 'function :-o';\n  } else if (val instanceof Error) {\n    const parts = [];\n    if (val.message) {\n      parts.push(`message: '${val.message}'`);\n    }\n    if (val.code) {\n      parts.push(`code: '${val.code}'`);\n    }\n    if (val.severity) {\n      parts.push(`severity: '${val.severity}'`);\n    }\n    return `{${parts.join(',')}}`;\n  } else if (Array.isArray(val)) {\n    return '[' + val.map(formatValue).join(',') + ']';\n  } else if (typeof val === 'boolean') {\n    return val.toString();\n  } else if (typeof val === 'string') {\n    return val;\n  } else if (val) {\n    return JSON.stringify(val)\n      .replace(/(\")(([A-Z]|[a-z]|[0-9])+)(\")(:)/g, '$2$5')\n      .replace(/(handlers|props|methods|constants):\\{(.*?)},/g, '');\n  } else {\n    return val;\n  }\n};\n\nexport class PropTableRow extends React.Component<TableRowProps, TableRowState> {\n  constructor(props: TableRowProps) {\n    super(props);\n    this.state = {\n      currentValue: props.inspect()[props.propertyName]\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: TableRowProps, prevState: TableRowState) {\n    if (nextProps.propertyName in nextProps && isDifferent(nextProps[nextProps.propertyName], prevState.currentValue)) {\n      return {\n        currentValue: nextProps[nextProps.propertyName],\n        previousValue: prevState.currentValue\n      };\n    } else {\n      return null;\n    }\n  }\n\n  render() {\n    const { prefixedClassNames, propertyName } = this.props;\n    const { currentValue, previousValue } = this.state;\n    const formattedCurrentValue = formatValue(currentValue);\n    const formattedPreviousValue = formatValue(previousValue);\n    return (\n      <tr>\n        <th title={propertyName} className={prefixedClassNames.propName}>\n          {propertyName}\n        </th>\n        <td title={formattedCurrentValue} className={prefixedClassNames.currentValue}>\n          {formattedCurrentValue}\n        </td>\n        <td title={formattedPreviousValue} className={prefixedClassNames.previousValue}>\n          {formattedPreviousValue}\n        </td>\n      </tr>\n    );\n  }\n}\n\nconst connectedComponents = {};\n\norderedPropertyNames.forEach(propertyName => {\n  connectedComponents[propertyName] = connectControl(PropTableRow, [propertyName]);\n});\n\nconst renderTableRows = classNamePrefix => {\n  const prefixedClassNames = {\n    headerRow: prefixClassNames(classNamePrefix, headerRowClassName),\n    propName: prefixClassNames(classNamePrefix, propNameClassName),\n    currentValue: prefixClassNames(classNamePrefix, currentValueClassName),\n    previousValue: prefixClassNames(classNamePrefix, previousValueClassName)\n  };\n  return [<TableHeaderRow key=\"header-row\" prefixedClassNames={prefixedClassNames} />].concat(\n    orderedPropertyNames.map(propertyName => {\n      const ConnectedPropRow = connectedComponents[propertyName];\n      return (\n        <ConnectedPropRow\n          key={`prop-row-${propertyName}`}\n          prefixedClassNames={prefixedClassNames}\n          propertyName={propertyName}\n        />\n      );\n    })\n  );\n};\n\nconst TableHeaderRow = ({ prefixedClassNames }: { prefixedClassNames: PrefixedClassNames }) => (\n  <tr className={prefixedClassNames.headerRow}>\n    <th className={prefixedClassNames.propName}>Property name</th>\n    <th className={prefixedClassNames.currentValue}>Current value</th>\n    <th className={prefixedClassNames.previousValue}>Previous value</th>\n  </tr>\n);\n\nclass PlaybackMonitor extends React.Component<Props, State> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      isMonitorVisible: !!(\n        props.configuration &&\n        props.configuration.playbackMonitor &&\n        props.configuration.playbackMonitor.visibleAtStart\n      )\n    };\n  }\n\n  handleCloseClick = () => this.setState({ isMonitorVisible: false });\n\n  handleKeyDown = (keyboardEvent: KeyboardEvent) => {\n    if (keyboardEvent.ctrlKey && keyboardEvent.altKey && keyboardEvent.code === 'KeyM') {\n      this.setState({ isMonitorVisible: !this.state.isMonitorVisible });\n    }\n  };\n\n  componentDidMount() {\n    document.addEventListener('keydown', this.handleKeyDown);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('keydown', this.handleKeyDown);\n  }\n\n  render() {\n    const { label, classNamePrefix, closeButtonContent } = this.props;\n    if (this.state.isMonitorVisible) {\n      return (\n        <div title={label} className={prefixClassNames(classNamePrefix, className)}>\n          <div className={prefixClassNames(classNamePrefix, headerClassName)}>\n            <Button\n              className={closeButtonClassName}\n              classNamePrefix={classNamePrefix}\n              content={closeButtonContent}\n              label={closeButtonLabel}\n              onClick={this.handleCloseClick}\n            />\n            <p className={prefixClassNames(classNamePrefix, versionClassName)}>Replay v{replayVersion}</p>\n          </div>\n          <table className={prefixClassNames(classNamePrefix, tableClassName)}>\n            <tbody>{renderTableRows(classNamePrefix)}</tbody>\n          </table>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nPlaybackMonitor.displayName = 'PlaybackMonitor';\nexport default PlaybackMonitor;\n","// @flow\nimport * as React from 'react';\nimport Button from '../../generic/Button/Button';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport type { InspectMethod } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** The position from which the skipped position is computed. Not recommended to set this, but rather provide inspect(). */\n  position?: number,\n  /** Configures the offset that will be added to the current position when clicking the button. Negative values mean skipping backward. */\n  offset: number,\n  /** Button content, e.g. icon. */\n  content: React.Node,\n  /** ⇘︎ A callback returning the current video stream state with a position property when invoked. Invoked on clicking the button, and the position property is used for computing the new position. */\n  inspect?: InspectMethod,\n  /** ⇗ When the button is clicked, this callback is invoked with an object having a position property with the computed new position based on the skip offset. */\n  setProperties?: ({ position: number }) => void\n};\n\nconst className = 'skip-button';\n\nclass SkipButton extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix,\n    offset: -30\n  };\n\n  handleClick = () => {\n    const setProperties = this.props.setProperties;\n    if (setProperties) {\n      const currentPosition =\n        typeof this.props.inspect === 'function' ? this.props.inspect().position : this.props.position;\n      const position = currentPosition + this.props.offset;\n      if (!isNaN(position)) {\n        setProperties({ position });\n      }\n    }\n  };\n\n  render() {\n    const { content, label, classNamePrefix } = this.props;\n    return (\n      <Button\n        classNamePrefix={classNamePrefix}\n        className={className}\n        label={label}\n        onClick={this.handleClick}\n        content={content}\n      />\n    );\n  }\n}\n\nSkipButton.displayName = 'SkipButton';\nexport default SkipButton;\n","// @flow\nimport * as React from 'react';\nimport Selector from '../../generic/Selector/Selector';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { AvailableTrack } from '../../player/VideoStreamer/types';\nimport type { CommonProps } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The list of text tracks available for selection. */\n  textTracks?: Array<AvailableTrack>,\n  /** ⇘ The currently displaying text track. Must be strict equal one of the items in the text track list. Set to null if no subtitles are displayed. */\n  currentTextTrack?: AvailableTrack,\n  /** ⇗ When one item is clicked, this callback is invoked with an object having an selectedTextTrack property with the textTrack object corresponding to the selection. */\n  setProperties?: ({ selectedTextTrack: ?AvailableTrack }) => void,\n  /** The label to use on the selector option for not displaying subtitles. */\n  noSubtitlesLabel: string,\n  /** Element displayed in the control bar for expanding/collapsing the selector items. */\n  toggleContent: React.Node\n};\n\ntype State = {\n  noSubtitlesItem: { noTrack: true, label: string }\n};\n\nconst className = 'subtitles-selector';\n\nconst defaultKind = 'subtitles';\n\nconst buildId = (...str: Array<?string>) => str.filter(s => s).join('.');\n// TODO: Consider injectable label mapper, and also for audio selector and bitrate selector.\nconst buildLabel = ({ label, kind = defaultKind, language = 'unknown' }: AvailableTrack) =>\n  label || (kind !== defaultKind ? `[${language}] ${kind}` : `[${language}]`) || '';\n\nconst textTrackToItem = (track: AvailableTrack | { noTrack: true, label: string }) => {\n  if (track.noTrack) {\n    const label = track.label || '';\n    return {\n      id: 0,\n      label,\n      data: track\n    };\n  } else {\n    return {\n      id: track.id || buildId(track.language, track.kind, track.origin) || track.label,\n      label: buildLabel(track),\n      data: track\n    };\n  }\n};\n\nclass SubtitlesSelector extends React.Component<Props, State> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['textTracks', 'currentTextTrack'];\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      noSubtitlesItem: { noTrack: true, label: this.props.noSubtitlesLabel }\n    };\n  }\n\n  handleSelect = (item: any) => {\n    if (this.props.setProperties) {\n      if (item.noTrack) {\n        this.props.setProperties({ selectedTextTrack: null });\n      } else {\n        this.props.setProperties({ selectedTextTrack: item });\n      }\n    }\n  };\n\n  render() {\n    const { textTracks, currentTextTrack, label, toggleContent, classNamePrefix } = this.props;\n    if (Array.isArray(textTracks) && textTracks.length > 0) {\n      // TODO: Consider optimization, memoizing the array and all props involved in rendering.\n      const items = [this.state.noSubtitlesItem].concat(textTracks);\n      let selectedItem = this.state.noSubtitlesItem;\n      if (currentTextTrack) {\n        const selectedIndex = textTracks.indexOf(currentTextTrack) + 1; // Nasty detail. Including \"no subtitles\" when counting.\n        if (selectedIndex > 0) {\n          selectedItem = items[selectedIndex];\n        }\n      }\n      return (\n        <Selector\n          items={items}\n          itemMapper={textTrackToItem}\n          classNamePrefix={classNamePrefix}\n          className={className}\n          selectedItem={selectedItem}\n          label={label}\n          onSelect={this.handleSelect}\n          reverseOrder={true}\n          expandedToggleContent={toggleContent}\n          collapsedToggleContent={toggleContent}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nSubtitlesSelector.displayName = 'SubtitlesSelector';\nexport default SubtitlesSelector;\n","// @flow\n\nimport * as React from 'react';\nimport type { CommonProps } from '../../common';\nimport { defaultClassNamePrefix, formatClockTime, formatTime, prefixClassNames } from '../../common';\nimport type { PlayMode } from '../../player/VideoStreamer/types';\nimport type { ObservingControlStaticProps } from '../../player/PlayerController/ControllerContext';\n\nexport type LiveDisplayMode = 'clock-time' | 'live-offset';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The relative playback position, used for on demand position and timeshift offset display. */\n  position?: number,\n  /** ⇘︎ The duration of the stream, used for on demand position and timeshift offset display. */\n  duration?: number,\n  /** ⇘︎ The clock time, used for live streams and DVR streams when liveDisplayMode is set to 'live-offset'. */\n  absolutePosition?: ?Date,\n  /** ⇘︎ Play mode is used to decide what times to display. */\n  playMode?: PlayMode,\n  /** When set to 'live-offset', DVR times will be displayed as offsets from the live edge. Default is 'clock-time'. */\n  liveDisplayMode?: LiveDisplayMode,\n  negativeMark?: string,\n  positionLabel?: string,\n  durationLabel?: string,\n  clockTimeLabel?: string\n};\n\ntype TimeDisplayType = React.StatelessFunctionalComponent<Props> & ObservingControlStaticProps;\n\nconst className = 'time-display';\nconst positionClassName = 'time-display-position';\nconst durationClassName = 'time-display-duration';\nconst clockTimeClassName = 'time-display-clock-time';\nconst noDurationClassName = 'time-display-no-duration';\n\nconst isReasonableDateTime = date => date instanceof Date && !isNaN(date.getTime()) && date.getTime() > 1514761200000;\n\nconst formatAndLimitTime = (time: ?number, negativeMark?: string, zeroAndBelow: boolean = false) =>\n  formatTime(time == null ? 0 : Math[zeroAndBelow ? 'min' : 'max'](0, time), negativeMark);\n\nconst TimeDisplay: TimeDisplayType = ({\n  position,\n  duration,\n  absolutePosition,\n  playMode,\n  liveDisplayMode = 'clock-time',\n  negativeMark,\n  label,\n  positionLabel,\n  durationLabel,\n  clockTimeLabel,\n  classNamePrefix = defaultClassNamePrefix\n}: Props) => {\n  if (playMode === 'ondemand') {\n    return (\n      <div className={prefixClassNames(classNamePrefix, className)} title={label}>\n        <span className={prefixClassNames(classNamePrefix, positionClassName)} title={positionLabel}>\n          {formatAndLimitTime(position, negativeMark)}\n        </span>\n        <span className={prefixClassNames(classNamePrefix, durationClassName)} title={durationLabel}>\n          {formatAndLimitTime(duration, negativeMark)}\n        </span>\n      </div>\n    );\n  } else {\n    if ((liveDisplayMode === 'live-offset' && playMode === 'livedvr') || !isReasonableDateTime(absolutePosition)) {\n      return (\n        <div className={prefixClassNames(classNamePrefix, className)} title={label}>\n          <span className={prefixClassNames(classNamePrefix, positionClassName)} title={positionLabel}>\n            {formatAndLimitTime((position || duration || 0) - (duration || 0), negativeMark, true)}\n          </span>\n          {playMode === 'livedvr' && (\n            <span className={prefixClassNames(classNamePrefix, durationClassName)} title={durationLabel}>\n              {formatAndLimitTime(duration, negativeMark)}\n            </span>\n          )}\n        </div>\n      );\n    } else {\n      return (\n        <div className={prefixClassNames(classNamePrefix, className, noDurationClassName)} title={label}>\n          <span className={prefixClassNames(classNamePrefix, clockTimeClassName)} title={positionLabel}>\n            {formatClockTime(absolutePosition)}\n          </span>\n        </div>\n      );\n    }\n  }\n};\n\nTimeDisplay.streamStateKeysForObservation = ['position', 'duration', 'absolutePosition', 'playMode'];\nTimeDisplay.displayName = 'TimeDisplay';\n\nexport default TimeDisplay;\n","// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport Slider from '../../generic/Slider/Slider';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The current playback position in seconds (with decimals). A value between 0 and duration. */\n  position?: number,\n  /** ⇘︎ The stream's duration or seekable range in seconds (with decimals). */\n  duration?: number,\n  /** ⇘︎ True if a seeking operation is ongoing. This prop is used by the component to avoid glitching while dragging. */\n  isSeeking?: boolean,\n  /** Elements that will display on top of the timeline slider track, but below the timeline handle. */\n  children?: React.Node,\n  /** Can be set for custom graphics or content in the slider handle. */\n  handleContent?: React.Node,\n  /** Can be set for custom graphics or content representing the slider track. */\n  trackContent?: React.Node,\n  /** ⇗ If the volume slider handle position is changed, this callback is invoked with { position: newPosition } */\n  setProperties?: ({ position: number }) => void,\n  /** If set to false, glitches after dragging completes will occur, while the stream reports a position before seeking is performed. When true glitches are prevented by activating a timer for a small time after dragging has completed.*/\n  reduceDragGlitch?: boolean\n};\n\ntype State = {\n  isDragging: boolean\n};\n\nconst className = 'timeline';\nconst trackClassName = 'timeline-track';\nconst handleClassName = 'timeline-handle';\n\nclass Timeline extends React.Component<Props, State> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix,\n    reduceDragGlitch: true\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['position', 'duration', 'isSeeking'];\n\n  timeoutId: ?TimeoutID;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = { isDragging: false };\n  }\n\n  handleSliderChange = (position: number) => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ position });\n    }\n  };\n\n  handleDrag = () => {\n    this.setState({ isDragging: true });\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n    this.timeoutId = setTimeout(() => {\n      this.setState({ isDragging: false });\n      this.timeoutId = null;\n    }, 800);\n  };\n\n  componentWillUnmount() {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n\n  render() {\n    const {\n      position,\n      duration,\n      isSeeking,\n      label,\n      classNamePrefix,\n      children,\n      handleContent,\n      trackContent,\n      reduceDragGlitch\n    } = this.props;\n    return (\n      <Slider\n        label={label}\n        value={position}\n        maxValue={duration}\n        isUpdateBlocked={isSeeking || this.state.isDragging}\n        handleContent={handleContent}\n        trackContent={trackContent}\n        onValueChange={this.handleSliderChange}\n        onDrag={reduceDragGlitch ? this.handleDrag : undefined}\n        classNamePrefix={classNamePrefix}\n        className={className}\n        trackClassName={trackClassName}\n        handleClassName={handleClassName}>\n        {children}\n      </Slider>\n    );\n  }\n}\n\nTimeline.displayName = 'Timeline';\nexport default Timeline;\n","// @flow\nimport * as React from 'react';\nimport { formatTime, formatClockTime, prefixClassNames, defaultClassNamePrefix } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\nimport type { PlayMode } from '../../player/VideoStreamer/types';\nimport type { CommonProps } from '../../common';\n\ntype Props = CommonProps & {\n  /** ⇘︎ For previewing live clock time positions, this should contain the date/time corresponding to the start of the timeline.. */\n  absoluteStartPosition?: Date,\n  /** ⇘︎ Used for selecting relative position or clock time display. */\n  playMode?: PlayMode,\n  /** ⇘︎ Used for computing the tooltip position. */\n  duration?: number,\n  /** The relative preview position, passed automatically from a Timeline parent. */\n  previewValue?: ?number,\n  /** The Timeline parent manages mouse pointer state, and passes to this component. If true, the tooltip is displayed. */\n  isPointerInside?: boolean,\n  /** Passed from the Timeline parent. When dragging, it is set to true, and the tooltip displays. */\n  isDragging?: ?boolean\n};\n\nconst className = 'timeline-information';\nconst tooltipClassName = 'timeline-tooltip';\nconst tooltipVisibleClassName = 'timeline-tooltip-visible';\n\nconst getTimeDisplay = (playMode: ?PlayMode, absoluteStartPosition: ?Date, previewValue: ?number): string => {\n  if (previewValue != null) {\n    if (playMode === 'livedvr' && absoluteStartPosition instanceof Date && absoluteStartPosition.getTime() > 0) {\n      return formatClockTime(new Date(absoluteStartPosition.getTime() + previewValue * 1000));\n    } else {\n      return formatTime(previewValue);\n    }\n  } else {\n    return '';\n  }\n};\n\nclass TimelineInformation extends React.Component<Props> {\n  static streamStateKeysForObservation: StreamStateKeysForObservation = [\n    'absoluteStartPosition',\n    'duration',\n    'playMode'\n  ];\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  render() {\n    const {\n      absoluteStartPosition,\n      duration,\n      playMode,\n      previewValue,\n      isDragging,\n      isPointerInside,\n      classNamePrefix\n    } = this.props;\n    const timeDisplay = getTimeDisplay(playMode, absoluteStartPosition, previewValue);\n    const left = (((previewValue || 0) / (duration || 1)) * 100).toFixed(2);\n    const prefixedClassName = prefixClassNames(classNamePrefix, className);\n    const prefixedTooltipClassNames = prefixClassNames(\n      classNamePrefix,\n      tooltipClassName,\n      isDragging || isPointerInside ? tooltipVisibleClassName : null\n    );\n    return (\n      <div className={prefixedClassName}>\n        <div className={prefixedTooltipClassNames} style={{ left: `${left}%` }}>\n          {timeDisplay}\n        </div>\n      </div>\n    );\n  }\n}\n\nTimelineInformation.displayName = 'TimelineInformation';\nexport default TimelineInformation;\n","// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix, prefixClassNames } from '../../common';\nimport type { CommonProps } from '../../common';\nimport ToggleButton from '../../generic/ToggleButton/ToggleButton';\nimport Slider from '../../generic/Slider/Slider';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The current volume level, a number between 0 and 1. */\n  volume?: number,\n  /** ⇘︎ The current mute state. false means unmuted. */\n  isMuted?: boolean,\n  volumeSliderLabel?: string,\n  muteToggleLabel?: string,\n  /** Element(s) displayed when isMuted is set to true The convention is to display a disabled or \"silent\" loudspeaker icon. */\n  mutedContent: React.Node,\n  /** Element(s) displayed when isMuted is set to false The convention is to display a loudspeaker icon with sound waves. */\n  unmutedContent: React.Node,\n  volumeSliderHandleContent?: React.Node,\n  volumeSliderTrackContent?: React.Node,\n  /** ⇗ This callback is invoked with { isMuted: true } or { isMuted: false } when the mute button is toggled. If the volume slider handle position is changed, it is invoked with { volume: newLevel } */\n  setProperties?: ({ volume: number } | { isMuted: boolean }) => void\n};\n\nconst className = 'volume';\nconst disabledClassName = 'volume-disabled';\nconst muteToggleClassName = 'mute-toggle';\nconst volumeSliderClassName = 'volume-slider';\nconst volumeSliderHandleClassName = 'volume-slider-handle';\nconst volumeSliderTrackClassName = 'volume-slider-track';\nconst maxVolume = 1;\n\nclass Volume extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['volume', 'isMuted'];\n\n  handleMuteToggleClick = (isMuted: boolean) => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ isMuted });\n    }\n  };\n\n  handleVolumeSliderChange = (volume: number) => {\n    const setProperties = this.props.setProperties;\n    if (setProperties) {\n      setProperties({ isMuted: false, volume });\n    }\n  };\n\n  render() {\n    const isIos = navigator.userAgent.match(/(iPad|iPhone|iPod)/i);\n    const {\n      volume,\n      isMuted,\n      label,\n      volumeSliderLabel,\n      muteToggleLabel,\n      classNamePrefix,\n      mutedContent,\n      unmutedContent,\n      volumeSliderHandleContent,\n      volumeSliderTrackContent\n    } = this.props;\n    const prefixedClassName = prefixClassNames(classNamePrefix, className, isIos && disabledClassName);\n    return (\n      <div className={prefixedClassName} title={label}>\n        <ToggleButton\n          label={muteToggleLabel}\n          isOn={isMuted}\n          toggledOffContent={unmutedContent}\n          toggledOnContent={mutedContent}\n          onToggle={this.handleMuteToggleClick}\n          classNamePrefix={classNamePrefix}\n          className={muteToggleClassName}\n        />\n        {!isIos && (\n          <Slider\n            label={volumeSliderLabel}\n            value={isMuted ? 0 : volume}\n            maxValue={maxVolume}\n            handleContent={volumeSliderHandleContent}\n            trackContent={volumeSliderTrackContent}\n            onValueChange={this.handleVolumeSliderChange}\n            classNamePrefix={classNamePrefix}\n            className={volumeSliderClassName}\n            trackClassName={volumeSliderTrackClassName}\n            handleClassName={volumeSliderHandleClassName}\n          />\n        )}\n      </div>\n    );\n  }\n}\n\nVolume.displayName = 'Volume';\nexport default Volume;\n","// @flow\nimport * as React from 'react';\nimport { type CommonGenericProps, getKeyboardShortcutBlocker, hydrateClassNames } from '../../common';\n\ntype Props = CommonGenericProps & {\n  label?: string,\n  content?: React.Node,\n  onClick?: () => void\n};\n\nconst baseClassName = 'button';\nconst selectClasses = classes => classes.button;\n\nclass Button extends React.Component<Props> {\n  static defaultProps = {\n    useDefaultClassNaming: true\n  };\n\n  handleClick = () => this.props.onClick && this.props.onClick();\n\n  handleKeyDown = getKeyboardShortcutBlocker(['Enter', ' ']);\n\n  handleKeyUp = (keyboardEvent: KeyboardEvent) => {\n    if (keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ') {\n      keyboardEvent.preventDefault();\n      this.handleClick();\n    }\n  };\n\n  render() {\n    const { label, className, classNamePrefix, classes, content }: Props = this.props;\n    const classNames = hydrateClassNames({\n      classes,\n      selectClasses,\n      classNames: [baseClassName, className],\n      classNamePrefix\n    }); // buildClassNames(useDefaultClassNaming, classNamePrefix, className, baseClassName);\n    return (\n      <div\n        title={label}\n        onClick={this.handleClick}\n        onKeyDown={this.handleKeyDown}\n        onKeyUp={this.handleKeyUp}\n        className={classNames}\n        role=\"button\"\n        tabIndex={0}>\n        <div tabIndex={-1}>{content}</div>\n      </div>\n    );\n  }\n}\n\nexport default Button;\n","// @flow\nimport * as React from 'react';\nimport type { PlaybackProps, VideoStreamState, VideoStreamStateKeys } from '../VideoStreamer/types';\n\nexport type ObserveCallback = ({ [VideoStreamStateKeys]: any }) => void;\nexport type ObserveMethod = (VideoStreamStateKeys, ObserveCallback) => void;\nexport type UnobserveMethod = ObserveMethod;\nexport type InspectMethod = () => VideoStreamState;\nexport type SetPropertiesMethod = PlaybackProps => void;\n\nexport type StreamStateKeysForObservation = Array<VideoStreamStateKeys>;\nexport type ObservingControlStaticProps = {\n  streamStateKeysForObservation?: StreamStateKeysForObservation\n};\n\nexport type ControllerApi = {\n  setProperties: SetPropertiesMethod,\n  observe: ?ObserveMethod,\n  inspect: InspectMethod,\n  videoStreamer: ?React.Element<any>,\n  unobserve: ObserveMethod\n};\nconst initialContextValue: ControllerApi = {\n  setProperties: () => {},\n  videoStreamer: null,\n  inspect: () => ({}),\n  observe: null,\n  unobserve: () => {}\n};\nconst ControllerContext = React.createContext<ControllerApi>(initialContextValue);\n\nexport default ControllerContext;\n","// @flow\nimport * as React from 'react';\nimport ControllerContext from './ControllerContext';\nimport type { InspectMethod, ObserveMethod, UnobserveMethod, SetPropertiesMethod } from './ControllerContext';\nimport type { VideoStreamState, VideoStreamStateKeys } from '../VideoStreamer/types';\nimport type { CommonGenericProps } from '../../common';\n\ntype HandleChangeMethod = ({ [VideoStreamStateKeys]: any }) => void;\n\ntype PassdownProps = VideoStreamState & {\n  setProperties?: SetPropertiesMethod,\n  inspect?: InspectMethod\n};\n\ntype ObserverProps = {\n  observe: ObserveMethod,\n  unobserve: UnobserveMethod,\n  inspect: InspectMethod,\n  passdownProps: PassdownProps\n};\n\n/*\nconst getObserver = (callback: HandleChangeMethod) => (key: string, value: any) => {\n  callback({ [key]: value });\n};\n*/\nconst registerObservers = (observe: ObserveMethod, keys: Array<VideoStreamStateKeys>, onChange: HandleChangeMethod) =>\n  keys.forEach(p => observe(p, onChange));\n\nconst connectControl = <Props: {}>(\n  Control: React.ComponentType<Props>,\n  stateKeys?: Array<VideoStreamStateKeys>\n): React.ComponentType<$Diff<Props, PassdownProps>> => {\n  // $FlowFixMe What's the best practices for extending component classes with static properties?\n  const resolvedStateKeys = stateKeys || Control.streamStateKeysForObservation || [];\n  if (!Array.isArray(resolvedStateKeys)) {\n    // Good old runtime check.\n    throw new Error(\n      `The component ${Control.displayName ||\n        Control.name} cannot be connected to the player controller because no stream state property keys are specified to be observed.`\n    );\n  }\n\n  class Observer extends React.Component<ObserverProps, any> {\n    constructor(props) {\n      super(props);\n      const currentState = props.inspect();\n      const initialState = {};\n      if (currentState) {\n        resolvedStateKeys.forEach(key => (initialState[key] = currentState[key]));\n      }\n      this.state = initialState;\n    }\n\n    update = prop => this.setState(prop);\n\n    componentWillUnmount() {\n      registerObservers(this.props.unobserve, resolvedStateKeys, this.update);\n    }\n\n    componentDidMount() {\n      registerObservers(this.props.observe, resolvedStateKeys, this.update);\n      const currentState = this.props.inspect();\n      if (currentState) {\n        resolvedStateKeys.forEach(key => this.setState({ [key]: currentState[key] }));\n      }\n    }\n\n    render() {\n      return <Control {...{ ...this.props.passdownProps, ...this.state }} />;\n    }\n  }\n\n  const ConnectedControl = (props: $Diff<Props, PassdownProps>) => (\n    <ControllerContext.Consumer>\n      {({ observe, unobserve, setProperties, inspect }) => {\n        if (observe) {\n          return (\n            <Observer\n              observe={observe}\n              unobserve={unobserve}\n              inspect={inspect}\n              passdownProps={{ ...props, setProperties, inspect }}\n            />\n          );\n        } else {\n          return <Control {...{ ...props, setProperties, inspect }} />;\n        }\n      }}\n    </ControllerContext.Consumer>\n  );\n\n  if (Control.displayName) {\n    ConnectedControl.displayName = 'Connected' + Control.displayName;\n  } else if (process.env.NODE_ENV === 'development') {\n    ConnectedControl.controlWithoutDisplayName = Control.name + ' wrapped in ConnectedControl';\n  } else {\n    ConnectedControl.displayName = 'Connected' + Control.name;\n  }\n  return ConnectedControl;\n};\n\nexport const ControlledVideoStreamer: React.StatelessFunctionalComponent<CommonGenericProps> = props => (\n  <ControllerContext.Consumer>\n    {({ videoStreamer }) => (videoStreamer != null ? React.cloneElement(videoStreamer, props) : null)}\n  </ControllerContext.Consumer>\n);\n\nexport default connectControl;\n","// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix, prefixClassNames } from '../../common';\nimport memoize from 'memoize-one';\n\ntype Props = {\n  aspectRatio?: {\n    horizontal: number,\n    vertical: number\n  },\n  classNamePrefix?: string,\n  aspectFixClassName?: ?string,\n  render: () => React.Node,\n  rootClassName?: string\n};\n\nconst outerStyle = { position: 'relative', maxHeight: '100vh' };\n\nconst helperStyle = {\n  display: 'block',\n  width: '100%',\n  paddingTop: '56.25%',\n  pointerEvents: 'none'\n};\n\nconst getHelperStyle = memoize(aspectRatio =>\n  aspectRatio\n    ? { ...helperStyle, paddingTop: ((aspectRatio.vertical * 100) / aspectRatio.horizontal).toFixed(2) + '%' }\n    : helperStyle\n);\n\nconst AspectRatio = ({\n  aspectRatio,\n  render,\n  rootClassName = '',\n  aspectFixClassName,\n  classNamePrefix = defaultClassNamePrefix\n}: Props) => {\n  if (aspectFixClassName) {\n    return (\n      <div className={`${rootClassName} ${prefixClassNames(classNamePrefix, aspectFixClassName)}`}>{render()}</div>\n    );\n  } else {\n    const beforeStyle = getHelperStyle(aspectRatio);\n    return (\n      <div className={rootClassName} style={outerStyle}>\n        <div style={beforeStyle} />\n        {render()}\n      </div>\n    );\n  }\n};\n\nexport default AspectRatio;\n","// @flow\nimport * as React from 'react';\n\ntype RenderParameters = {\n  isUserActive: boolean,\n  nudge: () => void,\n  toggleFixedUserActive: () => void,\n  handleMouseMove: (evt: MouseEvent) => void,\n  handleFocus: (evt: FocusEvent) => void,\n  handleTouchStart: (evt: TouchEvent) => void,\n  handleTouchEnd: (evt: TouchEvent) => void\n};\n\nexport type InteractionDetectorConfiguration = {\n  inactivityDelay: number\n};\n\ntype Props = {\n  configuration?: {\n    interactionDetector?: InteractionDetectorConfiguration\n  },\n  render: RenderParameters => React.Node\n};\n\ntype State = {\n  isUserActive: boolean\n};\n\ntype InteractionState = {\n  isMouseMoved: boolean,\n  isTouched: boolean,\n  isTouching: boolean,\n  isEntered: boolean,\n  clientX: number,\n  clientY: number\n};\n\nconst getDelaySeconds = configuration =>\n  configuration && configuration.interactionDetector && configuration.interactionDetector.inactivityDelay != null\n    ? configuration.interactionDetector.inactivityDelay\n    : 0;\n\nclass InteractionDetector extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { isUserActive: true };\n  }\n\n  isFixed: boolean = false;\n  intervalId: IntervalID;\n  inactivityTimeoutId: TimeoutID;\n  flags: InteractionState = {\n    isMouseMoved: true,\n    isTouched: false,\n    isTouching: false,\n    isEntered: false,\n    clientX: -1,\n    clientY: -1\n  };\n\n  componentDidMount() {\n    const delaySeconds = getDelaySeconds(this.props.configuration);\n    if (delaySeconds >= 0) {\n      // Negative values deactivate\n      this.intervalId = setInterval(this.updateActivity, 250); // This interval is not the inactivity delay.\n    }\n  }\n\n  componentDidUpdate(prevProps: Props, prevState: State) {\n    const delaySeconds = getDelaySeconds(this.props.configuration);\n    if (delaySeconds !== getDelaySeconds(prevProps.configuration)) {\n      if (this.intervalId) {\n        clearInterval(this.intervalId);\n      }\n      if (delaySeconds >= 0) {\n        // Negative values deactivate\n        this.intervalId = setInterval(this.updateActivity, 250); // This interval is not the inactivity delay.\n      } else {\n        this.setState({ isUserActive: true });\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n    }\n  }\n\n  handleMouseMove = (evt: MouseEvent) => {\n    if (evt.clientX !== this.flags.clientX || evt.clientY !== this.flags.clientY) {\n      this.flags.isMouseMoved = true;\n      this.flags.clientX = evt.clientX;\n      this.flags.clientY = evt.clientY;\n    }\n  };\n\n  handleTouchStart = () => {\n    this.flags.isTouched = true;\n    this.flags.isTouching = true;\n  };\n\n  handleTouchEnd = () => {\n    this.flags.isTouching = false;\n  };\n\n  nudge = () => {\n    this.flags.isMouseMoved = true;\n  };\n\n  toggleFixedUserActive = () => {\n    this.isFixed = !this.isFixed;\n    if (this.isFixed) {\n      this.flags.isMouseMoved = true;\n    } else {\n      this.setState({ isUserActive: false });\n    }\n  };\n\n  handleFocus = (focusEvent: FocusEvent) => {\n    if (focusEvent.target === focusEvent.currentTarget) {\n      this.nudge();\n    }\n  };\n\n  setInactive = () => {\n    if (!(this.isFixed || this.flags.isMouseMoved)) {\n      this.setState({ isUserActive: false });\n    }\n  };\n\n  updateActivity = () => {\n    if (this.flags.isMouseMoved || this.flags.isTouched || this.flags.isTouching) {\n      this.flags.isTouched = false;\n      this.flags.isMouseMoved = false;\n      if (!this.state.isUserActive) {\n        this.setState({ isUserActive: true });\n      }\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = setTimeout(this.setInactive, getDelaySeconds(this.props.configuration) * 1000);\n    }\n  };\n\n  render() {\n    const { isUserActive } = this.state;\n    const { render } = this.props;\n    const { handleMouseMove, handleTouchStart, handleTouchEnd, handleFocus, toggleFixedUserActive, nudge } = this;\n    return render({\n      isUserActive,\n      handleMouseMove,\n      handleTouchStart,\n      handleTouchEnd,\n      handleFocus,\n      toggleFixedUserActive: toggleFixedUserActive,\n      nudge\n    });\n  }\n}\n\nexport default InteractionDetector;\n","// @flow\nimport * as React from 'react';\nimport type { PlayMode } from '../VideoStreamer/types';\nimport type { FullscreenState } from './Fullscreen';\nimport type { InspectMethod } from '../PlayerController/ControllerContext';\n\ntype RenderParameters = {\n  handleKeyDown: KeyboardEvent => void\n};\n\ntype KeyMapping = string | Array<string>;\n\nexport type KeyboardShortcutsConfiguration = {\n  keyMap: {\n    togglePause?: KeyMapping,\n    toggleMute?: KeyMapping,\n    toggleFullscreen?: KeyMapping,\n    skipBack?: KeyMapping,\n    skipForward?: KeyMapping,\n    increaseVolume?: KeyMapping,\n    decreaseVolume?: KeyMapping\n  },\n  volumeStep?: number,\n  skipOffset?: number\n};\n\ntype UpdateableProperties = { volume: number } | { isMuted: boolean } | { isPaused: boolean } | { position: number };\n\ntype Props = {\n  nudge?: () => void,\n  toggleFixedUserActive?: () => void,\n  configuration?: {\n    keyboardShortcuts?: KeyboardShortcutsConfiguration\n  },\n  playMode?: ?PlayMode,\n  setProperties?: UpdateableProperties => void,\n  fullscreenState?: FullscreenState,\n  render: RenderParameters => React.Node,\n  isPaused?: ?boolean,\n  isMuted?: ?boolean,\n  position?: ?number,\n  duration?: ?number,\n  volume?: ?number,\n  inspect?: InspectMethod\n};\n\nconst matchKeyCaseSafely = (key: ?(string | any), eventKey: string): boolean => {\n  return typeof key !== 'string'\n    ? false\n    : key.length > 1\n    ? key === eventKey\n    : key.toLowerCase() === eventKey.toLowerCase();\n};\n\nconst getMatchingOperationFromKeyMap = (config: KeyboardShortcutsConfiguration, eventKey: string): ?string => {\n  if (config.keyMap) {\n    return Object.entries(config.keyMap)\n      .filter(\n        ([_, mappedKeys]) =>\n          !!(\n            matchKeyCaseSafely(mappedKeys, eventKey) ||\n            (Array.isArray(mappedKeys) && mappedKeys.filter(key => matchKeyCaseSafely(key, eventKey)).length)\n          )\n      )\n      .map(entry => entry[0])[0];\n  }\n};\n\nclass KeyboardShortcuts extends React.Component<Props> {\n  handleKeyDown = (keyboardEvent: KeyboardEvent) => {\n    let {\n      nudge,\n      toggleFixedUserActive,\n      configuration,\n      setProperties,\n      fullscreenState,\n      isPaused,\n      isMuted,\n      position,\n      duration,\n      volume,\n      playMode,\n      inspect\n    } = this.props;\n    if (inspect) {\n      const inspectedState = inspect();\n      isPaused = inspectedState.isPaused;\n      isMuted = inspectedState.isMuted;\n      position = inspectedState.position;\n      duration = inspectedState.duration;\n      volume = inspectedState.volume;\n      playMode = inspectedState.playMode;\n    }\n\n    if (configuration && configuration.keyboardShortcuts) {\n      const offset = configuration.keyboardShortcuts.skipOffset || 30;\n      const volumeStep = configuration.keyboardShortcuts.volumeStep || 0.1;\n      const operation = getMatchingOperationFromKeyMap(configuration.keyboardShortcuts, keyboardEvent.key);\n      if (operation) {\n        switch (operation) {\n          case 'togglePause':\n            setProperties && setProperties({ isPaused: !isPaused });\n            break;\n          case 'toggleMute':\n            setProperties && setProperties({ isMuted: !isMuted });\n            break;\n          case 'toggleFullscreen':\n            fullscreenState && fullscreenState.setProperties({ isFullscreen: !fullscreenState.isFullscreen });\n            break;\n          case 'skipBack':\n            setProperties && position != null && setProperties({ position: Math.max(position - offset, 0) });\n            break;\n          case 'skipForward':\n            if (setProperties && duration) {\n              const targetPosition = (position || 0) + offset;\n              // Skipping to the very end is just annoying. Skipping to live position makes sense.\n              if (targetPosition < duration || playMode !== 'ondemand') {\n                setProperties({ position: Math.min(targetPosition, duration) });\n              }\n            }\n            break;\n          case 'decreaseVolume':\n            setProperties && volume != null && setProperties({ volume: Math.max(volume - volumeStep, 0) });\n            break;\n          case 'increaseVolume':\n            setProperties && volume != null && setProperties({ volume: Math.min(volume + volumeStep, 1) });\n            break;\n          case 'toggleUserActive':\n            if (toggleFixedUserActive) {\n              toggleFixedUserActive();\n            }\n            break;\n          default:\n          // eslint requires default in switch. Can't see that this is a good case for such a requirement.\n        }\n        if (nudge && operation !== 'toggleUserActive') {\n          nudge();\n        }\n        keyboardEvent.preventDefault();\n      } else if (keyboardEvent.key === 'Tab' && nudge) {\n        nudge();\n      }\n    }\n  };\n\n  render() {\n    const { handleKeyDown } = this;\n    return this.props.render({ handleKeyDown });\n  }\n}\nexport default KeyboardShortcuts;\n","// @flow\n\nimport { type PlayState, type PlayMode } from '../VideoStreamer/types';\nimport { prefixClassNames } from '../../common';\n\nexport type ClassNameKeys =\n  | 'isBuffering'\n  | 'isStarting'\n  | 'isPlaying'\n  | 'isPaused'\n  | 'isSeeking'\n  | 'isMuted'\n  | 'isAtLiveEdge'\n  | 'isLive'\n  | 'isOnDemand'\n  | 'isDvrEnabled'\n  | 'isFailed'\n  | 'isFullscreen'\n  | 'isUserActive'\n  | 'isUserInactive'\n  | 'volumePrefix';\n\nexport type RecognizedPlayerStateProperties = {\n  isPaused?: boolean,\n  isSeeking?: boolean,\n  isBuffering?: boolean,\n  isMuted?: boolean,\n  volume?: number,\n  isAtLiveEdge?: boolean,\n  playState?: PlayState,\n  playMode?: PlayMode,\n  error?: any,\n  isUserActive?: boolean,\n  isFullscreen?: boolean\n};\n\nconst volumeMappings = ['low', 'medium', 'high'];\n\nconst isStreamOpen = (playState?: PlayState) => playState && playState !== 'inactive' && playState !== 'starting';\n\nconst playerStateClassNameBuilder = (\n  {\n    isPaused,\n    isSeeking,\n    isBuffering,\n    isMuted,\n    volume,\n    isAtLiveEdge,\n    playState,\n    playMode,\n    error,\n    isUserActive,\n    isFullscreen\n  }: RecognizedPlayerStateProperties,\n  classNameDefinitions: { [ClassNameKeys]: string },\n  classNamePrefix?: string,\n  extraClassNames?: Array<string> = []\n): string => {\n  const cd = classNameDefinitions || {};\n  const resultingClassNames = [];\n\n  // Is paused, playing\n  if (isStreamOpen(playState) && isPaused != null) {\n    if (isPaused) {\n      resultingClassNames.push(cd.isPaused);\n    } else {\n      resultingClassNames.push(cd.isPlaying);\n    }\n  }\n  if (isBuffering) {\n    resultingClassNames.push(cd.isBuffering);\n  }\n  if (isSeeking) {\n    resultingClassNames.push(cd.isSeeking);\n  }\n  if (isMuted) {\n    resultingClassNames.push(cd.isMuted);\n  }\n  if (isAtLiveEdge) {\n    resultingClassNames.push(cd.isAtLiveEdge);\n  }\n  if (playState === 'starting') {\n    resultingClassNames.push(cd.isStarting);\n  }\n  if (playMode === 'ondemand') {\n    resultingClassNames.push(cd.isOnDemand);\n  } else if (playMode === 'live') {\n    resultingClassNames.push(cd.isLive);\n  } else if (playMode === 'livedvr') {\n    resultingClassNames.push(cd.isLive);\n    resultingClassNames.push(cd.isDvrEnabled);\n  }\n  if (volume != null && cd.volumePrefix != null) {\n    const i = Math.min(Math.floor(volume * volumeMappings.length), volumeMappings.length - 1);\n    resultingClassNames.push(cd.volumePrefix + volumeMappings[i]);\n  }\n  if (isFullscreen) {\n    resultingClassNames.push(cd.isFullscreen);\n  }\n  if (isUserActive != null) {\n    if (isUserActive) {\n      resultingClassNames.push(cd.isUserActive);\n    } else {\n      resultingClassNames.push(cd.isUserInactive);\n    }\n  }\n  if (error) {\n    resultingClassNames.push(cd.isFailed);\n  }\n  return prefixClassNames(classNamePrefix, ...resultingClassNames.concat(extraClassNames));\n};\n\nexport default playerStateClassNameBuilder;\n","// @flow\nimport * as React from 'react';\nimport type { RecognizedPlayerStateProperties, ClassNameKeys } from './playerStateClassNameBuilder';\nimport playerStateClassNameBuilder from './playerStateClassNameBuilder';\nimport type { CommonGenericProps } from '../../common';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { StreamStateKeysForObservation } from '../PlayerController/ControllerContext';\n\ntype Props = RecognizedPlayerStateProperties &\n  CommonGenericProps & {\n    render: string => React.Node,\n    classNameDefinitions: { [ClassNameKeys]: string },\n    extraClassNames: Array<string>\n  };\n\nclass PlayerStateClassNames extends React.Component<Props> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix,\n    extraClassNames: []\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = [\n    'isPaused',\n    'isSeeking',\n    'isBuffering',\n    'isMuted',\n    'volume',\n    'isAtLiveEdge',\n    'playState',\n    'error',\n    'playMode'\n  ];\n\n  render() {\n    const {\n      render,\n      classNamePrefix,\n      classNameDefinitions,\n      className,\n      extraClassNames,\n      ...playerStateProps\n    } = this.props;\n    return render(\n      playerStateClassNameBuilder(\n        playerStateProps,\n        classNameDefinitions,\n        classNamePrefix,\n        className ? [className, ...extraClassNames] : extraClassNames\n      )\n    );\n  }\n}\n\nexport default PlayerStateClassNames;\n","// @flow\nimport * as React from 'react';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nexport type ResponsiveRange = {\n  className: string,\n  width?: {\n    min?: ?number,\n    max?: ?number\n  },\n  height?: {\n    min?: ?number,\n    max?: ?number\n  }\n};\n\nexport type ResponsiveRanges = Array<ResponsiveRange>;\n\ntype RenderParameters = {\n  onRef: (?HTMLElement) => void,\n  responsiveClassNames: Array<string>\n};\n\ntype Props = {\n  configuration?: {\n    responsivenessRules?: ?ResponsiveRanges\n  },\n  onRef?: (?HTMLElement) => void,\n  render: RenderParameters => React.Node\n};\n\ntype State = {\n  responsiveClassNames: Array<string>\n};\n\nclass ResponsiveClassNames extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      responsiveClassNames: []\n    };\n  }\n\n  resizeObserver: ResizeObserver;\n\n  onRef = (element: ?HTMLElement) => {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    if (\n      element &&\n      this.props.configuration &&\n      Array.isArray(this.props.configuration.responsivenessRules) &&\n      this.props.configuration.responsivenessRules.length > 0\n    ) {\n      if (!this.resizeObserver) {\n        this.resizeObserver = new ResizeObserver(entries => {\n          for (const entry of entries) {\n            this.onSizeChange(entry.contentRect);\n            /*\n            const {left, top, width, height} = entry.contentRect;\n\n            console.log('Element:', entry.target);\n            console.log(`Element's size: ${ width }px x ${ height }px`);\n            console.log(`Element's paddings: ${ top }px ; ${ left }px`);\n            */\n          }\n        });\n        // console.log('ResizeObserver instantiated.', this.resizeObserver);\n      }\n      this.resizeObserver.observe(element);\n    }\n    if (this.props.onRef) {\n      this.props.onRef(element);\n    }\n  };\n\n  onSizeChange = (contentRect: { +width: number, +height: number }) => {\n    const elementWidth = contentRect.width;\n    const elementHeight = contentRect.height;\n    if (\n      elementWidth > 0 &&\n      elementHeight > 0 &&\n      this.props.configuration &&\n      Array.isArray(this.props.configuration.responsivenessRules)\n    ) {\n      const responsiveClassNames = this.props.configuration.responsivenessRules\n        .filter(({ width, height }) => {\n          if (width && ((width.min && elementWidth <= width.min) || (width.max && elementWidth > width.max))) {\n            return false;\n          }\n          if (height && ((height.min && elementHeight <= height.min) || (height.max && elementHeight > height.max))) {\n            return false;\n          }\n          return true;\n        })\n        .map(range => range.className);\n      this.setState({ responsiveClassNames });\n    }\n  };\n\n  render() {\n    return this.props.render({ onRef: this.onRef, responsiveClassNames: this.state.responsiveClassNames });\n  }\n}\n\nexport default ResponsiveClassNames;\n","// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport Fullscreen from '../containment-helpers/Fullscreen';\nimport AspectRatio from '../containment-helpers/AspectRatio';\nimport InteractionDetector from '../containment-helpers/InteractionDetector';\nimport KeyboardShortcuts from '../containment-helpers/KeyboardShortcuts';\nimport type { InteractionDetectorConfiguration } from '../containment-helpers/InteractionDetector';\nimport type { KeyboardShortcutsConfiguration } from '../containment-helpers/KeyboardShortcuts';\nimport PlayerStateClassNames from '../containment-helpers/PlayerStateClassNames';\nimport ResponsiveClassNames from '../containment-helpers/ResponsiveClassNames';\nimport type { ResponsiveRanges } from '../containment-helpers/ResponsiveClassNames';\n\ntype RenderParameters = {\n  fullscreenState: {\n    isFullscreen: boolean,\n    setProperties: ({ isFullscreen: boolean }) => void,\n    enterFullscreen: () => void,\n    exitFullscreen: () => void\n  },\n  interactionState: {\n    nudge: () => void,\n    isUserActive: boolean\n  }\n};\n\ntype AspectRatioConfiguration = {\n  horizontal: number,\n  vertical: number\n};\n\ntype Props = CommonProps & {\n  aspectRatio: AspectRatioConfiguration,\n  configuration?: {\n    interactionDetector?: InteractionDetectorConfiguration,\n    keyboardShortcuts?: KeyboardShortcutsConfiguration,\n    responsivenessRules?: ?ResponsiveRanges,\n    aspectRatio?: ?AspectRatioConfiguration\n  },\n  render: RenderParameters => React.Node,\n  className?: string\n};\n\nconst uiContainerClassName = 'ui-container';\nconst aspectRatioFixClassName = 'aspect-ratio-fix';\n\nconst classNameDefinitions = {\n  responsivenessPrefix: 'player-size-',\n  volumePrefix: 'volume-level-',\n  isFullscreen: 'is-fullscreen',\n  isUserActive: 'is-user-active',\n  isUserInactive: 'is-user-inactive',\n  isBuffering: 'is-buffering',\n  isSeeking: 'is-seeking',\n  isPlaying: 'is-playing',\n  isPaused: 'is-paused',\n  isStarting: 'is-starting',\n  isMuted: 'is-muted',\n  isAtLiveEdge: 'is-at-live-edge',\n  isLive: 'is-live',\n  isOnDemand: 'is-on-demand',\n  isDvrEnabled: 'is-dvr-enabled',\n  isFailed: 'is-failed'\n};\n\n// Make stateClassNames pass an array with all relevant keys, so that a simple mapping can be done.\n// In addition comes dynamically generated class names from responsiveness, and perhaps volume level.\n\nconst noConnect = Component => Component;\n\nexport const getConnectedPlayerUIContainer = (connector: any => React.ComponentType<any> = noConnect) => {\n  const ConnectedPlayerStateClassNames = connector(PlayerStateClassNames);\n  const ConnectedKeyboardShortcuts = connector(KeyboardShortcuts);\n\n  return class PlayerUIContainer extends React.Component<Props> {\n    static defaultProps = {\n      classNamePrefix: defaultClassNamePrefix,\n      className: defaultClassNamePrefix.substr(0, defaultClassNamePrefix.length - 1), // Removing the last dash of the prefix. Dangerous assumption...\n      aspectRatio: {\n        horizontal: 16,\n        vertical: 9\n      }\n    };\n\n    render() {\n      const { classNamePrefix, render, configuration, aspectRatio, className } = this.props;\n      const playerClassName = classNamePrefix ? classNamePrefix.substr(0, classNamePrefix.length - 1) : className;\n      return (\n        <AspectRatio\n          rootClassName={playerClassName}\n          aspectRatio={aspectRatio || (configuration && configuration.aspectRatio)}\n          aspectFixClassName={aspectRatioFixClassName}\n          classNamePrefix={classNamePrefix}\n          render={() => (\n            <Fullscreen\n              render={({ onRef, ...fullscreenState }) => (\n                <InteractionDetector\n                  configuration={configuration}\n                  render={({ handleMouseMove, handleTouchStart, handleTouchEnd, handleFocus, ...interactionState }) => (\n                    <ConnectedKeyboardShortcuts\n                      configuration={configuration}\n                      fullscreenState={fullscreenState}\n                      nudge={interactionState.nudge}\n                      toggleFixedUserActive={interactionState.toggleFixedUserActive}\n                      render={({ handleKeyDown }) => (\n                        <ResponsiveClassNames\n                          onRef={onRef}\n                          configuration={configuration}\n                          render={({ onRef, responsiveClassNames }) => (\n                            <ConnectedPlayerStateClassNames\n                              {...fullscreenState}\n                              {...interactionState}\n                              classNameDefinitions={classNameDefinitions}\n                              classNamePrefix={classNamePrefix}\n                              className={uiContainerClassName}\n                              extraClassNames={responsiveClassNames}\n                              render={classNames => (\n                                <div\n                                  className={classNames}\n                                  tabIndex={0}\n                                  ref={onRef}\n                                  onMouseMove={handleMouseMove}\n                                  onTouchStart={handleTouchStart}\n                                  onTouchEnd={handleTouchEnd}\n                                  onKeyDown={handleKeyDown}\n                                  onFocus={handleFocus}>\n                                  {render({ fullscreenState, interactionState })}\n                                </div>\n                              )}\n                            />\n                          )}\n                        />\n                      )}\n                    />\n                  )}\n                />\n              )}\n            />\n          )}\n        />\n      );\n    }\n  };\n};\n\nconst PlayerUIContainer = getConnectedPlayerUIContainer();\nexport default PlayerUIContainer;\n","// @flow\nimport * as React from 'react';\nimport type { PlaybackProps } from '../VideoStreamer/types';\nimport type { StreamStateKeysForObservation } from '../PlayerController/ControllerContext';\nimport type { UserSettingsConfiguration } from './PreferredSettingsApplicator';\nimport type { PreferredSettings } from '../../../default-player/types';\n\ntype SettingsStorageProps<T: { setProperties?: any => void }> = T & {\n  configuration?: ?UserSettingsConfiguration\n};\n\nconst isEnabled = (configuration: ?UserSettingsConfiguration) => {\n  return (\n    configuration &&\n    configuration.userSettings &&\n    configuration.userSettings.storageKey &&\n    configuration.userSettings.settingsStoragePolicy\n  );\n};\n\nconst getStoredSettings = (storage: Storage, key: string): PreferredSettings => {\n  try {\n    const storedStr = storage.getItem(key);\n    if (storedStr) {\n      return JSON.parse(storedStr);\n    } else {\n      return {};\n    }\n  } catch (e) {\n    return {};\n  }\n};\n\nconst withStorage = (\n  storagePolicy,\n  key: string,\n  sessionSettings: PreferredSettings,\n  localSettings: PreferredSettings,\n  callback: PreferredSettings => any\n) => {\n  switch (storagePolicy[key]) {\n    case 'local':\n      callback(localSettings);\n      return;\n    case 'session':\n      callback(sessionSettings);\n      return;\n    default:\n      return;\n  }\n};\n\nconst withSettingsStorage = <P: { setProperties?: any => void }>(\n  Component: React.ComponentType<P>,\n  localStorage: Storage = window.localStorage,\n  sessionStorage: Storage = window.sessionStorage\n) => {\n  class SettingsStorage extends React.Component<SettingsStorageProps<P>> {\n    // $FlowFixMe What's the best practices for extending component types with static properties?\n    static streamStateKeysForObservation: StreamStateKeysForObservation = Component.streamStateKeysForObservation;\n\n    setProperties = (userSetProps: PlaybackProps) => {\n      if (this.props.setProperties) {\n        this.props.setProperties(userSetProps);\n      }\n      const userSettingsConfig = this.props.configuration && this.props.configuration.userSettings;\n      if (userSettingsConfig) {\n        const storageKey = userSettingsConfig.storageKey;\n        const storagePolicy = userSettingsConfig.settingsStoragePolicy;\n        if (storageKey && storagePolicy) {\n          const localSettings = getStoredSettings(localStorage, storageKey);\n          const sessionSettings = getStoredSettings(sessionStorage, storageKey);\n          if ('isMuted' in userSetProps) {\n            withStorage(\n              storagePolicy,\n              'isMuted',\n              sessionSettings,\n              localSettings,\n              settings => (settings.isMuted = !!userSetProps.isMuted)\n            );\n          }\n          if (typeof userSetProps.volume === 'number') {\n            withStorage(\n              storagePolicy,\n              'volume',\n              sessionSettings,\n              localSettings,\n              settings => (settings.volume = userSetProps.volume)\n            );\n          }\n          if ('selectedTextTrack' in userSetProps) {\n            withStorage(storagePolicy, 'textTrackLanguage', sessionSettings, localSettings, settings => {\n              if (userSetProps.selectedTextTrack) {\n                if (userSetProps.selectedTextTrack.language) {\n                  settings.textTrackLanguage = userSetProps.selectedTextTrack.language;\n                }\n              } else {\n                // Subtitles were turned off.\n                delete settings.textTrackLanguage;\n              }\n            });\n            withStorage(storagePolicy, 'textTrackKind', sessionSettings, localSettings, settings => {\n              if (userSetProps.selectedTextTrack) {\n                if (userSetProps.selectedTextTrack.kind) {\n                  settings.textTrackKind = userSetProps.selectedTextTrack.kind;\n                }\n              } else {\n                // Subtitles were turned off.\n                delete settings.textTrackKind;\n              }\n            });\n          }\n          if ('selectedAudioTrack' in userSetProps) {\n            withStorage(storagePolicy, 'audioTrackLanguage', sessionSettings, localSettings, settings => {\n              if (userSetProps.selectedAudioTrack && userSetProps.selectedAudioTrack.language) {\n                settings.audioTrackLanguage = userSetProps.selectedAudioTrack.language;\n              }\n            });\n            withStorage(storagePolicy, 'audioTrackKind', sessionSettings, localSettings, settings => {\n              if (userSetProps.selectedAudioTrack && userSetProps.selectedAudioTrack.kind) {\n                settings.audioTrackKind = userSetProps.selectedAudioTrack.kind;\n              }\n            });\n          }\n          if (Object.keys(localSettings).length > 0) {\n            try {\n              localStorage.setItem(storageKey, JSON.stringify(localSettings));\n            } catch (e) {}\n          }\n          if (Object.keys(sessionSettings).length > 0) {\n            try {\n              sessionStorage.setItem(storageKey, JSON.stringify(sessionSettings));\n            } catch (e) {}\n          }\n        }\n      }\n    };\n\n    render() {\n      const { configuration, ...remainder } = this.props;\n      if (isEnabled(this.props.configuration)) {\n        return <Component {...remainder} setProperties={this.setProperties} />;\n      } else {\n        return <Component {...remainder} />;\n      }\n    }\n  }\n  SettingsStorage.displayName = 'SettingsStorage' + (Component.displayName || Component.name);\n  return SettingsStorage;\n};\n\nexport default withSettingsStorage;\n","// @flow\n\nimport { getConnectedPlayerUIContainer } from '../PlayerUIContainer/PlayerUIContainer';\nimport UnconnectedSkipButton from '../../controls/SkipButton/SkipButton';\nimport UnconnectedTimeDisplay from '../../controls/TimeDisplay/TimeDisplay';\nimport UnconnectedQualitySelector from '../../controls/QualitySelector/QualitySelector';\nimport UnconnectedBufferingIndicator from '../../controls/BufferingIndicator/BufferingIndicator';\nimport connectControl from './connectControl';\nimport UnconnectedAudioSelector from '../../controls/AudioSelector/AudioSelector';\nimport UnconnectedPlayPauseButton from '../../controls/PlayPauseButton/PlayPauseButton';\nimport UnconnectedSubtitlesSelector from '../../controls/SubtitlesSelector/SubtitlesSelector';\nimport UnconnectedVolume from '../../controls/Volume/Volume';\nimport UnconnectedGotoLiveButton from '../../controls/GotoLiveButton/GotoLiveButton';\nimport UnconnectedTimeline from '../../controls/Timeline/Timeline';\nimport UnconnectedPipButton from '../../controls/PipButton/PipButton';\nimport UnconnectedAirPlayButton from '../../controls/AirPlayButton/AirPlayButton';\nimport UnconnectedTimelineInformation from '../../controls/TimelineInformation/TimelineInformation';\nimport withSettingsStorage from '../settings-helpers/settingsStorage';\n\nexport const PlayerUIContainer = getConnectedPlayerUIContainer(connectControl);\nexport const PlayPauseButton = connectControl(UnconnectedPlayPauseButton);\nexport const SkipButton = connectControl(UnconnectedSkipButton);\nexport const Timeline = connectControl(UnconnectedTimeline);\nexport const TimeDisplay = connectControl(UnconnectedTimeDisplay);\nexport const TimelineInformation = connectControl(UnconnectedTimelineInformation);\nexport const GotoLiveButton = connectControl(UnconnectedGotoLiveButton);\nexport const PipButton = connectControl(UnconnectedPipButton);\nexport const AirPlayButton = connectControl(UnconnectedAirPlayButton);\nexport const Volume = connectControl(UnconnectedVolume);\nexport const AudioSelector = connectControl(UnconnectedAudioSelector);\nexport const SubtitlesSelector = connectControl(UnconnectedSubtitlesSelector);\nexport const QualitySelector = connectControl(UnconnectedQualitySelector);\nexport const BufferingIndicator = connectControl(UnconnectedBufferingIndicator);\nexport const SettingsStorage = {\n  AudioSelector: connectControl(withSettingsStorage(UnconnectedAudioSelector)),\n  SubtitlesSelector: connectControl(withSettingsStorage(UnconnectedSubtitlesSelector)),\n  Volume: connectControl(withSettingsStorage(UnconnectedVolume))\n};\n","// @flow\nimport type { PlayMode } from '../types';\nimport type { StreamRangeHelper } from '../common/types';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\nconst dvrStartCorrection = 10; // yep, seconds\n\nfunction getSeekableNetRange(videoElement: HTMLVideoElement): number {\n  return videoElement.seekable.length > 0 ? videoElement.seekable.end(0) - videoElement.seekable.start(0) : 0;\n}\n\nfunction getPosition(videoElement: HTMLVideoElement): number {\n  return videoElement.currentTime - (videoElement.seekable.length > 0 ? videoElement.seekable.start(0) : 0);\n}\n\nfunction getDuration(videoElement: HTMLVideoElement, isLive: boolean, seekableRange: number): number {\n  return isLive ? seekableRange : videoElement.duration;\n}\n\nfunction getStartOffset(videoElement: HTMLVideoElement) {\n  return videoElement.seekable.length > 0 ? videoElement.seekable.start(0) : 0;\n}\n\nfunction resolvePlayMode(videoElement: HTMLVideoElement, seekableRange: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (seekableRange === Infinity || seekableRange === 0 || seekableRange < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  videoElement: HTMLVideoElement,\n  isLive: boolean,\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (isLive) {\n    // $FlowFixMe getStartDate() is Safari only and not part of the DOM standard API.\n    const startDate: Date = videoElement.getStartDate && videoElement.getStartDate();\n    if (isNaN(startDate)) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: new Date(startDate.getTime() + videoElement.currentTime * 1000),\n        absoluteStartPosition: new Date(startDate.getTime() + getStartOffset(videoElement) * 1000)\n      };\n    }\n  } else {\n    return {\n      absolutePosition: dawnOfTime,\n      absoluteStartPosition: dawnOfTime\n    };\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  configuration: ?{ liveEdgeMargin: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n\n  function calculateNewState() {\n    const seekableRange = getSeekableNetRange(videoElement);\n    const isLive = videoElement.duration === Infinity;\n\n    const position = getPosition(videoElement);\n    const duration = getDuration(videoElement, isLive, seekableRange);\n    const playMode = resolvePlayMode(videoElement, seekableRange, isLive);\n    const isAtLiveEdge = isLive && position > duration - liveMargin;\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(videoElement, isLive, position);\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    if (videoElement && videoElement.paused && videoElement.duration === Infinity) {\n      const seekableStart = getStartOffset(videoElement);\n      if (seekableStart !== Infinity && seekableStart >= videoElement.currentTime) {\n        videoElement.currentTime = seekableStart + dvrStartCorrection;\n      }\n    }\n  }\n\n  function setPosition(newPosition: number) {\n    if (!(isNaN(newPosition) && newPosition === Infinity)) {\n      videoElement.currentTime = getStartOffset(videoElement) + newPosition;\n    }\n  }\n\n  function gotoLive() {\n    if (videoElement.duration === Infinity && videoElement.seekable.length > 0) {\n      videoElement.currentTime = videoElement.seekable.end(0);\n    }\n  }\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\n\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { TextTrackManager, TrackElementData } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\n\nexport type ManagedTextTrack = {\n  isBlacklisted: boolean,\n  sourceTrack: ?SourceTrack,\n  videoElementTrack?: ?TextTrack,\n  selectableTrack: ?AvailableTrack,\n  trackElementData?: ?TrackElementData,\n  loadPromise?: Promise<?TextTrack>,\n  isLoaded: boolean,\n  error?: any\n};\n\ntype HTMLTextTrackMode = 'disabled' | 'hidden' | 'showing';\n\n/*export type TextTracksStateProps = {\n  currentTextTrack?: ?AvailableTrack,\n  textTracks?: Array<AvailableTrack>\n};*/\n\nconst trackModeMappings = ['disabled', 'hidden', 'showing']; // Index corresponds with \"enum\" value.\n\nfunction getTrackMode(textTrack: TextTrack) {\n  const mode = textTrack.mode;\n  return typeof mode === 'number' ? trackModeMappings[mode] : mode;\n}\n\nfunction setTrackMode(textTrack: TextTrack, newMode: HTMLTextTrackMode) {\n  // $FlowFixMe Some browsers use numbers mapping to modes.\n  textTrack.mode = typeof textTrack.mode === 'number' ? trackModeMappings.indexOf(newMode) : newMode;\n}\n\nfunction isEqual(a: any, b: any): boolean {\n  return (Number.isNaN(a) && Number.isNaN(b)) || (a == null && b == null) || a === b;\n}\n\nfunction isVideoElementTrackValid(textTrack: TextTrack) {\n  // Detecting empty dummy tracks originating from HLS streams in Safari.\n  return (\n    (textTrack.kind !== 'metadata' && !('inBandMetadataTrackDispatchType' in textTrack)) ||\n    (textTrack.cues && textTrack.cues.length) ||\n    textTrack.label ||\n    textTrack.language\n  );\n}\n\nfunction isSourceTracksEqual(a: ?SourceTrack, b: ?SourceTrack): boolean {\n  if (a && b) {\n    if (a.cues && b.cues) {\n      const ac = a.cues,\n        bc = b.cues;\n      if (ac.length === bc.length) {\n        const isCuesDifferent =\n          ac.filter(\n            (cue, index) =>\n              cue.start === bc[index].start && cue.end === bc[index].end && cue.content === bc[index].content\n          ).length !== ac.length;\n        if (isCuesDifferent) {\n          return false;\n        }\n      }\n    }\n    return (\n      isEqual(a.language, b.language) && isEqual(a.kind, b.kind) && isEqual(a.label, b.label) && isEqual(a.src, b.src)\n    );\n  } else {\n    return isEqual(a, b);\n  }\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  videoElementTrack: TextTrack\n): AvailableTrack {\n  return {\n    id,\n    kind: videoElementTrack.kind || '',\n    label: videoElementTrack.label || '',\n    language: videoElementTrack.language || '',\n    origin\n  };\n}\n\nconst getTextTrackManager = (\n  videoElement: HTMLVideoElement,\n  update: <T: VideoStreamState>(props: T) => void,\n  updateTrackElementData: (Array<TrackElementData>) => void\n): TextTrackManager => {\n  // Should use TextTracksStateProps above.\n  let managedTracks: Array<ManagedTextTrack> = [];\n  let currentTextTrack = null;\n  let selectableTextTracks = emptyTracks;\n  let unique = 0;\n  const Cue = window.VTTCue || window.TextTrackCue;\n\n  function notifyPropertyChanges() {\n    currentTextTrack = managedTracks\n      .filter(m => m.videoElementTrack != null && getTrackMode(m.videoElementTrack) === 'showing')\n      .map(m => m.selectableTrack)[0];\n\n    const textTracks = managedTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n    if (isShallowEqual(textTracks, selectableTextTracks)) {\n      // $FlowFixMe Complaints about null entries, despite filter above.\n      update({\n        currentTextTrack,\n        textTracks: selectableTextTracks\n      });\n    } else {\n      selectableTextTracks = textTracks;\n      update({\n        currentTextTrack,\n        textTracks\n      });\n    }\n  }\n\n  function addTracks(sourceTracks?: Array<SourceTrack>) {\n    if (Array.isArray(sourceTracks)) {\n      videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n      videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n\n      const freshSourceTracks = sourceTracks.filter(sourceTrack => {\n        const managedTrackMatches = managedTracks.filter(managedTrack => {\n          return isSourceTracksEqual(managedTrack.sourceTrack, sourceTrack) && !managedTrack.isBlacklisted;\n        });\n        if (managedTrackMatches.length === 0) {\n          return true;\n        } else {\n          const alreadyAddedTrack = managedTrackMatches[0];\n          alreadyAddedTrack.sourceTrack = sourceTrack;\n          alreadyAddedTrack.isBlacklisted = false;\n          alreadyAddedTrack.isLoaded = true; // Is this assumption correct?\n          return false;\n        }\n      });\n\n      const freshManagedTracks: Array<ManagedTextTrack> = freshSourceTracks.map(sourceTrack => {\n        const id = ++unique;\n        if (Array.isArray(sourceTrack.cues)) {\n          const cues = sourceTrack.cues;\n          const videoElementTrack = videoElement.addTextTrack(\n            sourceTrack.kind || 'subtitles',\n            sourceTrack.label,\n            sourceTrack.language\n          );\n          cues.forEach(cue => {\n            videoElementTrack.addCue(new Cue(cue.start, cue.end, cue.content));\n          });\n          return {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack,\n            selectableTrack: createSelectableTrack(id, 'side-loaded', videoElementTrack),\n            loadPromise: Promise.resolve(videoElementTrack),\n            isLoaded: true\n          };\n        } else {\n          const trackElementData: TrackElementData = {\n            src: sourceTrack.src,\n            srclang: sourceTrack.language,\n            kind: sourceTrack.kind || 'subtitles',\n            label: sourceTrack.label\n          };\n          const loadPromise = new Promise(resolve => {\n            trackElementData.onRef = (trackElement: ?HTMLTrackElement) => {\n              const t = trackElement;\n              if (t) {\n                setTrackMode(t.track, 'hidden');\n                const handleLoad = () => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve(t.track);\n                };\n                const handleError = (e: Event) => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve();\n                };\n                t.addEventListener('load', handleLoad);\n                t.addEventListener('error', handleError);\n              }\n            };\n          });\n          const managedTrack = {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack: undefined,\n            selectableTrack: undefined,\n            trackElementData,\n            loadPromise,\n            isLoaded: false\n          };\n          loadPromise.then(videoElementTrack => {\n            if (videoElementTrack != null) {\n              managedTrack.videoElementTrack = videoElementTrack;\n              managedTrack.selectableTrack = createSelectableTrack(id, 'side-loaded', videoElementTrack);\n            }\n            managedTrack.isLoaded = true;\n          });\n          return managedTrack;\n        }\n      });\n\n      managedTracks = managedTracks.concat(freshManagedTracks);\n\n      updateTrackElementData(\n        // $FlowFixMe Filtering away null/undefined isn't recognised.\n        managedTracks.filter(t => t.trackElementData && !t.isBlacklisted).map(t => t.trackElementData)\n      );\n\n      return Promise.all(freshManagedTracks.map(managedTrack => managedTrack.loadPromise)).then(() => {\n        videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n        videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n        notifyPropertyChanges();\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function updateFromVideoElement(textTracksList: TextTrackList) {\n    if (textTracksList.length === 0 && managedTracks.length === 0) {\n      return;\n    }\n\n    const videoElementTracks: Array<TextTrack> = [];\n    for (let i = 0; i < textTracksList.length; i++) {\n      // Awkward for-loop because Flow doesn't understand Array.from().\n      videoElementTracks.push(textTracksList[i]);\n    }\n\n    const cleanedUpManagedTracks = managedTracks.filter(managedTrack => {\n      return videoElementTracks.indexOf(managedTrack.videoElementTrack) >= 0;\n    });\n\n    //const isRemoving = cleanedUpManagedTracks.length < managedTracks.length;\n    //const isAdding = videoElementTracks.length > cleanedUpManagedTracks.length;\n\n    if (videoElementTracks.length > cleanedUpManagedTracks.length) {\n      const freshVideoElementTracks = videoElementTracks.filter(\n        videoElementTrack =>\n          isVideoElementTrackValid(videoElementTrack) &&\n          cleanedUpManagedTracks.filter(function(managedTrack) {\n            return videoElementTrack === managedTrack.videoElementTrack;\n          }).length === 0\n      );\n      const freshManagedTracks: Array<ManagedTextTrack> = freshVideoElementTracks.map(videoElementTrack => {\n        const id = ++unique;\n        return {\n          id,\n          sourceTrack: null,\n          videoElementTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(id, 'in-stream', videoElementTrack),\n          isLoaded: true\n        };\n      });\n      managedTracks = cleanedUpManagedTracks.concat(freshManagedTracks);\n    } else {\n      managedTracks = cleanedUpManagedTracks;\n    }\n  }\n\n  function cleanupTracks(isNewSession: boolean) {\n    updateFromVideoElement(videoElement.textTracks);\n    managedTracks.forEach(m => {\n      // Blacklisting and removing side-loaded tracks.\n      if (isNewSession || m.sourceTrack != null) {\n        m.isBlacklisted = true;\n      }\n      if (m.videoElementTrack != null && isNewSession) {\n        const vt = m.videoElementTrack;\n        if (vt.cues) {\n          while (vt.cues.length) {\n            vt.removeCue(vt.cues[0]);\n          }\n        }\n        setTrackMode(vt, 'disabled');\n      }\n      m.selectableTrack = null;\n    });\n    selectableTextTracks = emptyTracks;\n    updateTrackElementData([]);\n  }\n\n  function handleSourcePropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    updateFromVideoElement(videoElement.textTracks);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    const source = normalizeSource(newProps.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    cleanupTracks(false);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    cleanupTracks(true);\n  }\n\n  function handleSelectedTextTrackChange(selectedTextTrack: ?AvailableTrack) {\n    managedTracks\n      .filter(mt => mt.videoElementTrack && getTrackMode(mt.videoElementTrack) === 'showing')\n      .forEach(mt => mt.videoElementTrack && setTrackMode(mt.videoElementTrack, 'hidden'));\n    if (selectedTextTrack) {\n      const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedTextTrack)[0];\n      if (managedTrack && managedTrack.videoElementTrack) {\n        setTrackMode(managedTrack.videoElementTrack, 'showing');\n      }\n    }\n    notifyPropertyChanges();\n  }\n\n  function handleTrackAdd() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function handleTrackRemove() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function cleanup() {\n    videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n  }\n\n  function initialize() {\n    videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n  }\n\n  initialize();\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n};\n\nexport default getTextTrackManager;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { AudioTrackManager } from '../common/types';\n\n// http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\n/*export type AudioTracksStateProps = {\n  audioTracks?: Array<AvailableTrack>,\n  currentAudioTrack?: ?AvailableTrack\n};*/\n\ntype ManagedAudioTrack = {\n  videoElementTrack: AudioTrack,\n  selectableTrack: AvailableTrack\n};\n\nlet id = 0;\n\nconst createManagedTrack = (videoElementTrack: AudioTrack): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: videoElementTrack.id == null ? `audio-${++id}` : videoElementTrack.id,\n      language: videoElementTrack.language || '',\n      kind: videoElementTrack.kind || '',\n      label: videoElementTrack.label || '',\n      origin: 'in-stream'\n    },\n    videoElementTrack\n  };\n};\n\nconst getAudioTrackManager = (videoElement: HTMLVideoElement, update: VideoStreamState => void): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function mapAudioTracks() {\n    // $FlowFixMe Array.from() doesn't seem to understand iterables from the DOM API.\n    managedTracks = videoElement.audioTracks ? Array.from(videoElement.audioTracks).map(createManagedTrack) : [];\n  }\n\n  function updateStreamStateProps(selectedTrack?: ?AvailableTrack) {\n    const currentAudioTrack =\n      selectedTrack ||\n      managedTracks.filter(mt => mt.videoElementTrack.enabled).map(mt => mt.selectableTrack)[0] ||\n      null;\n    // TODO: Don't create a new array with new items every time. A deep equal comparison on availableTracks is needed.\n    update({ audioTracks: managedTracks.map(mt => mt.selectableTrack), currentAudioTrack });\n  }\n\n  function handleTrackAddOrRemove() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    updateStreamStateProps();\n  }\n\n  function setup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.addEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.addEventListener('change', handleTrackChange);\n      videoElement.audioTracks.addEventListener('removetrack', handleTrackAddOrRemove);\n    }\n    handleSourceChange();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      managedTrack.videoElementTrack.enabled = true;\n    }\n  }\n\n  function cleanup() {\n    if (videoElement.audioTracks) {\n      videoElement.audioTracks.removeEventListener('addtrack', handleTrackAddOrRemove);\n      videoElement.audioTracks.removeEventListener('change', handleTrackChange);\n      videoElement.audioTracks.removeEventListener('removetrack', handleTrackAddOrRemove);\n    }\n    managedTracks = [];\n  }\n\n  function handleSourceChange() {\n    handleTrackAddOrRemove();\n  }\n\n  setup();\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getAudioTrackManager;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport getStreamRangeHelper from './streamRangeHelper';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport getTextTrackManager from './textTrackManager';\nimport getAudioTrackManager from './audioTrackManager';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts, TrackElementData } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport getBasicVideoEventHandlers from './basicVideoEventHandlers';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getSourceChangeHandler from './sourceChangeHandler';\n\ntype BasicVideoStreamerProps = VideoStreamerImplProps<VideoStreamerConfiguration>;\ntype ThirdPartyPlayer = null;\n\nexport function getImplementationResolver(\n  sourceChangeHandlerFactory: (\n    videoElement: HTMLVideoElement\n  ) => (BasicVideoStreamerProps, ?BasicVideoStreamerProps) => Promise<any>\n) {\n  return function resolveImplementation(\n    streamer: SimplifiedVideoStreamer<VideoStreamerConfiguration, BasicVideoStreamerProps>,\n    configuration: ?VideoStreamerConfiguration,\n    videoElement: HTMLVideoElement,\n    onTrackElementDataChange: (Array<TrackElementData>) => void\n  ): Promise<StreamerImplementationParts<VideoStreamerConfiguration, BasicVideoStreamerProps, ThirdPartyPlayer>> {\n    const streamRangeHelper = getStreamRangeHelper(videoElement, configuration); // S\n    const handleSourceChange = sourceChangeHandlerFactory(videoElement);\n\n    const updateStreamState = getFilteredStreamStateUpdater(streamer); // G\n\n    const textTrackManager = getTextTrackManager(videoElement, updateStreamState, onTrackElementDataChange);\n    const audioTrackManager = getAudioTrackManager(videoElement, updateStreamState);\n\n    const applyProperties = getPropertyApplier(videoElement, streamRangeHelper, textTrackManager, audioTrackManager); // G\n    const { log } = getArrayLogger(window, 'videoEvents');\n\n    const basicHandlers = getBasicVideoEventHandlers({\n      streamer,\n      videoElement,\n      streamRangeHelper,\n      configuration,\n      applyProperties,\n      updateStreamState,\n      log\n    });\n    const { videoElementEventHandlers, setLifeCycleManager } = basicHandlers;\n\n    const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n      updateStreamState,\n      basicHandlers.pauseStreamRangeUpdater,\n      getArrayLogger(window, 'lifecycle').log\n    );\n    setLifeCycleManager(playbackLifeCycleManager);\n\n    function cleanup() {\n      textTrackManager.cleanup();\n      audioTrackManager.cleanup();\n      playbackLifeCycleManager.cleanup();\n      basicHandlers.cleanup();\n      return Promise.resolve();\n    }\n\n    const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n    const render = renderWithoutSource;\n\n    return Promise.resolve({\n      cleanup,\n      render,\n      textTrackManager,\n      audioTrackManager,\n      applyProperties,\n      handleSourceChange,\n      startPlaybackSession,\n      endPlaybackSession,\n      videoElementEventHandlers\n    });\n  };\n}\n\nconst BasicVideoStreamer = createVideoStreamerComponent(\n  'BasicVideoStreamer',\n  getImplementationResolver(getSourceChangeHandler)\n);\n\nexport default BasicVideoStreamer;\n","// @flow\n\nimport { PlaybackError, type ErrorCode } from '../types';\n\nconst videoErrorCodes = [\n  '(unknown)', // 0\n  'MEDIA_ERR_ABORTED', // 1\n  'MEDIA_ERR_NETWORK', // 2\n  'MEDIA_ERR_DECODE', // 3\n  'MEDIA_ERR_SRC_NOT_SUPPORTED', // 4\n  'MEDIA_ERR_ENCRYPTED' // 5 - Edge only?\n];\n\nconst mapError = (videoElement: HTMLVideoElement): PlaybackError => {\n  const isDesktopSafari = navigator.userAgent.match(/Mac OS X.*Safari/) && !navigator.userAgent.match(/(Chrome)/);\n  const isIos = navigator.userAgent.match(/(iPad|iPhone|iPod)/i);\n\n  let errorCode: ErrorCode = 'STREAM_ERROR';\n  const sourceError = videoElement.error || new Error('Unknown video element error.');\n  const sourceErrorCode = typeof sourceError.code === 'number' ? videoErrorCodes[sourceError.code] : videoErrorCodes[0];\n  if (sourceErrorCode === 'MEDIA_ERR_DECODE' || sourceErrorCode === 'MEDIA_ERR_SRC_NOT_SUPPORTED') {\n    if (isIos || isDesktopSafari) {\n      // MEDIA_ERR_DECODE Observed on 404s on HLS fragments, and MEDIA_ERR_SRC_NOT_SUPPORTED observed on non-OK m3u8 requests.\n      // Both should map to STREAM_ERROR_DOWNLOAD\n      errorCode = 'STREAM_ERROR_DOWNLOAD';\n    } else {\n      // Otherwise, actual decode problem? \"MEDIA_ERR_SRC_NOT_SUPPORTED\" also could be considered a decode problem.\n      errorCode = 'STREAM_ERROR_DECODE';\n    }\n  } else if (sourceErrorCode === 'MEDIA_ERR_NETWORK') {\n    errorCode = 'STREAM_ERROR_DOWNLOAD';\n  }\n  return new PlaybackError(errorCode, 'html', `${sourceErrorCode}: ${sourceError.message || ''}`, 'FATAL', sourceError);\n};\n\nexport default mapError;\n","// @flow\nimport mapError from './errorMapper';\nimport type { InitialPlaybackProps, PlaybackProps, PlaybackSource, VideoStreamState } from '../types';\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport { PlaybackError } from '../types';\nimport { getIntervalRunner } from '../../../common';\nimport normalizeSource from '../common/sourceNormalizer';\n\nconst defaultPauseUpdateInterval = 5;\n\nfunction seekToInitialPosition(source: ?PlaybackSource, videoElement: HTMLVideoElement) {\n  const normalizedSource = normalizeSource(source);\n  if (normalizedSource && typeof normalizedSource.startPosition === 'number') {\n    videoElement.currentTime = normalizedSource.startPosition;\n  }\n}\n\nfunction calculateBufferedAhead(videoElement: HTMLVideoElement): number {\n  const currentTime = videoElement.currentTime;\n  const buffered = videoElement.buffered;\n  let ahead = 0;\n\n  for (let i = 0; i < buffered.length; ++i) {\n    if (buffered.start(i) - 2 <= currentTime && buffered.end(i) + 2 >= currentTime) {\n      ahead = buffered.end(i) - currentTime;\n      break;\n    }\n  }\n  return ahead;\n}\n\nexport type BasicVideoEventHandlersProps = {\n  onPlaybackError?: PlaybackError => void,\n  initialPlaybackProps?: InitialPlaybackProps,\n  source?: ?PlaybackSource\n};\n\nconst getBasicVideoEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const isSafariOrEdge =\n    navigator.userAgent.indexOf('Edge') > 0 ||\n    (navigator.userAgent.indexOf('Safari') > 0 &&\n      navigator.userAgent.indexOf('Chrome') < 0 &&\n      navigator.userAgent.indexOf('Firefox') < 0);\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  function isPipAvailable() {\n    return (\n      // $FlowFixMe: Too exotic for React's HTML element typedefs.\n      (document.pictureInPictureEnabled && !videoElement.disablePictureInPicture) || // $FlowFixMe\n      (videoElement.webkitSupportsPresentationMode &&\n      videoElement.webkitSupportsPresentationMode('picture-in-picture') && // $FlowFixMe\n        typeof videoElement.webkitSetPresentationMode === 'function') ||\n      false\n    );\n  }\n\n  function onError() {\n    const playbackError = mapError(videoElement);\n    if (streamer.props.onPlaybackError) {\n      streamer.props.onPlaybackError(playbackError);\n    }\n    updateStreamState({ error: videoElement.error });\n    if (playbackError.severity === 'FATAL') {\n      lifeCycleManager.setStage('dead');\n      updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function onLoadStart() {\n    log && log('loadstart');\n    if (lifeCycleManager.getStage() === 'new') {\n      lifeCycleManager.setStage('starting');\n      if (streamer.props.initialPlaybackProps) {\n        const { isMuted, volume, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        applyProperties({ isMuted, volume, bitrateFix: bitrateFix, bitrateCap: bitrateCap });\n      }\n      updateStreamState({\n        playState: 'starting',\n        isBuffering: true,\n        volume: videoElement.volume,\n        isMuted: videoElement.muted\n      });\n    }\n  }\n\n  function onLoadedMetadata() {\n    log && log('loadedmetadata');\n    if (streamer.props.initialPlaybackProps && streamer.props.initialPlaybackProps.isPaused) {\n      videoElement.pause();\n    }\n    seekToInitialPosition(streamer.props.source, videoElement);\n    updateStreamState(streamRangeHelper.calculateNewState());\n    updateStreamState({\n      isPipAvailable: isPipAvailable()\n    });\n  }\n\n  function onCanPlay() {\n    log && log('canplay');\n    // If starting as paused, we consider \"canplay\" as completed starting. The playState must be updated accordingly.\n    // When starting as playing, the starting to started transition is handled by the onPlaying handler.\n    const stage = lifeCycleManager.getStage();\n    if (stage === 'starting') {\n      if (streamer.props.initialPlaybackProps && streamer.props.initialPlaybackProps.isPaused) {\n        lifeCycleManager.setStage('started');\n      }\n    } else if (stage === 'started') {\n      updateStreamState({ isBuffering: false, playState: videoElement.paused ? 'paused' : 'playing' });\n    }\n    updateStreamState({\n      bufferedAhead: calculateBufferedAhead(videoElement),\n      isPipAvailable: isPipAvailable()\n    });\n\n    if (videoElement.paused) {\n      updateStreamState({ playState: 'paused', isPaused: true, isBuffering: false, isSeeking: false });\n      pauseStreamRangeUpdater.start();\n    }\n  }\n\n  function onWaiting() {\n    log && log('waiting');\n    updateStreamState({ isBuffering: true });\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'buffering' });\n    }\n  }\n\n  function onStalled() {\n    log && log('stalled');\n    // The stalled event is fired also after pausing in Safari.\n    if (!isSafariOrEdge) {\n      updateStreamState({ isBuffering: true });\n      if (lifeCycleManager.getStage() === 'started') {\n        updateStreamState({ playState: 'buffering' });\n      }\n    }\n  }\n\n  function onPlaying() {\n    log && log('playing');\n    // When this is invoked, and we are not starting as paused, we consider the playback as started.\n    if (lifeCycleManager.getStage() === 'starting') {\n      lifeCycleManager.setStage('started');\n    }\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'playing', isBuffering: false, isPaused: false, isSeeking: false });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function onPause() {\n    log && log('pause');\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'paused', isPaused: true });\n    }\n    pauseStreamRangeUpdater.start();\n  }\n\n  function onSeeking() {\n    log && log('seeking');\n    pauseStreamRangeUpdater.stop();\n    if (lifeCycleManager.getStage() === 'started') {\n      updateStreamState({ playState: 'seeking', isSeeking: true });\n    }\n  }\n\n  function onSeeked() {\n    log && log('seeked');\n    if (isSafariOrEdge) {\n      if (videoElement.paused) {\n        updateStreamState({ playState: 'paused', isPaused: true, isBuffering: false, isSeeking: false });\n        pauseStreamRangeUpdater.start();\n      } else {\n        updateStreamState({ playState: 'playing', isPaused: false, isBuffering: false, isSeeking: false });\n        pauseStreamRangeUpdater.stop();\n      }\n    }\n  }\n\n  function onDurationChange() {\n    log && log('durationchange');\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function onTimeUpdate() {\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function onVolumeChange() {\n    log && log('volumechange');\n    updateStreamState({ volume: videoElement.volume, isMuted: videoElement.muted });\n  }\n\n  function onProgress() {\n    updateStreamState({ bufferedAhead: calculateBufferedAhead(videoElement) });\n  }\n\n  function onEnded() {\n    log && log('ended');\n    if (lifeCycleManager.getStage() === 'started') {\n      //lifeCycleManager.setStage('ended');\n      updateStreamState({ playState: 'inactive' });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function handleEnterPictureInPicture() {\n    updateStreamState({ isPipActive: true });\n  }\n\n  function handleLeavePictureInPicture() {\n    updateStreamState({ isPipActive: false });\n  }\n\n  // START Ugly Safari custom events and properties section\n\n  function handlePlaybackTargetAvailabilityChanged(evt: { availability: 'available' | 'not-available' }) {\n    if (evt.availability === 'available') {\n      updateStreamState({ isAirPlayAvailable: true });\n    } else {\n      updateStreamState({ isAirPlayAvailable: false });\n    }\n  }\n\n  function handleCurrentPlaybackTargetIsWirelessChanged(evt) {\n    // We don't know the current state, and need to guess based on a toggle.\n    // $FlowFixMe: Typedefs not up-to-date.\n    updateStreamState({ isAirPlayActive: videoElement.webkitCurrentPlaybackTargetIsWireless });\n  }\n\n  function handlePresentationModeChanged() {\n    // $FlowFixMe: Too exotic for Safari typedefs.\n    if (videoElement.webkitPresentationMode === 'picture-in-picture') {\n      updateStreamState({ isPipActive: true });\n    } else {\n      updateStreamState({ isPipActive: false });\n    }\n  }\n\n  // END Ugly Safari custom events and properties section\n\n  function onPauseInterval() {\n    streamRangeHelper.adjustForDvrStartOffset();\n    updateStreamState(streamRangeHelper.calculateNewState());\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n  }\n\n  const pauseStreamRangeUpdater = getIntervalRunner(\n    onPauseInterval,\n    (configuration && configuration.pauseUpdateInterval) || defaultPauseUpdateInterval\n  );\n\n  videoElement.addEventListener('enterpictureinpicture', handleEnterPictureInPicture);\n  videoElement.addEventListener('leavepictureinpicture', handleLeavePictureInPicture);\n  videoElement.addEventListener(\n    'webkitcurrentplaybacktargetiswirelesschanged',\n    handleCurrentPlaybackTargetIsWirelessChanged\n  );\n  // $FlowFixMe: evt.availability is unknown to React.\n  videoElement.addEventListener('webkitplaybacktargetavailabilitychanged', handlePlaybackTargetAvailabilityChanged);\n  videoElement.addEventListener('webkitpresentationmodechanged', handlePresentationModeChanged);\n\n  function cleanup() {\n    videoElement.removeEventListener('enterpictureinpicture', handleEnterPictureInPicture);\n    videoElement.removeEventListener('leavepictureinpicture', handleLeavePictureInPicture);\n    videoElement.removeEventListener(\n      'webkitcurrentplaybacktargetiswirelesschanged',\n      handleCurrentPlaybackTargetIsWirelessChanged\n    );\n    // $FlowFixMe: evt.availability is unknown to React.\n    videoElement.removeEventListener(\n      'webkitplaybacktargetavailabilitychanged',\n      handlePlaybackTargetAvailabilityChanged\n    );\n    videoElement.removeEventListener('webkitpresentationmodechanged', handlePresentationModeChanged);\n  }\n\n  return {\n    videoElementEventHandlers: {\n      onLoadStart,\n      onLoadedMetadata,\n      onCanPlay,\n      onWaiting,\n      onStalled,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onError,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager,\n    isPipAvailable,\n    cleanup\n  };\n};\n\nexport default getBasicVideoEventHandlers;\n","// @flow\nimport type { PlaybackSource } from '../types';\n\nexport default function getSourceChangeHandler(videoElement: HTMLVideoElement) {\n  const handleSourceChange = <P: { source?: ?PlaybackSource }>({ source }: P, prevProps: ?P) => {\n    const streamUrl = source ? (typeof source === 'string' ? source : source.streamUrl) : undefined;\n    if (streamUrl) {\n      videoElement.src = streamUrl;\n    } else if (videoElement.src) {\n      videoElement.removeAttribute('src');\n      videoElement.load();\n    }\n    return Promise.resolve();\n  };\n  return handleSourceChange;\n}\n","// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix } from '../../../common';\nimport type { PlaybackProps, VideoStreamerConfiguration, VideoStreamerImplProps } from '../types';\nimport type {\n  SimplifiedVideoStreamer,\n  StreamerImplementationParts,\n  TrackElementData,\n  VideoStreamerRenderer\n} from './types';\nimport { renderWithoutSource } from './renderers';\nimport { PlaybackError } from '../types';\n\nconst baseClassName = 'video-streamer';\n\ntype ResolveImplementation<C: VideoStreamerConfiguration, P: VideoStreamerImplProps<C>, T> = (\n  component: SimplifiedVideoStreamer<C, P>,\n  configuration: ?C,\n  videoElement: HTMLVideoElement,\n  onTrackElementDataChange: (?Array<TrackElementData>) => void\n) => Promise<StreamerImplementationParts<C, P, T>>;\n\ntype State = {\n  videoElementEventHandlers: { [string]: (any) => void },\n  trackElementData?: ?Array<TrackElementData>,\n  render: VideoStreamerRenderer\n};\n\nfunction createVideoStreamerComponent<C: VideoStreamerConfiguration, P: VideoStreamerImplProps<C>, T>(\n  name: string,\n  resolveImplementation: ResolveImplementation<C, P, T>\n) {\n  class VideoStreamer extends React.Component<P, State> {\n    static defaultProps = {\n      classNamePrefix: defaultClassNamePrefix\n    };\n\n    constructor(props: P) {\n      super(props);\n      this.videoRef = React.createRef();\n      this.state = {\n        videoElementEventHandlers: {},\n        render: renderWithoutSource\n      };\n    }\n\n    implementation: ?StreamerImplementationParts<C, P, T>;\n    videoRef: { current: null | HTMLVideoElement };\n\n    setProperties = (playbackProps: PlaybackProps) => {\n      const applyProperties = this.implementation && this.implementation.applyProperties;\n      if (applyProperties) {\n        applyProperties(playbackProps);\n      }\n    };\n\n    handleTrackElementDataChange = (trackElementData: ?Array<TrackElementData>) => {\n      this.setState({ trackElementData });\n    };\n\n    handleSourceChange = (nextProps: P, prevProps?: P) => {\n      const implementation = this.implementation;\n      if (implementation) {\n        implementation.startPlaybackSession();\n        implementation.textTrackManager.clear();\n        return implementation\n          .handleSourceChange(nextProps, prevProps)\n          .then(() => {\n            implementation.audioTrackManager.handleSourceChange();\n            implementation.textTrackManager.handleSourcePropChange(nextProps);\n          })\n          .catch(err => {\n            implementation.endPlaybackSession('dead');\n            return nextProps.onPlaybackError && nextProps.onPlaybackError(err);\n          });\n      }\n    };\n\n    componentDidMount() {\n      const videoElement = this.videoRef.current;\n      if (videoElement) {\n        resolveImplementation(this, this.props.configuration, videoElement, this.handleTrackElementDataChange)\n          .then(implementation => {\n            this.implementation = implementation;\n            const { render, videoElementEventHandlers, thirdPartyPlayer } = implementation;\n            this.setState({\n              render,\n              videoElementEventHandlers\n            });\n            if (this.props.onReady) {\n              this.props.onReady({ setProperties: this.setProperties, thirdPartyPlayer });\n            }\n            if (this.props.source) {\n              return this.handleSourceChange(this.props);\n            }\n          })\n          .catch(err => {\n            if (this.props.onPlaybackError && err instanceof PlaybackError) {\n              this.props.onPlaybackError(err);\n            } else {\n              throw err;\n            }\n          });\n      }\n    }\n\n    componentWillUnmount() {\n      const videoElement = this.videoRef.current;\n      if (videoElement) {\n        // $FlowFixMe\n        if (videoElement === document.pictureInPictureElement) {\n          // $FlowFixMe\n          return document.exitPictureInPicture();\n          // $FlowFixMe\n        } else if (\n          // $FlowFixMe\n          videoElement.webkitPresentationMode === 'picture-in-picture' && // $FlowFixMe\n          typeof videoElement.webkitSetPresentationMode === 'function'\n        ) {\n          // $FlowFixMe\n          videoElement.webkitSetPresentationMode('inline');\n        }\n      }\n      if (this.implementation && this.implementation.cleanup) {\n        return this.implementation.cleanup().catch(err => {\n          throw err;\n        });\n      }\n    }\n\n    getSnapshotBeforeUpdate() {\n      const previousVideoElement = this.videoRef.current;\n      // $FlowFixMe: Type defs not up-to-date.\n      const pipElement = document.pictureInPictureElement;\n      // $FlowFixMe\n      const presentationMode = previousVideoElement.webkitPresentationMode;\n      const wasPipActive = previousVideoElement === pipElement || presentationMode === 'picture-in-picture'; // $FlowFixMe\n      return {\n        wasPipActive,\n        previousVideoElement: this.videoRef.current\n      };\n    }\n\n    componentDidUpdate(\n      prevProps: P,\n      prevState: State,\n      snapshot?: { wasPipActive: boolean, previousVideoElement: HTMLVideoElement }\n    ) {\n      const implementation = this.implementation;\n      if (implementation) {\n        if (prevProps.source !== this.props.source) {\n          if (snapshot && snapshot.wasPipActive) {\n            // $FlowFixMe\n            if (document.exitPictureInPicture) {\n              document\n                .exitPictureInPicture()\n                .then(\n                  () => this.handleSourceChange(this.props, prevProps),\n                  () => this.handleSourceChange(this.props, prevProps)\n                );\n            } else if (\n              snapshot.previousVideoElement &&\n              // $FlowFixMe\n              typeof snapshot.previousVideoElement.webkitSetPresentationMode === 'function'\n            ) {\n              snapshot.previousVideoElement.webkitSetPresentationMode('inline');\n              this.handleSourceChange(this.props, prevProps);\n            }\n          } else {\n            this.handleSourceChange(this.props, prevProps);\n          }\n        } else if (prevProps.textTracks !== this.props.textTracks) {\n          implementation.textTrackManager.handleTextTracksPropChange(this.props);\n        }\n      }\n    }\n\n    render() {\n      const { videoRef } = this;\n      const { videoElementEventHandlers, render, trackElementData } = this.state;\n      const playsInline =\n        !this.props.configuration ||\n        this.props.configuration.playsInline == null ||\n        this.props.configuration.playsInline;\n      return render(videoRef, videoElementEventHandlers, this.props, baseClassName, playsInline, trackElementData);\n    }\n  }\n\n  VideoStreamer.displayName = name;\n  return VideoStreamer;\n}\n\nexport default createVideoStreamerComponent;\n","// @flow\nimport { type VideoStreamState } from '../types';\nimport { isDifferent } from '../../../common';\nimport type { VideoStreamerImplProps, VideoStreamStateKeys, VideoStreamStateValues } from '../types';\nimport type { SimplifiedVideoStreamer } from './types';\nimport type { VideoStreamerConfiguration } from '../types';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst saneNumberFilter = <T>(value: ?T) =>\n  value == null || isNaN(value) || value === Infinity || typeof value !== 'number' || value < 0 ? 0 : value;\n\nconst defaultFilters = {\n  position: saneNumberFilter,\n  duration: saneNumberFilter,\n  volume: saneNumberFilter\n};\n\nexport type SanityFilter = <T: ?VideoStreamStateValues>(val: T) => T;\n\nfunction getFilteredStreamStateUpdater<C: VideoStreamerConfiguration, P: VideoStreamerImplProps<C>>(\n  videoStreamer: SimplifiedVideoStreamer<C, P>,\n  filters: { [VideoStreamStateKeys]: SanityFilter } = defaultFilters\n) {\n  const currentValues: VideoStreamState = {};\n\n  function update(property: VideoStreamState) {\n    const callback = videoStreamer.props && videoStreamer.props.onStreamStateChange;\n    if (callback) {\n      // $FlowFixMe Yet to understand how to safely iterate through objects as maps.\n      Object.entries(property).forEach(([key, value]) => {\n        const saneValue = filters[key] ? filters[key](value) : value;\n        if (isDifferent(currentValues[key], saneValue)) {\n          // $FlowFixMe\n          currentValues[key] = saneValue;\n          callback({ [key]: saneValue });\n        }\n      });\n    }\n  }\n  return update;\n}\n\nexport default getFilteredStreamStateUpdater;\n","// @flow\n\nexport const getArrayLogger = (obj: any, name: string) => {\n  if (document.location.search.indexOf('debugVideoStreamer')) {\n    return {\n      log: (...args: Array<any>) => {\n        if (!obj[name]) {\n          obj[name] = [];\n        }\n        switch (args.length) {\n          case 0:\n            return;\n          case 1:\n            obj[name].push(args[0]);\n            return;\n          default:\n            obj[name].push(args);\n            return;\n        }\n      }\n    };\n  } else {\n    return { log: (...args: Array<any>) => {} };\n  }\n};\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { PlaybackLifeCycle } from './types';\n\nexport const emptyTracks: Array<AvailableTrack> = []; // Keeping the same array instance for all updates as long as not in use.\nconst emptyBitrates: Array<number> = [];\nconst dawnOfTime = new Date(0);\n\nfunction notifyInitialState(updateStreamState: VideoStreamState => void) {\n  updateStreamState({\n    duration: 0,\n    position: 0,\n    playMode: 'ondemand',\n    playState: 'inactive',\n    isBuffering: false,\n    isPaused: false,\n    isSeeking: false,\n    volume: 1,\n    muted: false,\n    bufferedAhead: 0,\n    isPipAvailable: false,\n    isAirPlayAvailable: false,\n    isPipActive: false,\n    isAirPlayActive: false,\n    bitrates: emptyBitrates,\n    audioTracks: emptyTracks,\n    textTracks: emptyTracks,\n    absolutePosition: dawnOfTime,\n    absoluteStartPosition: dawnOfTime\n  });\n}\n\nfunction notifyTerminalState(updateStreamState: VideoStreamState => void) {\n  updateStreamState({\n    // duration: 0,\n    // position: 0,\n    // playMode: 'ondemand',\n    playState: 'inactive', // Different\n    isBuffering: false,\n    isPaused: false,\n    isSeeking: false,\n    // volume: 1,\n    // muted: false,\n    // bufferedAhead: 0,\n    isPipAvailable: false,\n    isAirPlayAvailable: false\n    // isPipActive: false,\n    // isAirPlayActive: false,\n    // bitrates: emptyBitrates,\n    // audioTracks: emptyTracks,\n    // textTracks: emptyTracks,\n    // absolutePosition: dawnOfTime,\n    // absoluteStartPosition: dawnOfTime\n  });\n}\n\nfunction getPlaybackLifeCycleManager(\n  updateStreamState: VideoStreamState => void,\n  pauseStreamRangeUpdater: {\n    start: () => void,\n    stop: () => void\n  },\n  log?: string => void\n) {\n  let lifeCycleStage: PlaybackLifeCycle = 'unknown';\n  log && log(lifeCycleStage);\n\n  function getStage() {\n    return lifeCycleStage;\n  }\n\n  function setStage(newValue: PlaybackLifeCycle) {\n    log && log(newValue);\n    lifeCycleStage = newValue;\n  }\n\n  function startPlaybackSession() {\n    setStage('new');\n    notifyInitialState(updateStreamState);\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function endPlaybackSession(endStage?: PlaybackLifeCycle) {\n    if (endStage) {\n      setStage(endStage);\n    }\n    notifyTerminalState(updateStreamState);\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function cleanup() {\n    pauseStreamRangeUpdater.stop();\n  }\n\n  return {\n    startPlaybackSession,\n    endPlaybackSession,\n    getStage,\n    setStage,\n    cleanup\n  };\n}\n\nexport default getPlaybackLifeCycleManager;\n","// @flow\nimport type { PlaybackProps } from '../types';\nimport type { AudioTrackManager, BitrateManager, StreamRangeHelper, TextTrackManager } from './types';\n\nexport const getPropertyApplier = (\n  videoElement: HTMLVideoElement, // Abstract this away?\n  streamRangeHelper: StreamRangeHelper,\n  textTrackManager?: TextTrackManager,\n  audioTrackManager?: AudioTrackManager,\n  bitrateManager?: ?BitrateManager\n) => (playbackProps: PlaybackProps) => {\n  if ('isPaused' in playbackProps) {\n    if (playbackProps.isPaused) {\n      videoElement.pause();\n    } else {\n      videoElement.play();\n    }\n  }\n  if (playbackProps.volume != null) {\n    videoElement.volume = playbackProps.volume;\n  }\n  if (playbackProps.isMuted != null) {\n    videoElement.muted = playbackProps.isMuted;\n  }\n  if (playbackProps.position != null) {\n    streamRangeHelper.setPosition(playbackProps.position);\n  }\n  if (playbackProps.isAtLiveEdge) {\n    streamRangeHelper.gotoLive();\n  }\n  if (textTrackManager && 'selectedTextTrack' in playbackProps) {\n    textTrackManager.handleSelectedTextTrackChange(playbackProps.selectedTextTrack);\n  }\n  if (audioTrackManager && playbackProps.selectedAudioTrack) {\n    audioTrackManager.handleSelectedAudioTrackChange(playbackProps.selectedAudioTrack);\n  }\n  if (bitrateManager) {\n    if (playbackProps.bitrateFix !== undefined) {\n      // $FlowFixMe undefined is OK.\n      bitrateManager.fixBitrate(playbackProps.bitrateFix);\n    }\n    if (playbackProps.bitrateCap !== undefined) {\n      // $FlowFixMe undefined is OK.\n      bitrateManager.capBitrate(playbackProps.bitrateCap);\n    }\n  }\n  // $FlowFixMe: Type defs not up-to-date.\n  if ('isPipActive' in playbackProps) {\n    if (playbackProps.isPipActive) {\n      // $FlowFixMe\n      if (typeof videoElement.requestPictureInPicture === 'function') {\n        videoElement.requestPictureInPicture();\n        // $FlowFixMe\n      } else if (typeof videoElement.webkitSetPresentationMode === 'function') {\n        videoElement.webkitSetPresentationMode('picture-in-picture');\n      }\n      // $FlowFixMe\n    } else if (document.pictureInPictureElement === videoElement) {\n      // $FlowFixMe\n      document.exitPictureInPicture();\n      // $FlowFixMe\n    } else if (videoElement.webkitPresentationMode === 'picture-in-picture') {\n      // $FlowFixMe\n      videoElement.webkitSetPresentationMode('inline');\n    }\n  }\n  // $FlowFixMe: Type defs not up-to-date.\n  if (playbackProps.isAirPlayTargetPickerVisible && typeof videoElement.webkitShowPlaybackTargetPicker === 'function') {\n    videoElement.webkitShowPlaybackTargetPicker();\n  }\n};\n","// @flow\nimport * as React from 'react';\nimport { prefixClassNames } from '../../../common';\nimport type { TrackElementData, VideoStreamerRenderer } from './types';\n\nconst createTrackElement = ({ src, srclang, kind, label, onRef }: TrackElementData) => (\n  // $FlowFixMe. ref doesn't accept HTMLTrackElement as subtype to HTMLElement.\n  <track key={src + (label || '')} kind={kind} src={src} srcLang={srclang} label={label} ref={onRef} />\n);\n\nexport const renderWithoutSource: VideoStreamerRenderer = (\n  videoRef,\n  videoElementEventHandlers,\n  props,\n  baseClassName,\n  playsInline,\n  textTracks,\n  style\n) => {\n  const { className, classNamePrefix } = props;\n  const classNames = prefixClassNames(classNamePrefix, baseClassName, className);\n  return (\n    <video\n      autoPlay={true}\n      controls={false}\n      style={style}\n      className={classNames}\n      ref={videoRef}\n      playsInline={playsInline}\n      {...videoElementEventHandlers}>\n      {Array.isArray(textTracks) && textTracks.map(createTrackElement)}\n    </video>\n  );\n};\n\nexport const renderWithSource: VideoStreamerRenderer = (\n  videoRef,\n  videoElementEventHandlers,\n  props,\n  baseClassName,\n  playsInline,\n  textTracks,\n  style\n) => {\n  const { className, classNamePrefix, source } = props;\n  const classNames = prefixClassNames(classNamePrefix, baseClassName, className);\n  const streamUrl = source && (typeof source === 'string' ? source : source.streamUrl);\n  if (streamUrl) {\n    return (\n      <video\n        autoPlay={true}\n        controls={false}\n        style={style}\n        className={classNames}\n        src={streamUrl}\n        ref={videoRef}\n        playsInline={playsInline}\n        {...videoElementEventHandlers}>\n        {Array.isArray(textTracks) && textTracks.map(createTrackElement)}\n      </video>\n    );\n  } else {\n    return <video className={classNames} ref={videoRef} src={''} controls={false} style={style} />;\n  }\n};\n","// @flow\nimport type { AdvancedPlaybackSource, PlaybackSource } from '../types';\n\nconst normalizeSource = (source: ?PlaybackSource): ?AdvancedPlaybackSource =>\n  typeof source === 'string' ? { streamUrl: source } : source;\n\nexport default normalizeSource;\n","// @flow\n\n// Types for state observation\n\nimport type { CommonGenericProps, CommonProps } from '../../common';\n\nexport type PlayState = 'inactive' | 'starting' | 'playing' | 'paused' | 'seeking' | 'buffering';\nexport type PlayMode = 'ondemand' | 'live' | 'livedvr';\n\nexport type ErrorCode =\n  | 'STREAM_ERROR_TECHNOLOGY_UNSUPPORTED'\n  | 'STREAM_ERROR_DOWNLOAD'\n  | 'STREAM_ERROR_DECODE'\n  | 'STREAM_ERROR_DRM_OUTPUT_BLOCKED'\n  | 'STREAM_ERROR_DRM_CLIENT_UNAVAILABLE'\n  | 'STREAM_ERROR';\n\nexport type Severity = 'FATAL' | 'WARNING' | 'INFO';\n\nexport class PlaybackError extends Error {\n  constructor(code: ErrorCode, technology: string, message?: string, severity: Severity = 'FATAL', sourceError?: any) {\n    super(message);\n    this.code = code;\n    this.severity = severity;\n    this.technology = technology;\n    this.sourceError = sourceError;\n  }\n  code: ErrorCode;\n  severity: Severity;\n  technology: string;\n  sourceError: any;\n}\n\nexport type AvailableTrack = {\n  kind?: string,\n  label?: string,\n  language?: string,\n  origin?: 'side-loaded' | 'in-stream',\n  id?: string | number\n};\n\nexport type VideoStreamState = {\n  isPaused?: boolean,\n  isBuffering?: boolean,\n  isSeeking?: boolean,\n  position?: number,\n  duration?: number,\n  absolutePosition?: Date,\n  absoluteStartPosition?: Date,\n  isAtLiveEdge?: boolean,\n  playState?: PlayState,\n  playMode?: PlayMode,\n  volume?: number,\n  isMuted?: boolean,\n  isPipAvailable?: boolean,\n  isPipActive?: boolean,\n  isAirPlayAvailable?: boolean,\n  isAirPlayActive?: boolean,\n  bufferedAhead?: number,\n  currentBitrate?: number,\n  bitrateFix?: ?number,\n  bitrateCap?: ?number,\n  bitrates?: Array<number>,\n  currentTextTrack?: ?AvailableTrack,\n  textTracks?: Array<AvailableTrack>,\n  currentAudioTrack?: ?AvailableTrack,\n  audioTracks?: Array<AvailableTrack>,\n  error?: any\n};\n\nexport type VideoStreamStateKeys = $Keys<VideoStreamState>;\nexport type VideoStreamStateValues = $Values<VideoStreamState>;\n\n// Types used in settable props.\n\nexport type SourceTrack = {\n  src: string,\n  label?: string,\n  kind?: string,\n  language?: string,\n  contentType?: string,\n  cues?: Array<{ start: number, end: number, content: string }>\n};\n\nexport type FairPlayRequestFormat = 'formdata' | 'binary' | 'base64';\n\nexport type AdvancedPlaybackSource = {\n  streamUrl: string,\n  contentType?: string,\n  licenseUrl?: string,\n  drmType?: string,\n  startPosition?: number,\n  isLive?: boolean,\n  textTracks?: Array<SourceTrack>,\n  metadata?: any,\n  licenseAcquisitionDetails?: {\n    licenseRequestHeaders?: { [string]: string },\n    fairPlayCertificateUrl?: string,\n    widevineServiceCertificateUrl?: string,\n    fairPlayRequestFormat?: FairPlayRequestFormat,\n    contentIdExtractMatch?: RegExp | string,\n    contentId?: string\n  }\n};\n\nexport type PlaybackSource = string | AdvancedPlaybackSource;\n\n/* Types for settable props */\n\nexport type InitialPlaybackProps = {\n  isMuted?: boolean,\n  volume?: number,\n  isPaused?: boolean,\n  bitrateCap?: number,\n  bitrateFix?: number | 'max' | 'min'\n};\n\nexport type PlaybackProps = InitialPlaybackProps & {\n  position?: number,\n  isAtLiveEdge?: true,\n  isPipActive?: boolean,\n  isAirPlayTargetPickerVisible?: true,\n  selectedTextTrack?: ?AvailableTrack,\n  selectedAudioTrack?: AvailableTrack\n};\n\nexport type VideoStreamerMethods = {\n  setProperties: PlaybackProps => void,\n  thirdPartyPlayer: any\n};\n\nexport type VideoStreamerProps = CommonProps & {\n  // configuration?: ?VideoStreamerConfiguration,\n  source?: ?PlaybackSource,\n  textTracks?: ?Array<SourceTrack>,\n  className?: string,\n  initialPlaybackProps?: InitialPlaybackProps,\n  onReady?: VideoStreamerMethods => void,\n  onStreamStateChange?: VideoStreamState => void,\n  onProgress?: ({ event: string }) => void,\n  onPlaybackError?: PlaybackError => void\n};\n\nexport type VideoStreamerConfiguration = {\n  licenseAcquisition?: ?{\n    widevine: {\n      serviceCertificateUrl?: ?string,\n      withCredentials?: ?boolean\n    },\n    fairPlay: {\n      serviceCertificateUrl?: ?string,\n      withCredentials?: ?boolean,\n      requestFormat?: ?FairPlayRequestFormat,\n      contentIdExtractMatch?: ?(RegExp | string)\n    },\n    playReady: {\n      withCredentials?: ?boolean\n    }\n  },\n  manifestRequests?: ?{\n    withCredentials?: ?boolean\n  },\n  logLevel?: 'NONE' | 'ERROR' | 'WARNING' | 'INFO' | 'DEBUG',\n  defaultBandwidth?: ?number,\n  crossOrigin?: ?string,\n  playsInline?: ?boolean,\n  liveEdgeMargin?: ?number,\n  pauseUpdateInterval?: ?number\n};\n\nexport type VideoStreamerImplProps<T: VideoStreamerConfiguration> = VideoStreamerProps &\n  CommonGenericProps & {\n    configuration?: ?T\n  };\n","export function getFullscreenElement() {\n  // Ridiculous camel casing confusion ruling the Interwebs.\n  return (\n    document.fullScreenElement ||\n    document.fullscreenElement ||\n    document.webkitFullscreenElement ||\n    document.webkitFullScreenElement ||\n    document.mozFullScreenElement ||\n    document.msFullscreenElement\n  );\n}\n\nexport function enterFullscreen(element) {\n  if (element.requestFullscreen) {\n    element.requestFullscreen();\n    return true;\n  } else if (element.mozRequestFullScreen) {\n    element.mozRequestFullScreen();\n    return true;\n  } else if (element.msRequestFullscreen) {\n    element.msRequestFullscreen();\n    return true;\n  } else if (element.webkitRequestFullscreen) {\n    element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n    return true;\n  } else if (element.webkitRequestFullScreen) {\n    element.webkitRequestFullScreen(); // ALLOW_KEY_BOARD_INPUT makes this function not work in older Safari versions.\n    return true;\n  } else {\n    // Try native fullscreen for video element in Safari on iPhone and older iOS in general.\n    if (navigator.userAgent.match(/(iPad|iPhone|iPod)/i)) {\n      element = element.getElementsByTagName('video')[0];\n      if (element) {\n        element.webkitEnterFullscreen();\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function exitFullscreen() {\n  if (document.exitFullscreen) {\n    document.exitFullscreen();\n  } else if (document.mozCancelFullScreen) {\n    document.mozCancelFullScreen();\n  } else if (document.webkitExitFullscreen) {\n    document.webkitExitFullscreen();\n  } else if (document.webkitExitFullScreen) {\n    document.webkitExitFullScreen();\n  } else if (document.msExitFullscreen) {\n    document.msExitFullscreen();\n  }\n}\n\nexport function notifyFullscreenChange(handler) {\n  const fullscreenEventNames = [\n    'fullscreenchange',\n    'mozfullscreenchange',\n    'webkitfullscreenchange',\n    'MSFullscreenChange'\n  ];\n\n  fullscreenEventNames.forEach(function(eventName) {\n    document.addEventListener(eventName, handler);\n  });\n\n  return function() {\n    fullscreenEventNames.forEach(function(eventName) {\n      document.removeEventListener(eventName, handler);\n    });\n  };\n}\n","// @flow\n\nimport * as React from 'react';\nimport {\n  enterFullscreen,\n  exitFullscreen,\n  getFullscreenElement,\n  notifyFullscreenChange\n} from './ponyfills/crossBrowserFullscreen';\n\nexport type FullscreenState = {\n  isFullscreen: boolean,\n  setProperties: ({ isFullscreen: boolean }) => void,\n  enterFullscreen: () => void,\n  exitFullscreen: () => void\n};\n\ntype FullscreenRenderParameters = FullscreenState & {\n  onRef: (?HTMLElement) => void\n};\n\ntype Props = {\n  render: FullscreenRenderParameters => React.Node\n};\n\ntype State = {\n  isFullscreen: boolean\n};\n\nclass Fullscreen extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { isFullscreen: false };\n    this.unsubscribe = notifyFullscreenChange(this.onFullscreenChange);\n  }\n\n  fullscreenTarget: ?HTMLElement;\n  unsubscribe: () => void;\n\n  componentWillUnmount() {\n    this.unsubscribe && this.unsubscribe();\n  }\n\n  onRef = (element: ?HTMLElement) => {\n    this.fullscreenTarget = element;\n    this.setState({ isFullscreen: getFullscreenElement() === element });\n  };\n\n  onFullscreenChange = () => {\n    const fullscreenElement = getFullscreenElement();\n    this.setState({ isFullscreen: !!(fullscreenElement && fullscreenElement === this.fullscreenTarget) });\n  };\n\n  enterFullscreen = () => {\n    if (this.fullscreenTarget) {\n      enterFullscreen(this.fullscreenTarget);\n    }\n  };\n\n  exitFullscreen = () => {\n    if (this.fullscreenTarget) {\n      exitFullscreen(this.fullscreenTarget);\n    }\n  };\n\n  setProperties = ({ isFullscreen }: { isFullscreen: boolean } = {}) => {\n    if (isFullscreen) {\n      this.enterFullscreen();\n    } else {\n      this.exitFullscreen();\n    }\n  };\n\n  render() {\n    const { render } = this.props;\n    const { isFullscreen } = this.state;\n    const { enterFullscreen, exitFullscreen, onRef, setProperties } = this;\n    return render({ isFullscreen, enterFullscreen, exitFullscreen, setProperties, onRef });\n  }\n}\nexport default Fullscreen;\n","// @flow\nimport * as React from 'react';\nimport connectControl from '../PlayerController/connectControl';\n\nimport type { AvailableTrack, PlayState } from '../VideoStreamer/types';\nimport type { StreamStateKeysForObservation, SetPropertiesMethod } from '../PlayerController/ControllerContext';\nimport type { PreferredSettings } from '../../../default-player/types';\n\ntype SettingsStorageKind = 'none' | 'local' | 'session';\n\nexport type UserSettingsConfiguration = {\n  userSettings?: {\n    hasPrecedence?: ?boolean,\n    storageKey?: string,\n    settingsStoragePolicy: {\n      volume?: ?SettingsStorageKind,\n      isMuted?: ?SettingsStorageKind,\n      textTrackLanguage?: ?SettingsStorageKind,\n      textTrackKind?: ?SettingsStorageKind,\n      audioTrackLanguage?: ?SettingsStorageKind,\n      audioTrackKind?: ?SettingsStorageKind\n    }\n  }\n};\n\ntype Props = PreferredSettings & {\n  textTracks?: Array<AvailableTrack>,\n  audioTracks?: Array<AvailableTrack>,\n  playState?: PlayState,\n  setProperties: SetPropertiesMethod,\n  configuration?: ?UserSettingsConfiguration\n};\n\nconst noop = () => {};\n\nconst getTrackFromLanguageAndKind = (\n  language: ?string,\n  kind: ?string,\n  tracks: ?Array<AvailableTrack>,\n  ignorableLength: number\n): ?AvailableTrack => {\n  if (Array.isArray(tracks) && tracks.length > ignorableLength) {\n    return (\n      tracks.filter(track => track.language === language && track.kind === kind)[0] ||\n      tracks.filter(track => track.language === language)[0] ||\n      tracks.filter(track => track.kind === kind)[0]\n    );\n  }\n};\n\nconst getTrackToSelect = (\n  preferredLanguage: ?string,\n  preferredKind: ?string,\n  prevTracks: ?Array<AvailableTrack>,\n  nextTracks: ?Array<AvailableTrack>,\n  ignorableTrackListLength: number\n) => {\n  if (prevTracks !== nextTracks && Array.isArray(nextTracks) && nextTracks.length > 0) {\n    return getTrackFromLanguageAndKind(preferredLanguage, preferredKind, nextTracks, ignorableTrackListLength);\n  }\n};\n\nconst mergePreferredSettings = (\n  configuration: ?UserSettingsConfiguration,\n  programmaticSettings: PreferredSettings,\n  localStorage: Storage,\n  sessionStorage: Storage\n): PreferredSettings => {\n  const userSettingsConfig = configuration && configuration.userSettings;\n  const storageKey = userSettingsConfig && userSettingsConfig.storageKey;\n  if (userSettingsConfig && storageKey) {\n    let localSettings = {};\n    let sessionSettings = {};\n    try {\n      sessionSettings = JSON.parse(sessionStorage.getItem(storageKey) || '{}');\n    } catch (e) {}\n    try {\n      localSettings = JSON.parse(localStorage.getItem(storageKey) || '{}');\n    } catch (e) {}\n    if (userSettingsConfig.hasPrecedence) {\n      return {\n        ...programmaticSettings,\n        ...localSettings,\n        ...sessionSettings\n      };\n    } else {\n      return {\n        ...localSettings,\n        ...sessionSettings,\n        ...programmaticSettings\n      };\n    }\n  } else {\n    return programmaticSettings;\n  }\n};\n\nconst getPropsToBeUpdated = (\n  prevPlayState: ?PlayState,\n  nextPlayState: ?PlayState,\n  prevAudioTracks: ?Array<AvailableTrack>,\n  prevTextTracks: ?Array<AvailableTrack>,\n  nextAudioTracks: ?Array<AvailableTrack>,\n  nextTextTracks: ?Array<AvailableTrack>,\n  preferredSettings: PreferredSettings\n) => {\n  const updates = {};\n\n  if (nextPlayState !== prevPlayState && nextPlayState === 'starting') {\n    if (preferredSettings.volume != null) {\n      updates.volume = preferredSettings.volume;\n    }\n    if (preferredSettings.isMuted != null) {\n      updates.isMuted = preferredSettings.isMuted;\n    }\n  }\n\n  const audioTrackToSelect = getTrackToSelect(\n    preferredSettings.audioTrackLanguage,\n    preferredSettings.audioTrackKind,\n    prevAudioTracks,\n    nextAudioTracks,\n    1\n  );\n  if (audioTrackToSelect) {\n    updates.selectedAudioTrack = audioTrackToSelect;\n  }\n\n  const textTrackToSelect = getTrackToSelect(\n    preferredSettings.textTrackLanguage,\n    preferredSettings.textTrackKind,\n    prevTextTracks,\n    nextTextTracks,\n    0\n  );\n  if (textTrackToSelect) {\n    updates.selectedTextTrack = textTrackToSelect;\n  }\n\n  return updates;\n};\n\nconst onPropsChanged = (prevProps: Props, nextProps: Props, localStorage: Storage, sessionStorage: Storage) => {\n  const {\n    configuration,\n    playState,\n    audioTracks,\n    textTracks,\n    volume,\n    isMuted,\n    textTrackLanguage,\n    textTrackKind,\n    audioTrackLanguage,\n    audioTrackKind,\n    setProperties\n  } = nextProps;\n\n  const programmaticSettings = {};\n  if (volume != null) {\n    programmaticSettings.volume = volume;\n  }\n  if (isMuted != null) {\n    programmaticSettings.isMuted = isMuted;\n  }\n  if (textTrackLanguage != null) {\n    programmaticSettings.textTrackLanguage = textTrackLanguage;\n  }\n  if (textTrackKind != null) {\n    programmaticSettings.textTrackKind = textTrackKind;\n  }\n  if (audioTrackLanguage != null) {\n    programmaticSettings.audioTrackLanguage = audioTrackLanguage;\n  }\n  if (audioTrackKind != null) {\n    programmaticSettings.audioTrackKind = audioTrackKind;\n  }\n\n  const mergedSettings = mergePreferredSettings(configuration, programmaticSettings, localStorage, sessionStorage);\n  const propsToBeUpdated = getPropsToBeUpdated(\n    prevProps.playState,\n    playState,\n    prevProps.audioTracks,\n    prevProps.textTracks,\n    audioTracks,\n    textTracks,\n    mergedSettings\n  );\n\n  if (Object.keys(propsToBeUpdated).length > 0) {\n    setProperties(propsToBeUpdated);\n  }\n};\n\n// Testable version:\nexport const getPreferredSettingsApplicator = (\n  localStorage: Storage = window.localStorage,\n  sessionStorage: Storage = window.sessionStorage\n) =>\n  class PreferredSettingsApplicator extends React.Component<Props> {\n    static streamStateKeysForObservation: StreamStateKeysForObservation = ['playState', 'textTracks', 'audioTracks'];\n    componentDidMount() {\n      onPropsChanged({ setProperties: noop }, this.props, localStorage, sessionStorage);\n    }\n    componentDidUpdate(prevProps: Props) {\n      onPropsChanged(prevProps, this.props, localStorage, sessionStorage);\n    }\n    render() {\n      return null;\n    }\n  };\n\nconst PreferredSettingsApplicator = connectControl(getPreferredSettingsApplicator());\n\nexport default PreferredSettingsApplicator;\n","// @flow\n\nimport type { PlayerConfiguration } from './types';\n\nexport const baseConfiguration: PlayerConfiguration = {\n  videoStreamer: {\n    logLevel: 'WARNING'\n  },\n  interactionDetector: {\n    inactivityDelay: 2\n  },\n  keyboardShortcuts: {\n    keyMap: {\n      togglePause: [' ', 'Enter', 'P'],\n      toggleFullscreen: 'F',\n      decreaseVolume: '-',\n      increaseVolume: '+',\n      skipBack: ',',\n      skipForward: '.',\n      toggleUserActive: 'C',\n      toggleMute: 'M'\n    }\n  },\n  responsivenessRules: [\n    {\n      className: 'narrow',\n      width: {\n        max: 500\n      }\n    },\n    {\n      className: 'medium-width',\n      width: {\n        min: 500,\n        max: 1000\n      }\n    },\n    {\n      className: 'wide',\n      width: {\n        min: 1000\n      }\n    }\n  ],\n  userSettings: {\n    hasPrecedence: false,\n    storageKey: 'replay-settings',\n    settingsStoragePolicy: {\n      volume: 'local',\n      isMuted: 'local',\n      textTrackLanguage: 'local',\n      textTrackKind: 'local',\n      audioTrackLanguage: 'local',\n      audioTrackKind: 'local'\n    }\n  },\n  controls: {\n    skipButtonOffset: -10,\n    qualitySelectionStrategy: 'cap-bitrate',\n    liveDisplayMode: 'clock-time'\n  },\n  playbackMonitor: {\n    visibleAtStart: false\n  }\n};\n","import * as React from 'react';\n\nconst LoadingAnimation = () => (\n  <svg width=\"100%\" height=\"100%\" viewBox=\"0 0 38 38\" stroke=\"currentColor\">\n    <g fill=\"none\" fillRule=\"evenodd\">\n      <g transform=\"translate(1 1)\" strokeWidth=\"2\">\n        <circle stroke=\"currentColor\" strokeOpacity=\"0.5\" cx=\"18\" cy=\"18\" r=\"18\" />\n        <path className=\"animated\" d=\"M36 18c0-9.94-8.06-18-18-18\" />\n      </g>\n    </g>\n  </svg>\n);\n\nexport default LoadingAnimation;\n","// @flow\nimport * as React from 'react';\nimport {\n  Play,\n  Pause,\n  RotateCcw,\n  Volume2,\n  VolumeX,\n  MessageSquare,\n  Type,\n  Settings,\n  Copy,\n  Square,\n  Airplay,\n  Maximize,\n  Minimize,\n  XCircle\n} from 'react-feather';\nimport LoadingAnimation from './LoadingAnimation';\nimport strings from '../strings';\n\nconst graphics = {\n  playPauseButton: {\n    playingContent: <Pause />,\n    pausedContent: <Play />\n  },\n  skipButton: {\n    content: (\n      <React.Fragment>\n        <span>\n          <RotateCcw />\n        </span>\n        <span>{strings.skipButton.seconds}</span>\n      </React.Fragment>\n    )\n  },\n  timeline: {\n    handleContent: '',\n    trackContent: <div />\n  },\n  gotoLiveButton: {\n    isAtLiveEdgeContent: <span>{strings.gotoLiveButton.isLive}</span>,\n    isNotAtLiveEdgeContent: <span>{strings.gotoLiveButton.gotoLive}</span>\n  },\n  volume: {\n    unmutedContent: <Volume2 />,\n    mutedContent: <VolumeX />,\n    volumeSliderHandleContent: ''\n  },\n  audioSelector: {\n    toggleContent: <MessageSquare />\n  },\n  subtitlesSelector: {\n    toggleContent: <Type />\n  },\n  qualitySelector: {\n    toggleContent: <Settings />\n  },\n  pipButton: {\n    pipActiveContent: <Square />,\n    pipInactiveContent: <Copy />\n  },\n  airPlayButton: {\n    airPlayActiveContent: <Airplay />,\n    airPlayInactiveContent: <Airplay />\n  },\n  fullscreenButton: {\n    normalContent: <Maximize />,\n    fullscreenContent: <Minimize />\n  },\n  bufferingIndicator: {\n    content: <LoadingAnimation />,\n    renderStrategy: 'always'\n  },\n  playbackMonitor: {\n    closeButtonContent: <XCircle />\n  },\n  exitButton: {\n    content: <XCircle />\n  }\n};\n\nexport default graphics;\n","const strings = {\n  playPauseButton: {\n    label: 'Toggle play/pause'\n  },\n  skipButton: {\n    label: 'Skip back 10 seconds',\n    seconds: '–10'\n  },\n  timeDisplay: {\n    label: 'Video times',\n    clockTimeLabel: 'Clock time',\n    positionLabel: 'Current time',\n    durationLabel: 'Duration',\n    negativeMark: '–'\n  },\n  timeline: {\n    label: 'Timeline'\n  },\n  gotoLiveButton: {\n    label: 'Play from live position',\n    isLive: 'Live',\n    gotoLive: 'Go live'\n  },\n  volume: {\n    label: 'Volume and mute',\n    muteToggleLabel: 'Toggle mute',\n    volumeSliderLabel: 'Volume setting'\n  },\n  audioSelector: {\n    label: 'Audio track selector'\n  },\n  subtitlesSelector: {\n    label: 'Subtitles selector',\n    noSubtitlesLabel: 'No subtitles'\n  },\n  qualitySelector: {\n    label: 'Video quality selector',\n    autoLabel: 'Automatic',\n    formatBitrateLabel: (bitrate, isPlaying) => `${bitrate} kbps${isPlaying ? ' •' : ''}`\n  },\n  pipButton: {\n    label: 'Toggle picture-in-picture mode'\n  },\n  airPlayButton: {\n    label: 'Select AirPlay device'\n  },\n  fullscreenButton: {\n    label: 'Toggle fullscreen'\n  },\n  bufferingIndicator: {\n    label: 'Video is buffering'\n  },\n  exitButton: {\n    label: 'Exit'\n  }\n};\n\nexport default strings;\n","// @flow\nimport * as React from 'react';\nimport ControllerContext from './ControllerContext';\nimport type {\n  AvailableTrack,\n  InitialPlaybackProps,\n  VideoStreamerMethods,\n  PlaybackProps,\n  VideoStreamerProps,\n  VideoStreamState,\n  VideoStreamStateKeys\n} from '../VideoStreamer/types';\nimport type { ObserveCallback, ControllerApi, SetPropertiesMethod } from './ControllerContext';\nimport { override } from '../../common';\nimport memoize from 'memoize-one';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nexport type RenderParameters = {\n  controllerApi: ControllerApi,\n  externalProps: any,\n  configuration: any\n};\n\nexport type RenderMethod = RenderParameters => React.Node;\n\nexport type PlaybackActions = {\n  play: () => void,\n  pause: () => void,\n  setPosition: number => void,\n  gotoLive: () => void,\n  setVolume: number => void,\n  setIsMuted: boolean => void,\n  mute: () => void,\n  unmute: () => void,\n  requestPictureInPicture: () => void,\n  exitPictureInPicture: () => void,\n  showAirPlayTargetPicker: () => void,\n  setSelectedAudioTrack: AvailableTrack => void,\n  setSelectedTextTrack: (AvailableTrack | null) => void,\n  capBitrate: number => void,\n  fixBitrate: (number | 'max' | 'min') => void,\n  inspect: () => VideoStreamState,\n  setProperties: PlaybackProps => void\n};\n\ntype PlayerControllerProps = {\n  render: RenderMethod,\n  children: React.Node,\n  externalProps?: any,\n  configuration?: any,\n  options?: any,\n  onPlaybackActionsReady?: PlaybackActions => void,\n  onStreamStateChange?: VideoStreamState => void,\n  onStreamerError?: any => void,\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\ntype PlayerControllerState = {\n  videoStreamerProps: VideoStreamerProps,\n  setProperties: SetPropertiesMethod\n};\n\nconst passPropsToVideoStreamer = (children: React.Node, props: any): React.Element<any> => {\n  return React.Children.map(children, (child, i) => {\n    if (i === 0) {\n      return React.cloneElement(child, props);\n    } else {\n      return child;\n    }\n  })[0];\n};\n\nconst getObserveManager = () => {\n  const observers: { [VideoStreamStateKeys]: Array<ObserveCallback> } = {};\n\n  const observe = (key: VideoStreamStateKeys, callback: ObserveCallback) => {\n    if (!(key in observers)) {\n      observers[key] = [];\n    }\n    observers[key].push(callback);\n  };\n\n  const unobserve = (key: VideoStreamStateKeys, callback: ObserveCallback) => {\n    if (Array.isArray(observers[key])) {\n      const index = observers[key].indexOf(callback);\n      if (index !== -1) {\n        observers[key].splice(index, 1);\n      }\n    }\n  };\n\n  const unobserveAll = () => {\n    Object.entries(observers).forEach(([key, handlers]) => {\n      while (handlers.length) {\n        handlers.pop();\n      }\n    });\n  };\n\n  const update = (prop: VideoStreamState) => {\n    Object.keys(prop).forEach(key => {\n      if (Array.isArray(observers[key])) {\n        observers[key].forEach(callback => {\n          callback(prop);\n        });\n      }\n    });\n  };\n\n  return {\n    observe,\n    unobserve,\n    update,\n    unobserveAll\n  };\n};\n\nconst createPlaybackActions = (inspect, setProperties: PlaybackProps => void): PlaybackActions => {\n  const play = () => setProperties({ isPaused: false });\n  const pause = () => setProperties({ isPaused: true });\n  const setPosition = (position: number) => setProperties({ position });\n  const gotoLive = () => setProperties({ isAtLiveEdge: true });\n  const setVolume = (volume: number) => setProperties({ volume });\n  const setIsMuted = (isMuted: boolean) => setProperties({ isMuted });\n  const mute = () => setProperties({ isMuted: true });\n  const unmute = () => setProperties({ isMuted: false });\n  const requestPictureInPicture = () => setProperties({ isPipActive: true });\n  const exitPictureInPicture = () => setProperties({ isPipActive: false });\n  const showAirPlayTargetPicker = () => setProperties({ isAirPlayTargetPickerVisible: true });\n  const setSelectedTextTrack = (selectedTextTrack: AvailableTrack | null) => setProperties({ selectedTextTrack });\n  const setSelectedAudioTrack = (selectedAudioTrack: AvailableTrack) => setProperties({ selectedAudioTrack });\n  const capBitrate = (bitrateCap: number) => setProperties({ bitrateCap });\n  const fixBitrate = (bitrateFix: number | 'max' | 'min') => setProperties({ bitrateFix });\n  return {\n    play,\n    pause,\n    setPosition,\n    gotoLive,\n    setVolume,\n    setIsMuted,\n    mute,\n    unmute,\n    requestPictureInPicture,\n    exitPictureInPicture,\n    showAirPlayTargetPicker,\n    setSelectedAudioTrack,\n    setSelectedTextTrack,\n    capBitrate,\n    fixBitrate,\n    setProperties,\n    inspect\n  };\n};\n\nclass PlayerController extends React.Component<PlayerControllerProps, PlayerControllerState> {\n  constructor(props: PlayerControllerProps) {\n    super(props);\n    const videoStreamerProps: VideoStreamerProps = {\n      initialPlaybackProps: this.props.initialPlaybackProps, //TODO: This is overwritten by preferred settings. Reconsider.\n      onReady: this.onVideoStreamerReady,\n      onPlaybackError: this.props.onStreamerError,\n      onStreamStateChange: this.onStreamStateChange\n    };\n    this.state = {\n      videoStreamerProps,\n      setProperties: () => {}\n    };\n  }\n\n  componentDidMount() {\n    const onReady = this.props.onPlaybackActionsReady;\n    if (onReady) {\n      onReady(createPlaybackActions(() => this.inspect(), props => this.setProperties(props)));\n    }\n  }\n\n  componentWillUnmount() {\n    this.observeManager.unobserveAll();\n  }\n\n  inspectableStreamState: VideoStreamState = {};\n  observeManager = getObserveManager();\n\n  inspect = () => this.inspectableStreamState;\n\n  mergeConfiguration = memoize(override);\n\n  setProperties = (props: PlaybackProps) => this.state.setProperties(props);\n\n  onVideoStreamerReady = ({ setProperties }: VideoStreamerMethods) => {\n    this.inspectableStreamState = {};\n    this.setState({ setProperties });\n  };\n\n  // Video streamer -> UI\n  onStreamStateChange = (property: VideoStreamState) => {\n    // if (!('position' in property) && !('bufferedAhead' in property)) { console.log('Updating %s', Object.keys(property).join(', '), property); }\n    this.observeManager.update(property);\n    this.inspectableStreamState = { ...this.inspectableStreamState, ...property };\n    if (this.props.onStreamStateChange) {\n      this.props.onStreamStateChange(property);\n    }\n  };\n\n  render() {\n    const { setProperties, videoStreamerProps } = this.state;\n    const { observeManager } = this;\n    const { render, externalProps, configuration, options } = this.props;\n    const mergedConfiguration = this.mergeConfiguration(configuration, options);\n    const { observe, unobserve } = observeManager;\n    const controllerApi = {\n      setProperties,\n      videoStreamer: passPropsToVideoStreamer(this.props.children, {\n        ...videoStreamerProps,\n        configuration: mergedConfiguration.videoStreamer\n      }),\n      observe,\n      inspect: this.inspect,\n      unobserve\n    };\n\n    return (\n      <ControllerContext.Provider value={controllerApi}>\n        {render({ controllerApi, configuration: mergedConfiguration, externalProps })}\n      </ControllerContext.Provider>\n    );\n  }\n}\n\nexport default PlayerController;\n","// @flow\nimport * as React from 'react';\nimport type { ControlNames } from '../../default-player/types';\n\ntype Props = {\n  children: React.Node,\n  configuration: ?Array<ControlNames>\n};\n\nconst alreadyWarnedNames = [];\n\nconst analyzeChild = child => {\n  const type = child && child.type;\n  let displayName = type && child.type.displayName;\n  const name = type && child.type.name;\n  let fullName = name;\n  if (name === 'ConnectedControl') {\n    fullName = child.type.controlWithoutDisplayName || name;\n  }\n  if (!displayName && (!name || alreadyWarnedNames.indexOf(name) === -1)) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      '<RenderIfEnabled/> depends on child components having the displayName static property set. The component %s, has no ' +\n        'displayName property set. If no displayName is added to %s, the control might not render in production builds.',\n      fullName || '[no name found]',\n      name || '[no name found]'\n    );\n    if (name) {\n      alreadyWarnedNames.push(name);\n    }\n  }\n};\n\nconst extractChildName = child => {\n  const name = child && child.type && (child.type.displayName || child.type.name);\n  if (name) {\n    const startIndex = name.indexOf('Connected') === 0 ? 9 : 0;\n    return name.charAt(startIndex).toLowerCase() + name.substr(startIndex + 1);\n  }\n};\n\nclass RenderIfEnabled extends React.Component<Props> {\n  render() {\n    if (this.props.configuration) {\n      return React.Children.map(this.props.children, child => {\n        if (process.env.NODE_ENV === 'development') {\n          analyzeChild(child);\n        }\n        const childName = extractChildName(child);\n        if (!childName || (this.props.configuration && this.props.configuration.indexOf(childName) >= 0)) {\n          return child;\n        }\n      });\n    } else if (process.env.NODE_ENV === 'development') {\n      React.Children.forEach(this.props.children, analyzeChild);\n      return this.props.children;\n    } else {\n      return this.props.children;\n    }\n  }\n}\n\nexport default RenderIfEnabled;\n","// @flow\nimport * as React from 'react';\nimport type { RenderMethod } from '../components/player/PlayerController/PlayerController';\nimport type {\n  GraphicAndStringResources,\n  GraphicResources,\n  PlayerConfiguration,\n  StringResources,\n  UIResources\n} from './types';\nimport { defaultClassNamePrefix } from '../components/common';\n\n// Non-connected controls\nimport ControlsBar from '../components/controls/ControlsBar/ControlsBar';\nimport FullscreenButton from '../components/controls/FullscreenButton/FullscreenButton';\nimport ExitButton from '../components/controls/ExitButton/ExitButton';\n\n// Connected controls\nimport PlaybackMonitor from '../components/controls/PlaybackMonitor/PlaybackMonitor';\nimport {\n  BufferingIndicator,\n  GotoLiveButton,\n  PlayerUIContainer,\n  PlayPauseButton,\n  QualitySelector,\n  SettingsStorage,\n  SkipButton,\n  TimeDisplay,\n  TimelineInformation,\n  Timeline,\n  PipButton,\n  AirPlayButton\n} from '../components/player/PlayerController/connectedControls';\nimport { ControlledVideoStreamer } from '../components/player/PlayerController/connectControl';\nimport RenderIfEnabled from '../components/player/RenderIfEnabled';\nimport PreferredSettingsApplicator from '../components/player/settings-helpers/PreferredSettingsApplicator';\n\nconst { AudioSelector, SubtitlesSelector, Volume } = SettingsStorage;\nconst getSkipBackOffset = (conf: PlayerConfiguration) => conf && conf.controls && conf.controls.skipButtonOffset;\nconst getLiveDisplayMode = (conf: PlayerConfiguration) => conf && conf.controls && conf.controls.liveDisplayMode;\nconst getQSStrategy = (conf: PlayerConfiguration) => conf && conf.controls && conf.controls.qualitySelectionStrategy;\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst merge = (\n  strings: UIResources<StringResources>,\n  graphics: UIResources<GraphicResources>\n): UIResources<GraphicAndStringResources> => {\n  const merged = {};\n  Object.entries(strings).forEach(([control, props]) => {\n    merged[control] = { ...merged[control], ...props };\n  });\n  Object.entries(graphics).forEach(([control, props]) => {\n    merged[control] = { ...merged[control], ...props };\n  });\n  return merged;\n};\n\n// The following method is assembling all controls into the player UI. Create a copy for assembling custom player UIs.\n\nconst getPlayerUIRenderer = (\n  graphics: UIResources<GraphicResources>,\n  strings: UIResources<StringResources>,\n  classNamePrefix?: string = defaultClassNamePrefix\n) => {\n  const u = merge(strings, graphics);\n  const renderPlayerUI: RenderMethod = ({ configuration, externalProps }) => {\n    const prefix = { classNamePrefix: (configuration && configuration.classNamePrefix) || classNamePrefix };\n    const includedControlsList = configuration.controls && configuration.controls.includeControls;\n    return (\n      <PlayerUIContainer\n        configuration={configuration}\n        {...prefix}\n        render={({ fullscreenState }) => (\n          <>\n            <ControlledVideoStreamer {...prefix} />\n            <RenderIfEnabled configuration={includedControlsList}>\n              <ExitButton {...u.exitButton} {...prefix} onClick={externalProps && externalProps.onExit} />\n              <PlaybackMonitor {...u.playbackMonitor} configuration={configuration} />\n            </RenderIfEnabled>\n            <ControlsBar {...prefix}>\n              <RenderIfEnabled configuration={includedControlsList}>\n                <PlayPauseButton {...u.playPauseButton} {...prefix} />\n                <SkipButton {...u.skipButton} {...prefix} offset={getSkipBackOffset(configuration)} />\n                <Timeline {...u.timeline} {...prefix}>\n                  <TimelineInformation {...prefix} />\n                </Timeline>\n                <TimeDisplay {...u.timeDisplay} {...prefix} liveDisplayMode={getLiveDisplayMode(configuration)} />\n                <GotoLiveButton {...u.gotoLiveButton} {...prefix} />\n                <Volume {...u.volume} {...prefix} configuration={configuration} />\n                <AudioSelector {...u.audioSelector} {...prefix} configuration={configuration} />\n                <SubtitlesSelector {...u.subtitlesSelector} {...prefix} configuration={configuration} />\n                <QualitySelector {...u.qualitySelector} {...prefix} selectionStrategy={getQSStrategy(configuration)} />\n                <PipButton {...u.pipButton} {...prefix} />\n                <AirPlayButton {...u.airPlayButton} {...prefix} />\n                <FullscreenButton {...u.fullscreenButton} {...prefix} {...fullscreenState} />\n              </RenderIfEnabled>\n            </ControlsBar>\n            <BufferingIndicator {...u.bufferingIndicator} {...prefix} />\n            <PreferredSettingsApplicator configuration={configuration} {...externalProps.initialPlaybackProps} />\n          </>\n        )}\n      />\n    );\n  };\n  return renderPlayerUI;\n};\n\nexport default getPlayerUIRenderer;\n","// @flow\nimport * as React from 'react';\n\nimport type { PlaybackSource, SourceTrack, VideoStreamerProps } from './components/player/VideoStreamer/types';\nimport type { RenderMethod } from './components/player/PlayerController/PlayerController';\nimport type { ReplayProps } from './default-player/types';\nimport PlayerController from './components/player/PlayerController/PlayerController';\nimport { baseConfiguration } from './default-player/baseConfiguration';\nimport type { GraphicResources, StringResources, UIResources } from './default-player/types';\nimport getPlayerUIRenderer from './default-player/playerUI';\nimport { defaultClassNamePrefix } from './components/common';\nimport replayVersion from './version';\nimport BasicVideoStreamer from './components/player/VideoStreamer/BasicVideoStreamer/BasicVideoStreamer';\n\nexport type ResolveVideoStreamerMethod = (\n  Component: ?React.ComponentType<VideoStreamerProps>,\n  children: ?React.Element<any>,\n  source?: ?PlaybackSource,\n  textTracks?: ?Array<SourceTrack>\n) => ?React.Element<any>;\n\ntype Customization = {\n  name?: string,\n  configuration?: any,\n  graphics?: UIResources<GraphicResources>,\n  strings?: UIResources<StringResources>,\n  classNamePrefix?: string,\n  version?: string,\n  uiRenderMethod?: RenderMethod,\n  resolveVideoStreamerMethod?: ResolveVideoStreamerMethod,\n  // future: styles: { [string]: any },\n  videoStreamerComponent?: React.ComponentType<VideoStreamerProps>\n};\n\n// In addition comes CSS.\n\nconst defaultVideoStreamerResolver: ResolveVideoStreamerMethod = (Component, children, source, textTracks) =>\n  children ? (\n    React.cloneElement(children, { source, textTracks })\n  ) : (\n    <BasicVideoStreamer source={source} textTracks={textTracks} />\n  );\n\nconst composePlayer = ({\n  name,\n  videoStreamerComponent,\n  graphics,\n  strings,\n  uiRenderMethod,\n  resolveVideoStreamerMethod = defaultVideoStreamerResolver,\n  classNamePrefix = defaultClassNamePrefix,\n  configuration = baseConfiguration,\n  version = replayVersion\n}: Customization): React.ComponentType<ReplayProps> => {\n  const renderUI = uiRenderMethod || (graphics && strings && getPlayerUIRenderer(graphics, strings, classNamePrefix));\n  if (!renderUI) {\n    throw new Error(\n      'Either a custom UI render method must be specified in the customization parameters, ' +\n        'or graphics and strings must be specified for the default player UI renderer.'\n    );\n  }\n\n  const ComposedPlayer = ({\n    source,\n    textTracks,\n    options,\n    onPlaybackActionsReady,\n    onStreamStateChange,\n    onExit,\n    onError,\n    initialPlaybackProps,\n    children,\n    ...externalProps\n  }: ReplayProps) => {\n    return (\n      <PlayerController\n        render={renderUI}\n        configuration={configuration}\n        options={options}\n        onStreamerError={onError}\n        onPlaybackActionsReady={onPlaybackActionsReady}\n        onStreamStateChange={onStreamStateChange}\n        initialPlaybackProps={initialPlaybackProps}\n        externalProps={{ ...externalProps, onExit, initialPlaybackProps }}>\n        {resolveVideoStreamerMethod(videoStreamerComponent, children, source, textTracks) || null}\n      </PlayerController>\n    );\n  };\n  if (name) {\n    ComposedPlayer.displayName = name;\n  }\n  ComposedPlayer.version = version;\n  return ComposedPlayer;\n};\n\nexport default composePlayer;\n","let version = '0.0.0';\ntry {\n  version = __VERSION__; // eslint-disable-line no-undef\n} catch (e) {}\nexport default version;\n"],"sourceRoot":""}