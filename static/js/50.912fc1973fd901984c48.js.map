{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaTextTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/ShakaVideoStreamer.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSetup.js"],"names":["dawnOfTime","Date","minimumDvrLength","dvrStartCorrection","getStreamRangeHelper","videoElement","shakaPlayer","configuration","liveMargin","liveEdgeMargin","adjustForDvrStartOffset","paused","isLive","seekableStart","seekRange","start","currentTime","calculateNewState","startDateTime","getPresentationStartTimeAsDate","position","duration","end","Infinity","isNaN","playMode","resolvePlayMode","isAtLiveEdge","_getAbsolutePositions","absolutePosition","absoluteStartPosition","getTime","getAbsolutePositions","setPosition","newPosition","gotoLive","errorTechnology","STREAM_ERROR","STREAM_ERROR_DRM_CLIENT_UNAVAILABLE","STREAM_ERROR_DRM_OUTPUT_BLOCKED","errorFromCodeMappings","3016","shakaError","data","classification","4012","6001","6002","6003","6007","6008","6013","7000","1","2","3","4","5","6","defaultError","reverseLookup","numeric","mappings","Object","keys","filter","key","parseInt","getSeverity","isStarted","code","test","category","mapShakaError","userAgent","location","mapping","Math","floor","getFromDeclarativeMapping","protocol","hostname","indexOf","isEmeBlocked","PlaybackError","message","shaka","util","Error","Code","Category","buildMessage","getSourceChangeHandler","nextProps","prevProps","shakaRequestFilter","shakaResponseFilter","source","normalizeSource","networkingEngine","getNetworkingEngine","clearAllRequestFilters","clearAllResponseFilters","registerRequestFilter","registerResponseFilter","Promise","resolve","prepareFilters","then","licenseUrl","serviceCertificate","licenseAcquisitionDetails","widevineServiceCertificateUrl","licenseAcquisition","widevine","serviceCertificateUrl","emeAttributes","audioRobustness","videoRobustness","_classification","getEmeAttributes","navigator","configure","drm","servers","com.widevine.alpha","com.microsoft.playready","advanced","serverCertificate","prepareDrm","load","streamUrl","startPosition","catch","err","LOAD_INTERRUPTED","document","unload","getShakaEventHandlers","_ref","streamer","streamRangeHelper","applyProperties","updateStreamState","log","htmlVideoHandlers","getBasicVideoEventHandlers","thirdPartyPlayer","videoElementEventHandlers","pauseStreamRangeUpdater","lifeCycleManager","setStage","_","getStage","shakaEventHandlers","error","_ref2","detail","playbackError","props","onPlaybackError","severity","playState","isBuffering","isSeeking","stop","loading","initialPlaybackProps","_streamer$props$initi","isMuted","volume","muted","isPipAvailable","streaming","_streamer$props$initi2","isPaused","bitrateFix","bitrateCap","pause","_objectSpread","buffering","_ref3","toString","entries","forEach","_ref6","_ref7","_slicedToArray","name","handler","addEventListener","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","setLifeCycleManager","manager","cleanup","_ref4","_ref5","removeEventListener","getBitrateAsBps","track","bandwidth","numericSort","a","b","bandwidthSort","getBitrateAsKbps","ceil","isActiveTrack","active","type","isUnique","item","index","arr","resetConfiguration","abr","enabled","restrictions","maxBandwidth","getShakaBitrateManager","previousBitrates","updateBitrateProps","variantTracks","getVariantTracks","currentBitrate","bitrates","map","sort","updates","isShallowEqual","length","adaptation","trackschanged","shakaBitrateManager_slicedToArray","fixBitrate","bitrate","sortedTracks","slice","desiredVariantTrack","selectVariantTrack","e","matchingTrack","capBitrate","cap","lowestBitrate","max","trackPropKeys","isShakaTrackEqual","Number","isEqual","createSelectableTrack","id","origin","shakaTrack","kind","label","language","supportedContentTypes","isContentTypeSupported","sourceTrack","contentType","ct","getShakaTextTrackManager","managedTextTracks","selectableTextTracks","emptyTracks","getActiveShakaTrack","getTextTracks","update","allProps","currentTextTrack","selectedTrack","isTextTrackVisible","managedSelectedTrack","managedTrack","isBlacklisted","selectableTrack","textTracks","m","emptyManagedTextTrackList","addTracks","tracks","supportedTracks","tracksBeingAdded","newManagedTracks","freshTracks","managedTrackMatches","managedTextTrack","src","addedTrack","isLoaded","loadPromise","charsetPos","substr","addPromise","addTextTrack","trackBeingAdded","shakaLoadPromise","concat","all","nmt","blacklistExistingSideLoadedTracks","setTextTrackVisibility","shakaTracks","newManagedTrackList","isRemoving","texttrackvisibility","shakaTextTrackManager_slicedToArray","handleSelectedTextTrackChange","textTrack","mt","window","setTimeout","fullShakaTrack","updatedTrack","selectTextTrack","handleTextTracksPropChange","Array","isArray","handleSourcePropChange","newTracks","clear","createManagedTrack","role","isTrackMatchingLanguageAndRole","roles","getShakaAudioTrackManager","managedTracks","updateCurrentAudioTrack","activeShakaTrack","currentAudioTrack","updateAudioTracks","audioTracks","getAudioLanguagesAndRoles","shakaAudioTrackManager_slicedToArray","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","selectAudioLanguage","ShakaVideoStreamer","createVideoStreamerComponent","shakaPlayerConfig","installPolyfills","polyfill","installAll","Player","customConfiguration","shakaSetup","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","bitrateManager","getArrayLogger","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","render","renderWithoutSource","destroy","shakaCleanup"],"mappings":"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","file":"static/js/50.f07512da.js","sourcesContent":["// @flow\nimport type { PlayMode } from '../types';\nimport type { ShakaPlayer } from './types';\nimport type { StreamRangeHelper } from '../common/types';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\nconst dvrStartCorrection = 10; // yep, seconds\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: Date,\n  seekRange: { start: number, end: number },\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (isLive) {\n    if (isNaN(startDateTime)) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: new Date(startDateTime.getTime() + (position + seekRange.start) * 1000),\n        absoluteStartPosition: new Date(startDateTime.getTime() + seekRange.start * 1000)\n      };\n    }\n  } else {\n    return {\n      absolutePosition: dawnOfTime,\n      absoluteStartPosition: dawnOfTime\n    };\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n\n  function calculateNewState() {\n    const seekRange = shakaPlayer.seekRange();\n    const isLive = shakaPlayer.isLive();\n    const startDateTime = isLive ? shakaPlayer.getPresentationStartTimeAsDate() : new Date();\n    const position = videoElement.currentTime - seekRange.start;\n    const duration =\n      seekRange.end !== 0 || seekRange.start !== 0\n        ? seekRange.end - seekRange.start\n        : videoElement.duration === Infinity || isNaN(videoElement.duration)\n        ? 0\n        : videoElement.duration;\n\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = isLive && position > duration - liveMargin;\n\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(\n      isLive,\n      startDateTime,\n      seekRange,\n      position\n    );\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    if (videoElement && videoElement.paused && shakaPlayer.isLive()) {\n      const seekableStart = shakaPlayer.seekRange().start || 0;\n      if (seekableStart >= videoElement.currentTime) {\n        videoElement.currentTime = seekableStart + dvrStartCorrection;\n      }\n    }\n  }\n\n  function setPosition(newPosition: number) {\n    if (!(isNaN(newPosition) && newPosition === Infinity)) {\n      videoElement.currentTime = shakaPlayer.seekRange().start + newPosition;\n    }\n  }\n\n  function gotoLive() {\n    if (shakaPlayer.isLive()) {\n      videoElement.currentTime = shakaPlayer.seekRange().end;\n    }\n  }\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { ErrorCode, Severity } from '../types';\nimport shaka from 'shaka-player';\nimport type { ShakaError } from './types';\nimport { PlaybackError } from '../types';\n\nconst errorTechnology = 'shaka';\n\nconst STREAM_ERROR = 'STREAM_ERROR';\nconst STREAM_ERROR_DRM_CLIENT_UNAVAILABLE = 'STREAM_ERROR_DRM_CLIENT_UNAVAILABLE';\nconst STREAM_ERROR_DOWNLOAD = 'STREAM_ERROR_DOWNLOAD';\nconst STREAM_ERROR_DECODE = 'STREAM_ERROR_DECODE';\nconst STREAM_ERROR_DRM_OUTPUT_BLOCKED = 'STREAM_ERROR_DRM_OUTPUT_BLOCKED';\n\nconst errorFromCodeMappings = {\n  '3016': function(shakaError) {\n    if (shakaError.data && shakaError.data[0]) {\n      if (shakaError.data[0] === 3) {\n        return { classification: STREAM_ERROR_DECODE };\n      }\n    }\n    return { classification: STREAM_ERROR };\n  },\n  '4012': { classification: STREAM_ERROR },\n  '6001': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6002': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6003': { classification: STREAM_ERROR },\n  '6007': { classification: STREAM_ERROR_DOWNLOAD },\n  '6008': { classification: STREAM_ERROR_DOWNLOAD },\n  '6013': { classification: STREAM_ERROR },\n  '7000': { classification: '' },\n\n  // Error codes starting with the following digits, are grouped together.\n  '1': { classification: STREAM_ERROR_DOWNLOAD },\n  '2': { classification: STREAM_ERROR_DECODE },\n  '3': { classification: STREAM_ERROR_DECODE },\n  '4': { classification: STREAM_ERROR_DECODE },\n  '5': { classification: STREAM_ERROR_DECODE },\n  '6': { classification: STREAM_ERROR_DECODE }\n};\n\nconst defaultError = { classification: STREAM_ERROR };\n\nfunction reverseLookup(numeric: string | number, mappings: { [string]: string }) {\n  return Object.keys(mappings).filter(key => {\n    return mappings[key] === parseInt(numeric, 10);\n  })[0];\n}\n\nfunction buildMessage(shakaError: ShakaError, classification: ErrorCode) {\n  if (shakaError.code === 1001 && shakaError.data[1] != null) {\n    return 'Shaka request failed with status ' + shakaError.data[1] + ' for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1002) {\n    return 'Shaka request could not be performed for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1003) {\n    return 'Shaka request timed out for URL ' + shakaError.data[0];\n  }\n  if (shakaError.message) {\n    return shakaError.message;\n  }\n  if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE) {\n    return 'Playback of protected content appears to be disabled in the browser.';\n  }\n  if (classification === STREAM_ERROR_DRM_OUTPUT_BLOCKED) {\n    return 'Playback of protected content appears to be disallowed, perhaps due to a non-secure or HDCP-less screen being connected.';\n  }\n  const code = reverseLookup(shakaError.code, shaka.util.Error.Code),\n    category = reverseLookup(shakaError.category, shaka.util.Error.Category);\n  const message = 'Shaka error ' + category + '/' + code + ' reported';\n\n  if (shakaError.data[0]) {\n    if (shakaError.data[0].message) {\n      return message + ': ' + shakaError.data[0].message;\n    } else {\n      return message + ': ' + shakaError.data[0];\n    }\n  } else {\n    return message + ' with no further details.';\n  }\n}\n\nfunction getSeverity(isStarted: boolean, shakaError: ShakaError): Severity {\n  if (shakaError.code === 1001 && shakaError.data) {\n    if (shakaError.data[0] && /\\.ttml|\\.vtt|\\.srt|subtitle/.test(shakaError.data[0])) {\n      // Dirty check for subtitles requests failing. That's not fatal.\n      return 'WARNING';\n    } else if (shakaError.data[1] === 502) {\n      return 'FATAL';\n    }\n  }\n  if (shakaError.code === 4012) {\n    return 'WARNING';\n  }\n  if ((isStarted && shakaError.code < 2000) || shakaError.category === 2) {\n    return 'WARNING';\n  }\n  return 'FATAL';\n}\n\nfunction getFromDeclarativeMapping(shakaError) {\n  if (shakaError.code) {\n    const mapping = errorFromCodeMappings[shakaError.code] || errorFromCodeMappings[Math.floor(shakaError.code / 1000)];\n    if (typeof mapping === 'function') {\n      return mapping(shakaError) || defaultError;\n    } else {\n      return mapping || defaultError;\n    }\n  } else {\n    return defaultError;\n  }\n}\n\nfunction isEmeBlocked(userAgent: string, location: Location) {\n  return (\n    location &&\n    location.protocol === 'http:' &&\n    location.hostname.indexOf('localhost') !== 0 &&\n    userAgent &&\n    userAgent.indexOf('Edge') < 0 &&\n    userAgent.indexOf('Chrome') > 0\n  );\n}\n\nfunction mapShakaError(isStarted: boolean, shakaError: ShakaError, userAgent: string, location: Location) {\n  const classification = getFromDeclarativeMapping(shakaError).classification;\n  if (classification) {\n    if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE && isEmeBlocked(userAgent, location)) {\n      const message = 'DRM playback is blocked in Chrome. Likely reason: This page is not served with HTTPS.';\n      return new PlaybackError(STREAM_ERROR, errorTechnology, message, getSeverity(isStarted, shakaError), shakaError);\n    } else {\n      return new PlaybackError(\n        classification,\n        errorTechnology,\n        buildMessage(shakaError, classification),\n        getSeverity(isStarted, shakaError),\n        shakaError\n      );\n    }\n  } else {\n    return new PlaybackError(\n      STREAM_ERROR,\n      errorTechnology,\n      'Unknown error reported from Shaka Player.',\n      'WARNING',\n      shakaError\n    );\n  }\n}\n\nexport default mapShakaError;\n","// @flow\nimport type { AdvancedPlaybackSource, PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport type { ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport mapShakaError from './shakaErrorMapper';\nimport shaka from 'shaka-player';\nimport normalizeSource from '../common/sourceNormalizer';\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter,\n  configuration?: ?C\n};\n\nfunction getEmeAttributes(userAgent, serviceCertificate) {\n  // For now, only deals with Chrome and Android Chrome distinctions.\n  if (/Android(.*)Chrome/.test(userAgent)) {\n    // Lowest level, SW_SECURE_CRYPTO, also for video.\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_CRYPTO',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Android Chrome 58 and newer'\n    };\n  } else {\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_DECODE',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Desktop'\n    };\n  }\n}\n\nfunction prepareDrm(\n  shakaPlayer: ShakaPlayer,\n  source: AdvancedPlaybackSource,\n  configuration: ?VideoStreamerConfiguration\n) {\n  const licenseUrl = source.licenseUrl;\n  const serviceCertificate =\n    (source.licenseAcquisitionDetails && source.licenseAcquisitionDetails.widevineServiceCertificateUrl) ||\n    (configuration &&\n      configuration.licenseAcquisition &&\n      configuration.licenseAcquisition.widevine &&\n      configuration.licenseAcquisition.widevine.serviceCertificateUrl);\n  const emeAttributes = getEmeAttributes(navigator.userAgent, serviceCertificate);\n  shakaPlayer.configure({\n    drm: {\n      servers: {\n        'com.widevine.alpha': licenseUrl,\n        'com.microsoft.playready': licenseUrl\n      },\n      advanced: {\n        'com.widevine.alpha': {\n          audioRobustness: emeAttributes.audioRobustness,\n          videoRobustness: emeAttributes.videoRobustness,\n          serverCertificate: emeAttributes.serviceCertificate\n        },\n        'com.microsoft.playready': {\n          videoRobustness: 'SW_SECURE_DECODE',\n          audioRobustness: 'SW_SECURE_CRYPTO'\n        }\n      }\n    }\n  });\n  return Promise.resolve();\n}\n\nfunction prepareFilters(\n  shakaPlayer: ShakaPlayer,\n  shakaRequestFilter: ?ShakaRequestFilter,\n  shakaResponseFilter: ?ShakaResponseFilter\n) {\n  const networkingEngine = shakaPlayer.getNetworkingEngine();\n  if (networkingEngine) {\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    if (shakaRequestFilter) {\n      networkingEngine.registerRequestFilter(shakaRequestFilter);\n    }\n    if (shakaResponseFilter) {\n      networkingEngine.registerResponseFilter(shakaResponseFilter);\n    }\n  }\n  // To be leaved for plugging in: Credentials, request headers, license request headers, manifest modification, manifest corrections.\n  return Promise.resolve();\n}\n\nconst getSourceChangeHandler = (shakaPlayer: ShakaPlayer) => <C: VideoStreamerConfiguration, P: Props<C>>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const { shakaRequestFilter, shakaResponseFilter } = nextProps;\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    return prepareFilters(shakaPlayer, shakaRequestFilter, shakaResponseFilter)\n      .then(() => prepareDrm(shakaPlayer, source, nextProps.configuration))\n      .then(() => shakaPlayer.load(source.streamUrl, source.startPosition))\n      .catch(err => {\n        if (err && err.code !== shaka.util.Error.Code.LOAD_INTERRUPTED) {\n          throw mapShakaError(false, err, navigator.userAgent, document.location);\n        }\n      });\n  } else if (prevProps && prevProps.source) {\n    // And no new source.\n    const networkingEngine = shakaPlayer.getNetworkingEngine();\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    return shakaPlayer.unload();\n  } else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport type { ShakaPlayer } from './types';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport mapShakaError from './shakaErrorMapper';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getShakaEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  shakaPlayer,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    thirdPartyPlayer: shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  const shakaEventHandlers = {\n    error: ({ detail }: { detail: any }) => {\n      log && log('shaka.error');\n      const playbackError = mapShakaError(\n        lifeCycleManager.getStage() === 'started',\n        detail,\n        navigator.userAgent,\n        document.location\n      );\n      if (streamer.props.onPlaybackError) {\n        streamer.props.onPlaybackError(playbackError);\n      }\n      if (videoElement.error) {\n        updateStreamState({ error: videoElement.error });\n      }\n      if (playbackError.severity === 'FATAL') {\n        lifeCycleManager.setStage('dead');\n        updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n      }\n      pauseStreamRangeUpdater.stop();\n    },\n    loading: () => {\n      log && log('shaka.loading');\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    streaming: () => {\n      log && log('shaka.streaming');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        applyProperties({ bitrateFix, bitrateCap });\n        if (isPaused) {\n          videoElement.pause();\n        }\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n\n      updateStreamState({\n        isMuted: videoElement.muted,\n        volume: videoElement.volume,\n        ...streamRangeHelper.calculateNewState()\n      });\n    },\n    buffering: ({ buffering }: { buffering: boolean }) => {\n      log && log('shaka.buffering.' + buffering.toString());\n      if (buffering && lifeCycleManager.getStage() === 'started') {\n        updateStreamState({ isBuffering: buffering, playState: 'buffering' });\n      } else {\n        updateStreamState({ isBuffering: buffering });\n      }\n    }\n  };\n\n  function cleanup() {\n    htmlVideoHandlers.cleanup();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager,\n    cleanup\n  };\n};\n\nexport default getShakaEventHandlers;\n","// @flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsBps(track) {\n  return (track && track.bandwidth) || 0;\n}\n\nfunction numericSort(a, b) {\n  return a - b;\n}\n\nfunction bandwidthSort(a: ShakaTrack, b: ShakaTrack) {\n  return a.bandwidth - b.bandwidth;\n}\n\nfunction getBitrateAsKbps(track: ShakaTrack) {\n  return (track && Math.ceil(track.bandwidth / 1000)) || 0;\n}\n\nfunction isActiveTrack(track: ShakaTrack) {\n  return track && track.active && track.type === 'variant';\n}\n\nfunction isUnique(item, index, arr) {\n  return arr.indexOf(item) === index;\n}\n\nconst resetConfiguration = { abr: { enabled: true, restrictions: { maxBandwidth: Infinity } } };\n\nconst getShakaBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n\n  function updateBitrateProps() {\n    let variantTracks: Array<ShakaTrack> = shakaPlayer.getVariantTracks();\n    /*const maxBandwidth = shakaPlayer.getConfiguration().abr['restrictions'] && shakaPlayer.getConfiguration().abr['restrictions'].maxBandwidth;\n    if (maxBandwidth && maxBandwidth !== Infinity && variantTracks.length > previousVariantTracks.length) {\n      variantTracks = previousVariantTracks;\n    }// else {\n    // previousVariantTracks = variantTracks;\n    //}*/\n    const currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    const bitrates = variantTracks\n      .map(getBitrateAsKbps)\n      .filter(isUnique)\n      .sort(numericSort);\n\n    const updates: Object = {};\n    if (currentBitrate) {\n      updates.currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    }\n    if (!isShallowEqual(previousBitrates, bitrates)) {\n      previousBitrates = bitrates;\n      updates.bitrates = bitrates;\n    }\n    if (Object.keys(updates).length > 0) {\n      updateStreamState(updates);\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n      log && log('Resetting restrictions for bitrate.');\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateCap: null });\n    } else {\n      const lowestBitrate = shakaPlayer\n        .getVariantTracks()\n        .map(getBitrateAsBps)\n        .sort(numericSort)[0];\n      if (lowestBitrate) {\n        const maxBandwidth = Math.max(cap * 1000, lowestBitrate);\n        const restrictions = { maxBandwidth };\n        shakaPlayer.configure({ abr: { enabled: true, restrictions: restrictions } });\n        updateStreamState({ bitrateCap: Math.ceil(maxBandwidth / 1000) });\n        if (restrictions.maxBandwidth === lowestBitrate) {\n          log && log('Applying restrictions for bitrate, but aligning to lowest available bitrate.', restrictions);\n        } else {\n          log && log('Applying restrictions for bitrate.', restrictions);\n        }\n      } else {\n        log &&\n          log(\n            'Bitrate range not found. Not safe to applying restrictions for bitrate.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (typeof bitrate === 'string') {\n      try {\n        const sortedTracks = shakaPlayer\n          .getVariantTracks()\n          .slice(0)\n          .sort(bandwidthSort);\n        const desiredVariantTrack =\n          bitrate === 'min' ? sortedTracks[0] : bitrate === 'max' ? sortedTracks[sortedTracks.length - 1] : null;\n        if (desiredVariantTrack) {\n          shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n          shakaPlayer.selectVariantTrack(desiredVariantTrack);\n          updateStreamState({ bitrateFix: getBitrateAsKbps(desiredVariantTrack) });\n        } else {\n          shakaPlayer.configure(resetConfiguration);\n          updateStreamState({ bitrateFix: null });\n          log &&\n            log(\n              'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n              bitrate\n            );\n        }\n      } catch (e) {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Attempting to set ' + bitrate + 'imum bitrate, but no tracks found. A bit too early, maybe?',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    } else if (isNaN(bitrate) || bitrate == null || bitrate < 0 || !bitrate) {\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateFix: null });\n      log && log('Resetting bitrate locking.');\n    } else {\n      const matchingTrack = shakaPlayer.getVariantTracks().filter(function(track) {\n        return getBitrateAsKbps(track) === bitrate;\n      })[0];\n      if (matchingTrack) {\n        shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n        shakaPlayer.selectVariantTrack(matchingTrack);\n        updateStreamState({ bitrateFix: getBitrateAsKbps(matchingTrack) });\n        log && log('Locking at bitrate ' + bitrate + '.', matchingTrack);\n      } else {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Could not finding matching track for specified lock bitrate ' + bitrate + '.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  const shakaEventHandlers = {\n    loading: () => {\n      previousBitrates = [];\n    },\n    streaming: updateBitrateProps,\n    adaptation: updateBitrateProps,\n    trackschanged: updateBitrateProps\n  };\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  return {\n    cleanup,\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getShakaBitrateManager;\n","//@flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { ManagedTextTrack } from '../BasicVideoStreamer/textTrackManager';\nimport type { TextTrackManager } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedShakaTextTrack = ManagedTextTrack & {\n  shakaTrack: ?ShakaTrack,\n  shakaLoadPromise?: Promise<?ShakaTrack>\n};\n\nfunction isEqual(a, b) {\n  return a === b || (a == null && b == null ? true : Number.isNaN(a) && Number.isNaN(b));\n}\n\nconst trackPropKeys = ['id', 'language', 'kind', 'label'];\n\nfunction isShakaTrackEqual(a, b) {\n  return (a && b && trackPropKeys.filter(key => isEqual(a[key], b[key])).length === trackPropKeys.length) || (!a && !b);\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  shakaTrack: ShakaTrack\n): AvailableTrack {\n  const kind = shakaTrack.kind === 'subtitle' ? 'subtitles' : shakaTrack.kind || '';\n  return {\n    id,\n    kind,\n    label: shakaTrack.label || '',\n    language: shakaTrack.language || '',\n    origin\n  };\n}\n\nconst supportedContentTypes = ['text/vtt', 'application/ttml+xml'];\n\nfunction isContentTypeSupported(sourceTrack) {\n  const contentType = sourceTrack.contentType;\n  return contentType && supportedContentTypes.filter(ct => contentType.indexOf(ct) === 0).length > 0;\n}\n\nfunction getShakaTextTrackManager(\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): TextTrackManager {\n  let managedTextTracks: Array<ManagedShakaTextTrack> = [];\n  let selectableTextTracks = emptyTracks;\n\n  function getActiveShakaTrack() {\n    return (shakaPlayer.getTextTracks() || []).filter(track => track.active)[0];\n  }\n\n  function update(allProps: boolean) {\n    let currentTextTrack = null;\n    const selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    if (selectedTrack) {\n      const managedSelectedTrack = managedTextTracks.filter(\n        managedTrack =>\n          !managedTrack.isBlacklisted &&\n          managedTrack.selectableTrack != null &&\n          isShakaTrackEqual(managedTrack.shakaTrack, selectedTrack)\n      )[0];\n      currentTextTrack = managedSelectedTrack ? managedSelectedTrack.selectableTrack : null;\n    }\n    if (allProps) {\n      const textTracks = managedTextTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n      if (isShallowEqual(textTracks, selectableTextTracks)) {\n        // $FlowFixMe Complaints about null entries, despite filter above.\n        updateStreamState({\n          textTracks: selectableTextTracks,\n          currentTextTrack\n        });\n      } else {\n        selectableTextTracks = textTracks;\n        updateStreamState({\n          textTracks,\n          currentTextTrack\n        });\n      }\n    } else {\n      updateStreamState({\n        currentTextTrack\n      });\n    }\n  }\n\n  function emptyManagedTextTrackList() {\n    managedTextTracks.length = 0;\n    update(true);\n  }\n\n  function ingestAndFilterEarlierAddedTracks(sourceTracks: Array<SourceTrack>) {\n    return sourceTracks.filter(sourceTrack => {\n      const managedTrackMatches = managedTextTracks.filter(\n        managedTextTrack =>\n          managedTextTrack.sourceTrack &&\n          managedTextTrack.sourceTrack.src === sourceTrack.src &&\n          managedTextTrack.shakaTrack\n      );\n      if (managedTrackMatches.length === 0) {\n        return true;\n      } else {\n        const addedTrack = managedTrackMatches[0];\n        const shakaTrack = addedTrack.shakaTrack;\n        if (shakaTrack) {\n          addedTrack.sourceTrack = sourceTrack;\n          addedTrack.isBlacklisted = false;\n          addedTrack.isLoaded = true;\n          if (addedTrack.shakaTrack)\n            addedTrack.selectableTrack = createSelectableTrack(\n              addedTrack.shakaTrack.id,\n              'side-loaded',\n              addedTrack.shakaTrack\n            );\n          addedTrack.error = null;\n          addedTrack.loadPromise = Promise.resolve();\n          return false;\n        }\n        return false;\n      }\n    });\n  }\n\n  function updateManagedTrackListFromAddedTracks(tracksBeingAdded) {\n    const newManagedTracks = tracksBeingAdded.map(trackBeingAdded => {\n      const managedTrack: ManagedShakaTextTrack = {\n        id: null,\n        sourceTrack: trackBeingAdded.sourceTrack,\n        shakaTrack: null,\n        isBlacklisted: false, // When a track is explicitly added, we don't assume or check for duplicates, thus blacklisting should not be relevant.\n        isLoaded: false,\n        error: null,\n        selectableTrack: null,\n        shakaLoadPromise: trackBeingAdded.addPromise.then(\n          shakaTrack => {\n            managedTrack.isLoaded = true;\n            managedTrack.shakaTrack = shakaTrack;\n            managedTrack.selectableTrack = createSelectableTrack(shakaTrack.id, 'side-loaded', shakaTrack);\n            return shakaTrack;\n          },\n          error => {\n            managedTrack.error =\n              error || new Error('Shaka rejected adding a track with the URL ' + trackBeingAdded.sourceTrack.src);\n            managedTrack.isBlacklisted = true;\n            managedTrack.isLoaded = true;\n            return null;\n          }\n        )\n      };\n      return managedTrack;\n    });\n    managedTextTracks = managedTextTracks.concat(newManagedTracks);\n    return Promise.all(newManagedTracks.map(nmt => nmt.shakaLoadPromise));\n  }\n\n  function selectShakaTrack(shakaTrack: ?ShakaTrack) {\n    // setTextTrackVisibility() (and some other internal Shaka methods) is not dealing well with different text tracks having the same language code.\n    // This method needs to complete async tasks (promises?) before we can select the correct track.\n    if (shakaTrack) {\n      shakaPlayer.removeEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      if (!shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(true);\n      }\n      window.setTimeout(() => {\n        // Shaka tracks contain incomplete data and an updated version needs to be looked up:\n        const fullShakaTrack = (shakaPlayer.getTextTracks() || []).filter(updatedTrack => {\n          return isShakaTrackEqual(updatedTrack, shakaTrack);\n        })[0];\n        if (fullShakaTrack) {\n          shakaPlayer.selectTextTrack(fullShakaTrack);\n        } else {\n          shakaTrack && shakaPlayer.selectTextTrack(shakaTrack);\n        }\n        update(false);\n        shakaPlayer.addEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      }, 1);\n    } else {\n      if (shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(false);\n      }\n    }\n  }\n\n  function addTracks(tracks: Array<SourceTrack>) {\n    const supportedTracks = tracks.filter(isContentTypeSupported);\n\n    // We don't want updates to videoModel for each track during load.\n    shakaPlayer.removeEventListener('trackschanged', shakaEventHandlers.trackschanged);\n\n    // If the same source track was added earlier, and is readded, then just refurbish and un-blacklist the entry.\n    const freshTracks = ingestAndFilterEarlierAddedTracks(supportedTracks);\n    return updateManagedTrackListFromAddedTracks(\n      freshTracks.map(sourceTrack => {\n        let contentType = sourceTrack.contentType;\n        const charsetPos = contentType ? contentType.indexOf(';charset') : -1;\n        if (charsetPos > 0) {\n          contentType = contentType && contentType.substr(0, charsetPos);\n        }\n        return {\n          addPromise: shakaPlayer.addTextTrack(\n            sourceTrack.src,\n            sourceTrack.language,\n            sourceTrack.kind,\n            contentType,\n            null,\n            sourceTrack.label\n          ),\n          sourceTrack: sourceTrack\n        };\n      })\n    ).then(() => {\n      // Now we are ready again for other track change events coming from the stream etc.\n      shakaPlayer.addEventListener('trackschanged', shakaEventHandlers.trackschanged);\n      update(true);\n    });\n  }\n\n  function updateFromShakaTextTracks() {\n    const shakaTracks = shakaPlayer.getTextTracks() || [];\n    //logger.debug('trackschanged fired.', shakaTracks);\n    if (shakaTracks.length === 0) {\n      // Don't spend CPU cycles comparing the old and new track list when the new list is empty.\n      /*if (managedTextTracks.length === 0) {\n        logger.debug('No Shaka text tracks reported.');\n      } else {\n        logger.debug('No Shaka text tracks reported. Emptying the list.');\n      }*/\n      emptyManagedTextTrackList();\n    } else {\n      // Keep existing managed tracks untouched. This includes blacklisting.\n      const newManagedTrackList = managedTextTracks.filter(managedTrack => {\n        const equalTracks = shakaTracks.filter(shakaTrack => isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack));\n        return equalTracks.length === 1;\n      });\n\n      const isRemoving = newManagedTrackList.length < managedTextTracks.length;\n      const isAdding = shakaTracks.length > newManagedTrackList.length;\n\n      if (isAdding) {\n        const freshTracks = shakaTracks.filter(shakaTrack => {\n          const equalTracks = newManagedTrackList.filter(managedTrack =>\n            isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack)\n          );\n          return equalTracks.length === 0;\n        });\n        const newManagedTracks = freshTracks.map(shakaTrack => ({\n          sourceTrack: null,\n          shakaTrack: shakaTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(shakaTrack.id, 'in-stream', shakaTrack),\n          isLoaded: true,\n          error: null\n        }));\n        managedTextTracks = newManagedTrackList.concat(newManagedTracks);\n        update(true);\n      } else if (isRemoving) {\n        managedTextTracks = newManagedTrackList;\n        update(true);\n      }\n    }\n  }\n\n  function blacklistExistingSideLoadedTracks() {\n    const selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    managedTextTracks\n      .filter(managedTrack => {\n        return managedTrack.sourceTrack != null;\n      })\n      .forEach(managedTrack => {\n        if (managedTrack.selectableTrack) {\n          managedTrack.selectableTrack = null;\n        }\n        if (\n          selectedTrack &&\n          managedTrack.shakaTrack &&\n          managedTrack.shakaTrack.active &&\n          isShakaTrackEqual(selectedTrack, managedTrack.shakaTrack)\n        ) {\n          shakaPlayer.setTextTrackVisibility(false);\n        }\n        managedTrack.isBlacklisted = true;\n      });\n  }\n\n  function handleSourcePropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    const source = normalizeSource(props.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    blacklistExistingSideLoadedTracks();\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    blacklistExistingSideLoadedTracks();\n  }\n\n  function handleSelectedTextTrackChange(textTrack: ?AvailableTrack) {\n    const managedTrack = textTrack && managedTextTracks.filter(mt => mt.selectableTrack === textTrack)[0];\n    selectShakaTrack(managedTrack && managedTrack.shakaTrack);\n  }\n\n  const shakaEventHandlers = {\n    loading: emptyManagedTextTrackList,\n    trackschanged: updateFromShakaTextTracks,\n    texttrackvisibility: () => update(false)\n  };\n\n  function cleanup() {\n    emptyManagedTextTrackList();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n}\n\nexport default getShakaTextTrackManager;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { ShakaLanguageRole, ShakaPlayer, ShakaTrack } from './types';\nimport type { AudioTrackManager } from '../common/types';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedAudioTrack = {\n  language: string,\n  role: string,\n  selectableTrack: AvailableTrack\n};\n\nconst createManagedTrack = ({ language, role }: ShakaLanguageRole, index: number): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: language + role || index,\n      kind: role,\n      label: '',\n      language: language,\n      origin: 'in-stream'\n    },\n    language,\n    role\n  };\n};\n\nconst isTrackMatchingLanguageAndRole = (shakaTrack: ShakaTrack, { language, role }: ShakaLanguageRole) => {\n  return shakaTrack.language === language && (!role || (shakaTrack.roles && shakaTrack.roles.indexOf(role) >= 0));\n};\n\nconst getShakaAudioTrackManager = (\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function updateCurrentAudioTrack() {\n    const activeShakaTrack = shakaPlayer.getVariantTracks().filter(track => track.active)[0];\n    const currentAudioTrack =\n      activeShakaTrack &&\n      managedTracks.filter(mt => isTrackMatchingLanguageAndRole(activeShakaTrack, mt)).map(mt => mt.selectableTrack)[0];\n    updateStreamState({ currentAudioTrack });\n  }\n\n  function updateAudioTracks() {\n    managedTracks = shakaPlayer.getAudioLanguagesAndRoles().map(createManagedTrack);\n    const audioTracks = managedTracks.map(mt => mt.selectableTrack);\n    updateStreamState({\n      audioTracks\n    });\n    updateCurrentAudioTrack();\n  }\n\n  const shakaEventHandlers = {\n    loading: updateAudioTracks,\n    trackschanged: updateAudioTracks,\n    adaptation: updateCurrentAudioTrack\n  };\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      shakaPlayer.selectAudioLanguage(managedTrack.language, managedTrack.role);\n      updateCurrentAudioTrack();\n    }\n  }\n\n  function handleSourceChange() {\n    managedTracks.length = 0;\n  }\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getShakaAudioTrackManager;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport type { ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport { shakaSetup, shakaCleanup } from './shakaSetup';\nimport getStreamRangeHelper from './shakaStreamRangeHelper';\nimport getSourceChangeHandler from './shakaSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport getShakaEventHandlers from './shakaEventHandlers';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getShakaBitrateManager from './shakaBitrateManager';\nimport getShakaTextTrackManager from './shakaTextTrackManager';\nimport getShakaAudioTrackManager from './shakaAudioTrackManager';\n\nexport type ShakaVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  shakaPlayer?: ?{\n    installPolyfills?: boolean,\n    customConfiguration?: any // Actually the config structure that can be passed to shaka.Player::configure.\n  }\n};\n\nexport type ShakaVideoStreamerProps = VideoStreamerImplProps<ShakaVideoStreamerConfiguration> & {\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter\n};\n\nfunction resolveImplementation(\n  streamer: SimplifiedVideoStreamer<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps>,\n  configuration: ?ShakaVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement\n): Promise<StreamerImplementationParts<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps, ShakaPlayer>> {\n  const shakaPlayer = shakaSetup(videoElement, configuration);\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, shakaPlayer, configuration); // S\n  const handleSourceChange = getSourceChangeHandler(shakaPlayer); // S\n  const updateStreamState = getFilteredStreamStateUpdater(streamer); // G\n\n  const textTrackManager = getShakaTextTrackManager(shakaPlayer, updateStreamState);\n  const audioTrackManager = getShakaAudioTrackManager(shakaPlayer, updateStreamState);\n  const bitrateManager = getShakaBitrateManager(\n    streamer,\n    shakaPlayer,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const shakaEventHandlers = getShakaEventHandlers({\n    streamer,\n    videoElement,\n    shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = shakaEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    shakaEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    audioTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    shakaEventHandlers.cleanup();\n    bitrateManager.cleanup();\n    return shakaCleanup(shakaPlayer);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = shakaPlayer;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n}\n\nconst ShakaVideoStreamer = createVideoStreamerComponent('ShakaVideoStreamer', resolveImplementation);\n\nexport default ShakaVideoStreamer;\n","// @flow\nimport type { ShakaPlayer } from './types';\nimport shaka from 'shaka-player';\nimport type { ShakaVideoStreamerConfiguration } from './ShakaVideoStreamer';\n\nexport function shakaSetup(\n  videoElement: HTMLVideoElement,\n  configuration: ?ShakaVideoStreamerConfiguration\n): ShakaPlayer {\n  const shakaPlayerConfig = configuration && configuration.shakaPlayer;\n  if (shakaPlayerConfig && shakaPlayerConfig.installPolyfills) {\n    shaka.polyfill.installAll();\n  }\n  const shakaPlayer = new shaka.Player(videoElement);\n  if (shakaPlayerConfig && shakaPlayerConfig.customConfiguration) {\n    shakaPlayer.configure(shakaPlayerConfig.customConfiguration);\n  }\n  return shakaPlayer;\n}\n\nexport function shakaCleanup(shakaPlayer: ShakaPlayer) {\n  return Promise.resolve(shakaPlayer && shakaPlayer.destroy());\n}\n"],"sourceRoot":""}