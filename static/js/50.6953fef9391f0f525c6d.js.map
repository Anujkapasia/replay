{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaTextTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/ShakaVideoStreamer.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSetup.js"],"names":["dawnOfTime","Date","minimumDvrLength","dvrStartCorrection","getStreamRangeHelper","videoElement","shakaPlayer","configuration","liveMargin","liveEdgeMargin","adjustForDvrStartOffset","paused","isLive","seekableStart","seekRange","start","currentTime","calculateNewState","startDateTime","getPresentationStartTimeAsDate","position","duration","end","Infinity","isNaN","playMode","resolvePlayMode","isAtLiveEdge","_getAbsolutePositions","absolutePosition","absoluteStartPosition","getTime","getAbsolutePositions","setPosition","newPosition","gotoLive","errorTechnology","STREAM_ERROR","STREAM_ERROR_DRM_CLIENT_UNAVAILABLE","STREAM_ERROR_DRM_OUTPUT_BLOCKED","errorFromCodeMappings","3016","shakaError","data","classification","4012","6001","6002","6003","6007","6008","6013","7000","1","2","3","4","5","6","defaultError","reverseLookup","numeric","mappings","Object","keys","filter","key","parseInt","getSeverity","isStarted","code","test","category","mapShakaError","userAgent","location","PlaybackError","mapping","Math","floor","getFromDeclarativeMapping","message","indexOf","protocol","hostname","isEmeBlocked","shaka","util","Error","Code","Category","buildMessage","prepareDrm","source","licenseUrl","details","licenseAcquisitionDetails","serviceCertificate","widevineServiceCertificateUrl","licenseAcquisition","widevine","serviceCertificateUrl","emeAttributes","audioRobustness","videoRobustness","_classification","getEmeAttributes","navigator","licenseRequestHeaders","length","getNetworkingEngine","registerRequestFilter","type","request","net","NetworkingEngine","RequestType","LICENSE","entries","forEach","_ref","_ref2","_slicedToArray","value","headers","addLicenseRequestFilters","configure","drm","servers","com.widevine.alpha","com.microsoft.playready","advanced","serverCertificate","Promise","resolve","getSourceChangeHandler","nextProps","prevProps","shakaRequestFilter","shakaResponseFilter","normalizeSource","networkingEngine","clearAllRequestFilters","clearAllResponseFilters","registerResponseFilter","prepareFilters","then","load","streamUrl","startPosition","catch","err","LOAD_INTERRUPTED","document","unload","getShakaEventHandlers","streamer","streamRangeHelper","applyProperties","updateStreamState","log","htmlVideoHandlers","getBasicVideoEventHandlers","thirdPartyPlayer","videoElementEventHandlers","pauseStreamRangeUpdater","lifeCycleManager","setStage","_","getStage","shakaEventHandlers","error","detail","playbackError","props","onPlaybackError","severity","playState","isBuffering","isSeeking","stop","loading","initialPlaybackProps","_streamer$props$initi","isMuted","volume","muted","isPipAvailable","streaming","_streamer$props$initi2","isPaused","bitrateFix","bitrateCap","pause","_objectSpread","buffering","_ref3","toString","_ref6","_ref7","shakaEventHandlers_slicedToArray","name","handler","addEventListener","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","setLifeCycleManager","manager","cleanup","_ref4","_ref5","removeEventListener","getBitrateAsBps","track","bandwidth","numericSort","a","b","bandwidthSort","getBitrateAsKbps","ceil","isActiveTrack","active","isUnique","item","index","arr","resetConfiguration","abr","enabled","restrictions","maxBandwidth","getShakaBitrateManager","previousBitrates","updateBitrateProps","variantTracks","getVariantTracks","currentBitrate","bitrates","map","sort","updates","isShallowEqual","adaptation","trackschanged","shakaBitrateManager_slicedToArray","fixBitrate","bitrate","sortedTracks","slice","desiredVariantTrack","selectVariantTrack","e","matchingTrack","capBitrate","cap","lowestBitrate","max","trackPropKeys","isShakaTrackEqual","Number","isEqual","createSelectableTrack","id","origin","shakaTrack","kind","label","language","supportedContentTypes","isContentTypeSupported","sourceTrack","contentType","ct","getShakaTextTrackManager","managedTextTracks","selectableTextTracks","emptyTracks","getActiveShakaTrack","getTextTracks","update","allProps","currentTextTrack","selectedTrack","isTextTrackVisible","managedSelectedTrack","managedTrack","isBlacklisted","selectableTrack","textTracks","m","emptyManagedTextTrackList","addTracks","tracks","supportedTracks","tracksBeingAdded","newManagedTracks","freshTracks","managedTrackMatches","managedTextTrack","src","addedTrack","isLoaded","loadPromise","charsetPos","substr","addPromise","addTextTrack","trackBeingAdded","shakaLoadPromise","concat","all","nmt","blacklistExistingSideLoadedTracks","setTextTrackVisibility","shakaTracks","newManagedTrackList","isRemoving","texttrackvisibility","shakaTextTrackManager_slicedToArray","handleSelectedTextTrackChange","textTrack","mt","window","setTimeout","fullShakaTrack","updatedTrack","selectTextTrack","handleTextTracksPropChange","Array","isArray","handleSourcePropChange","newTracks","clear","createManagedTrack","role","isTrackMatchingLanguageAndRole","roles","getShakaAudioTrackManager","managedTracks","updateCurrentAudioTrack","activeShakaTrack","currentAudioTrack","updateAudioTracks","audioTracks","getAudioLanguagesAndRoles","shakaAudioTrackManager_slicedToArray","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","selectAudioLanguage","ShakaVideoStreamer","createVideoStreamerComponent","MediaSource","isTypeSupported","shakaPlayerConfig","installPolyfills","polyfill","installAll","Player","customConfiguration","shakaSetup","reject","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","bitrateManager","getArrayLogger","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","render","renderWithoutSource","destroy","shakaCleanup"],"mappings":"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","file":"static/js/50.8c329de4.js","sourcesContent":["// @flow\nimport type { PlayMode } from '../types';\nimport type { ShakaPlayer } from './types';\nimport type { StreamRangeHelper } from '../common/types';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\nconst dvrStartCorrection = 10; // yep, seconds\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: Date,\n  seekRange: { start: number, end: number },\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (isLive) {\n    if (isNaN(startDateTime)) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: new Date(startDateTime.getTime() + (position + seekRange.start) * 1000),\n        absoluteStartPosition: new Date(startDateTime.getTime() + seekRange.start * 1000)\n      };\n    }\n  } else {\n    return {\n      absolutePosition: dawnOfTime,\n      absoluteStartPosition: dawnOfTime\n    };\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n\n  function calculateNewState() {\n    const seekRange = shakaPlayer.seekRange();\n    const isLive = shakaPlayer.isLive();\n    const startDateTime = isLive ? shakaPlayer.getPresentationStartTimeAsDate() : new Date();\n    const position = videoElement.currentTime - seekRange.start;\n    const duration =\n      seekRange.end !== 0 || seekRange.start !== 0\n        ? seekRange.end - seekRange.start\n        : videoElement.duration === Infinity || isNaN(videoElement.duration)\n        ? 0\n        : videoElement.duration;\n\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = isLive && position > duration - liveMargin;\n\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(\n      isLive,\n      startDateTime,\n      seekRange,\n      position\n    );\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    if (videoElement && videoElement.paused && shakaPlayer.isLive()) {\n      const seekableStart = shakaPlayer.seekRange().start || 0;\n      if (seekableStart >= videoElement.currentTime) {\n        videoElement.currentTime = seekableStart + dvrStartCorrection;\n      }\n    }\n  }\n\n  function setPosition(newPosition: number) {\n    if (!(isNaN(newPosition) && newPosition === Infinity)) {\n      videoElement.currentTime = shakaPlayer.seekRange().start + newPosition;\n    }\n  }\n\n  function gotoLive() {\n    if (shakaPlayer.isLive()) {\n      videoElement.currentTime = shakaPlayer.seekRange().end;\n    }\n  }\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { ErrorCode, Severity } from '../types';\nimport shaka from 'shaka-player';\nimport type { ShakaError } from './types';\nimport { PlaybackError } from '../types';\n\nconst errorTechnology = 'shaka';\n\nconst STREAM_ERROR = 'STREAM_ERROR';\nconst STREAM_ERROR_DRM_CLIENT_UNAVAILABLE = 'STREAM_ERROR_DRM_CLIENT_UNAVAILABLE';\nconst STREAM_ERROR_DOWNLOAD = 'STREAM_ERROR_DOWNLOAD';\nconst STREAM_ERROR_DECODE = 'STREAM_ERROR_DECODE';\nconst STREAM_ERROR_DRM_OUTPUT_BLOCKED = 'STREAM_ERROR_DRM_OUTPUT_BLOCKED';\n\nconst errorFromCodeMappings = {\n  '3016': function(shakaError) {\n    if (shakaError.data && shakaError.data[0]) {\n      if (shakaError.data[0] === 3) {\n        return { classification: STREAM_ERROR_DECODE };\n      }\n    }\n    return { classification: STREAM_ERROR };\n  },\n  '4012': { classification: STREAM_ERROR },\n  '6001': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6002': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6003': { classification: STREAM_ERROR },\n  '6007': { classification: STREAM_ERROR_DOWNLOAD },\n  '6008': { classification: STREAM_ERROR_DOWNLOAD },\n  '6013': { classification: STREAM_ERROR },\n  '7000': { classification: '' },\n\n  // Error codes starting with the following digits, are grouped together.\n  '1': { classification: STREAM_ERROR_DOWNLOAD },\n  '2': { classification: STREAM_ERROR_DECODE },\n  '3': { classification: STREAM_ERROR_DECODE },\n  '4': { classification: STREAM_ERROR_DECODE },\n  '5': { classification: STREAM_ERROR_DECODE },\n  '6': { classification: STREAM_ERROR_DECODE }\n};\n\nconst defaultError = { classification: STREAM_ERROR };\n\nfunction reverseLookup(numeric: string | number, mappings: { [string]: string }) {\n  return Object.keys(mappings).filter(key => {\n    return mappings[key] === parseInt(numeric, 10);\n  })[0];\n}\n\nfunction buildMessage(shakaError: ShakaError, classification: ErrorCode) {\n  if (shakaError.code === 1001 && shakaError.data[1] != null) {\n    return 'Shaka request failed with status ' + shakaError.data[1] + ' for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1002) {\n    return 'Shaka request could not be performed for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1003) {\n    return 'Shaka request timed out for URL ' + shakaError.data[0];\n  }\n  if (shakaError.message) {\n    return shakaError.message;\n  }\n  if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE) {\n    return 'Playback of protected content appears to be disabled in the browser.';\n  }\n  if (classification === STREAM_ERROR_DRM_OUTPUT_BLOCKED) {\n    return 'Playback of protected content appears to be disallowed, perhaps due to a non-secure or HDCP-less screen being connected.';\n  }\n  const code = reverseLookup(shakaError.code, shaka.util.Error.Code),\n    category = reverseLookup(shakaError.category, shaka.util.Error.Category);\n  const message = 'Shaka error ' + category + '/' + code + ' reported';\n\n  if (shakaError.data[0]) {\n    if (shakaError.data[0].message) {\n      return message + ': ' + shakaError.data[0].message;\n    } else {\n      return message + ': ' + shakaError.data[0];\n    }\n  } else {\n    return message + ' with no further details.';\n  }\n}\n\nfunction getSeverity(isStarted: boolean, shakaError: ShakaError): Severity {\n  if (shakaError.code === 1001 && shakaError.data) {\n    if (shakaError.data[0] && /\\.ttml|\\.vtt|\\.srt|subtitle/.test(shakaError.data[0])) {\n      // Dirty check for subtitles requests failing. That's not fatal.\n      return 'WARNING';\n    } else if (shakaError.data[1] === 502) {\n      return 'FATAL';\n    }\n  }\n  if (shakaError.code === 4012) {\n    return 'WARNING';\n  }\n  if ((isStarted && shakaError.code < 2000) || shakaError.category === 2) {\n    return 'WARNING';\n  }\n  return 'FATAL';\n}\n\nfunction getFromDeclarativeMapping(shakaError) {\n  if (shakaError.code) {\n    const mapping = errorFromCodeMappings[shakaError.code] || errorFromCodeMappings[Math.floor(shakaError.code / 1000)];\n    if (typeof mapping === 'function') {\n      return mapping(shakaError) || defaultError;\n    } else {\n      return mapping || defaultError;\n    }\n  } else {\n    return defaultError;\n  }\n}\n\nfunction isEmeBlocked(userAgent: ?string, location: ?Location) {\n  return (\n    location &&\n    location.protocol === 'http:' &&\n    location.hostname.indexOf('localhost') !== 0 &&\n    userAgent &&\n    userAgent.indexOf('Edge') < 0 &&\n    userAgent.indexOf('Chrome') > 0\n  );\n}\n\nfunction mapShakaError(isStarted: boolean, shakaError: ShakaError, userAgent?: string, location?: Location) {\n  if (shakaError instanceof PlaybackError) {\n    return shakaError;\n  }\n  const classification = getFromDeclarativeMapping(shakaError).classification;\n  if ((shakaError.message || '').indexOf('MediaSource') >= 0) {\n    return new PlaybackError(\n      'STREAM_ERROR_TECHNOLOGY_UNSUPPORTED',\n      'shaka',\n      'This browser does not support playing MPEG-DASH streams with Shaka Player.',\n      'FATAL',\n      shakaError\n    );\n  } else if (classification) {\n    if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE && isEmeBlocked(userAgent, location)) {\n      const message = 'DRM playback is blocked in Chrome. Likely reason: This page is not served with HTTPS.';\n      return new PlaybackError(STREAM_ERROR, errorTechnology, message, getSeverity(isStarted, shakaError), shakaError);\n    } else {\n      return new PlaybackError(\n        classification,\n        errorTechnology,\n        buildMessage(shakaError, classification),\n        getSeverity(isStarted, shakaError),\n        shakaError\n      );\n    }\n  } else {\n    return new PlaybackError(\n      STREAM_ERROR,\n      errorTechnology,\n      'Unknown error reported from Shaka Player.',\n      'WARNING',\n      shakaError\n    );\n  }\n}\n\nexport default mapShakaError;\n","// @flow\nimport type { AdvancedPlaybackSource, PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport type { ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport mapShakaError from './shakaErrorMapper';\nimport shaka from 'shaka-player';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter,\n  configuration?: ?C\n};\n\nfunction getEmeAttributes(userAgent, serviceCertificate) {\n  // For now, only deals with Chrome and Android Chrome distinctions.\n  if (/Android(.*)Chrome/.test(userAgent)) {\n    // Lowest level, SW_SECURE_CRYPTO, also for video.\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_CRYPTO',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Android Chrome 58 and newer'\n    };\n  } else {\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_DECODE',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Desktop'\n    };\n  }\n}\n\nfunction addLicenseRequestFilters(shakaPlayer: ShakaPlayer, licenseRequestHeaders: { [string]: string }) {\n  shakaPlayer.getNetworkingEngine().registerRequestFilter((type: string, request) => {\n    if (type === shaka.net.NetworkingEngine.RequestType.LICENSE) {\n      Object.entries(licenseRequestHeaders).forEach(([key: string, value: string]) => {\n        request.headers[key] = value;\n      });\n    }\n  });\n}\n\nfunction prepareDrm(\n  shakaPlayer: ShakaPlayer,\n  source: AdvancedPlaybackSource,\n  configuration: ?VideoStreamerConfiguration\n) {\n  const licenseUrl = source.licenseUrl;\n  const details = source.licenseAcquisitionDetails || {};\n  const serviceCertificate =\n    details.widevineServiceCertificateUrl ||\n    (configuration &&\n      configuration.licenseAcquisition &&\n      configuration.licenseAcquisition.widevine &&\n      configuration.licenseAcquisition.widevine.serviceCertificateUrl);\n  const emeAttributes = getEmeAttributes(navigator.userAgent, serviceCertificate);\n  const { licenseRequestHeaders } = details;\n  if (licenseRequestHeaders && Object.keys(licenseRequestHeaders).length > 0) {\n    addLicenseRequestFilters(shakaPlayer, licenseRequestHeaders);\n  }\n  shakaPlayer.configure({\n    drm: {\n      servers: {\n        'com.widevine.alpha': licenseUrl,\n        'com.microsoft.playready': licenseUrl\n      },\n      advanced: {\n        'com.widevine.alpha': {\n          audioRobustness: emeAttributes.audioRobustness,\n          videoRobustness: emeAttributes.videoRobustness,\n          serverCertificate: emeAttributes.serviceCertificate\n        },\n        'com.microsoft.playready': {\n          videoRobustness: 'SW_SECURE_DECODE',\n          audioRobustness: 'SW_SECURE_CRYPTO'\n        }\n      }\n    }\n  });\n  return Promise.resolve();\n}\n\nfunction prepareFilters(\n  shakaPlayer: ShakaPlayer,\n  shakaRequestFilter: ?ShakaRequestFilter,\n  shakaResponseFilter: ?ShakaResponseFilter\n) {\n  const networkingEngine = shakaPlayer.getNetworkingEngine();\n  if (networkingEngine) {\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    if (shakaRequestFilter) {\n      networkingEngine.registerRequestFilter(shakaRequestFilter);\n    }\n    if (shakaResponseFilter) {\n      networkingEngine.registerResponseFilter(shakaResponseFilter);\n    }\n  }\n  // To be leaved for plugging in: Credentials, request headers, license request headers, manifest modification, manifest corrections.\n  return Promise.resolve();\n}\n\nconst getSourceChangeHandler = (shakaPlayer: ShakaPlayer) => <C: VideoStreamerConfiguration, P: Props<C>>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const { shakaRequestFilter, shakaResponseFilter } = nextProps;\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    return prepareFilters(shakaPlayer, shakaRequestFilter, shakaResponseFilter)\n      .then(() => prepareDrm(shakaPlayer, source, nextProps.configuration))\n      .then(() => shakaPlayer.load(source.streamUrl, source.startPosition))\n      .catch(err => {\n        if (err && err.code !== shaka.util.Error.Code.LOAD_INTERRUPTED) {\n          throw mapShakaError(false, err, navigator.userAgent, document.location);\n        }\n      });\n  } else if (prevProps && prevProps.source) {\n    // And no new source.\n    const networkingEngine = shakaPlayer.getNetworkingEngine();\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    return shakaPlayer.unload();\n  } else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport type { ShakaPlayer } from './types';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport mapShakaError from './shakaErrorMapper';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getShakaEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  shakaPlayer,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    thirdPartyPlayer: shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  const shakaEventHandlers = {\n    error: ({ detail }: { detail: any }) => {\n      log && log('shaka.error');\n      const playbackError = mapShakaError(\n        lifeCycleManager.getStage() === 'started',\n        detail,\n        navigator.userAgent,\n        document.location\n      );\n      if (streamer.props.onPlaybackError) {\n        streamer.props.onPlaybackError(playbackError);\n      }\n      if (videoElement.error) {\n        updateStreamState({ error: videoElement.error });\n      }\n      if (playbackError.severity === 'FATAL') {\n        lifeCycleManager.setStage('dead');\n        updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n      }\n      pauseStreamRangeUpdater.stop();\n    },\n    loading: () => {\n      log && log('shaka.loading');\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    streaming: () => {\n      log && log('shaka.streaming');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        applyProperties({ bitrateFix, bitrateCap });\n        if (isPaused) {\n          videoElement.pause();\n        }\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n\n      updateStreamState({\n        isMuted: videoElement.muted,\n        volume: videoElement.volume,\n        ...streamRangeHelper.calculateNewState()\n      });\n    },\n    buffering: ({ buffering }: { buffering: boolean }) => {\n      log && log('shaka.buffering.' + buffering.toString());\n      if (buffering && lifeCycleManager.getStage() === 'started') {\n        updateStreamState({ isBuffering: buffering, playState: 'buffering' });\n      } else {\n        updateStreamState({ isBuffering: buffering });\n      }\n    }\n  };\n\n  function cleanup() {\n    htmlVideoHandlers.cleanup();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager,\n    cleanup\n  };\n};\n\nexport default getShakaEventHandlers;\n","// @flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsBps(track) {\n  return (track && track.bandwidth) || 0;\n}\n\nfunction numericSort(a, b) {\n  return a - b;\n}\n\nfunction bandwidthSort(a: ShakaTrack, b: ShakaTrack) {\n  return a.bandwidth - b.bandwidth;\n}\n\nfunction getBitrateAsKbps(track: ShakaTrack) {\n  return (track && Math.ceil(track.bandwidth / 1000)) || 0;\n}\n\nfunction isActiveTrack(track: ShakaTrack) {\n  return track && track.active && track.type === 'variant';\n}\n\nfunction isUnique(item, index, arr) {\n  return arr.indexOf(item) === index;\n}\n\nconst resetConfiguration = { abr: { enabled: true, restrictions: { maxBandwidth: Infinity } } };\n\nconst getShakaBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n\n  function updateBitrateProps() {\n    let variantTracks: Array<ShakaTrack> = shakaPlayer.getVariantTracks();\n    /*const maxBandwidth = shakaPlayer.getConfiguration().abr['restrictions'] && shakaPlayer.getConfiguration().abr['restrictions'].maxBandwidth;\n    if (maxBandwidth && maxBandwidth !== Infinity && variantTracks.length > previousVariantTracks.length) {\n      variantTracks = previousVariantTracks;\n    }// else {\n    // previousVariantTracks = variantTracks;\n    //}*/\n    const currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    const bitrates = variantTracks\n      .map(getBitrateAsKbps)\n      .filter(isUnique)\n      .sort(numericSort);\n\n    const updates: Object = {};\n    if (currentBitrate) {\n      updates.currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    }\n    if (!isShallowEqual(previousBitrates, bitrates)) {\n      previousBitrates = bitrates;\n      updates.bitrates = bitrates;\n    }\n    if (Object.keys(updates).length > 0) {\n      updateStreamState(updates);\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n      log && log('Resetting restrictions for bitrate.');\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateCap: null });\n    } else {\n      const lowestBitrate = shakaPlayer\n        .getVariantTracks()\n        .map(getBitrateAsBps)\n        .sort(numericSort)[0];\n      if (lowestBitrate) {\n        const maxBandwidth = Math.max(cap * 1000, lowestBitrate);\n        const restrictions = { maxBandwidth };\n        shakaPlayer.configure({ abr: { enabled: true, restrictions: restrictions } });\n        updateStreamState({ bitrateCap: Math.ceil(maxBandwidth / 1000) });\n        if (restrictions.maxBandwidth === lowestBitrate) {\n          log && log('Applying restrictions for bitrate, but aligning to lowest available bitrate.', restrictions);\n        } else {\n          log && log('Applying restrictions for bitrate.', restrictions);\n        }\n      } else {\n        log &&\n          log(\n            'Bitrate range not found. Not safe to applying restrictions for bitrate.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (typeof bitrate === 'string') {\n      try {\n        const sortedTracks = shakaPlayer\n          .getVariantTracks()\n          .slice(0)\n          .sort(bandwidthSort);\n        const desiredVariantTrack =\n          bitrate === 'min' ? sortedTracks[0] : bitrate === 'max' ? sortedTracks[sortedTracks.length - 1] : null;\n        if (desiredVariantTrack) {\n          shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n          shakaPlayer.selectVariantTrack(desiredVariantTrack);\n          updateStreamState({ bitrateFix: getBitrateAsKbps(desiredVariantTrack) });\n        } else {\n          shakaPlayer.configure(resetConfiguration);\n          updateStreamState({ bitrateFix: null });\n          log &&\n            log(\n              'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n              bitrate\n            );\n        }\n      } catch (e) {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Attempting to set ' + bitrate + 'imum bitrate, but no tracks found. A bit too early, maybe?',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    } else if (isNaN(bitrate) || bitrate == null || bitrate < 0 || !bitrate) {\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateFix: null });\n      log && log('Resetting bitrate locking.');\n    } else {\n      const matchingTrack = shakaPlayer.getVariantTracks().filter(function(track) {\n        return getBitrateAsKbps(track) === bitrate;\n      })[0];\n      if (matchingTrack) {\n        shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n        shakaPlayer.selectVariantTrack(matchingTrack);\n        updateStreamState({ bitrateFix: getBitrateAsKbps(matchingTrack) });\n        log && log('Locking at bitrate ' + bitrate + '.', matchingTrack);\n      } else {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Could not finding matching track for specified lock bitrate ' + bitrate + '.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  const shakaEventHandlers = {\n    loading: () => {\n      previousBitrates = [];\n    },\n    streaming: updateBitrateProps,\n    adaptation: updateBitrateProps,\n    trackschanged: updateBitrateProps\n  };\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  return {\n    cleanup,\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getShakaBitrateManager;\n","//@flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { ManagedTextTrack } from '../BasicVideoStreamer/textTrackManager';\nimport type { TextTrackManager } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedShakaTextTrack = ManagedTextTrack & {\n  shakaTrack: ?ShakaTrack,\n  shakaLoadPromise?: Promise<?ShakaTrack>\n};\n\nfunction isEqual(a, b) {\n  return a === b || (a == null && b == null ? true : Number.isNaN(a) && Number.isNaN(b));\n}\n\nconst trackPropKeys = ['id', 'language', 'kind', 'label'];\n\nfunction isShakaTrackEqual(a, b) {\n  return (a && b && trackPropKeys.filter(key => isEqual(a[key], b[key])).length === trackPropKeys.length) || (!a && !b);\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  shakaTrack: ShakaTrack\n): AvailableTrack {\n  const kind = shakaTrack.kind === 'subtitle' ? 'subtitles' : shakaTrack.kind || '';\n  return {\n    id,\n    kind,\n    label: shakaTrack.label || '',\n    language: shakaTrack.language || '',\n    origin\n  };\n}\n\nconst supportedContentTypes = ['text/vtt', 'application/ttml+xml'];\n\nfunction isContentTypeSupported(sourceTrack) {\n  const contentType = sourceTrack.contentType;\n  return contentType && supportedContentTypes.filter(ct => contentType.indexOf(ct) === 0).length > 0;\n}\n\nfunction getShakaTextTrackManager(\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): TextTrackManager {\n  let managedTextTracks: Array<ManagedShakaTextTrack> = [];\n  let selectableTextTracks = emptyTracks;\n\n  function getActiveShakaTrack() {\n    return (shakaPlayer.getTextTracks() || []).filter(track => track.active)[0];\n  }\n\n  function update(allProps: boolean) {\n    let currentTextTrack = null;\n    const selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    if (selectedTrack) {\n      const managedSelectedTrack = managedTextTracks.filter(\n        managedTrack =>\n          !managedTrack.isBlacklisted &&\n          managedTrack.selectableTrack != null &&\n          isShakaTrackEqual(managedTrack.shakaTrack, selectedTrack)\n      )[0];\n      currentTextTrack = managedSelectedTrack ? managedSelectedTrack.selectableTrack : null;\n    }\n    if (allProps) {\n      const textTracks = managedTextTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n      if (isShallowEqual(textTracks, selectableTextTracks)) {\n        // $FlowFixMe Complaints about null entries, despite filter above.\n        updateStreamState({\n          textTracks: selectableTextTracks,\n          currentTextTrack\n        });\n      } else {\n        selectableTextTracks = textTracks;\n        updateStreamState({\n          textTracks,\n          currentTextTrack\n        });\n      }\n    } else {\n      updateStreamState({\n        currentTextTrack\n      });\n    }\n  }\n\n  function emptyManagedTextTrackList() {\n    managedTextTracks.length = 0;\n    update(true);\n  }\n\n  function ingestAndFilterEarlierAddedTracks(sourceTracks: Array<SourceTrack>) {\n    return sourceTracks.filter(sourceTrack => {\n      const managedTrackMatches = managedTextTracks.filter(\n        managedTextTrack =>\n          managedTextTrack.sourceTrack &&\n          managedTextTrack.sourceTrack.src === sourceTrack.src &&\n          managedTextTrack.shakaTrack\n      );\n      if (managedTrackMatches.length === 0) {\n        return true;\n      } else {\n        const addedTrack = managedTrackMatches[0];\n        const shakaTrack = addedTrack.shakaTrack;\n        if (shakaTrack) {\n          addedTrack.sourceTrack = sourceTrack;\n          addedTrack.isBlacklisted = false;\n          addedTrack.isLoaded = true;\n          if (addedTrack.shakaTrack)\n            addedTrack.selectableTrack = createSelectableTrack(\n              addedTrack.shakaTrack.id,\n              'side-loaded',\n              addedTrack.shakaTrack\n            );\n          addedTrack.error = null;\n          addedTrack.loadPromise = Promise.resolve();\n          return false;\n        }\n        return false;\n      }\n    });\n  }\n\n  function updateManagedTrackListFromAddedTracks(tracksBeingAdded) {\n    const newManagedTracks = tracksBeingAdded.map(trackBeingAdded => {\n      const managedTrack: ManagedShakaTextTrack = {\n        id: null,\n        sourceTrack: trackBeingAdded.sourceTrack,\n        shakaTrack: null,\n        isBlacklisted: false, // When a track is explicitly added, we don't assume or check for duplicates, thus blacklisting should not be relevant.\n        isLoaded: false,\n        error: null,\n        selectableTrack: null,\n        shakaLoadPromise: trackBeingAdded.addPromise.then(\n          shakaTrack => {\n            managedTrack.isLoaded = true;\n            managedTrack.shakaTrack = shakaTrack;\n            managedTrack.selectableTrack = createSelectableTrack(shakaTrack.id, 'side-loaded', shakaTrack);\n            return shakaTrack;\n          },\n          error => {\n            managedTrack.error =\n              error || new Error('Shaka rejected adding a track with the URL ' + trackBeingAdded.sourceTrack.src);\n            managedTrack.isBlacklisted = true;\n            managedTrack.isLoaded = true;\n            return null;\n          }\n        )\n      };\n      return managedTrack;\n    });\n    managedTextTracks = managedTextTracks.concat(newManagedTracks);\n    return Promise.all(newManagedTracks.map(nmt => nmt.shakaLoadPromise));\n  }\n\n  function selectShakaTrack(shakaTrack: ?ShakaTrack) {\n    // setTextTrackVisibility() (and some other internal Shaka methods) is not dealing well with different text tracks having the same language code.\n    // This method needs to complete async tasks (promises?) before we can select the correct track.\n    if (shakaTrack) {\n      shakaPlayer.removeEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      if (!shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(true);\n      }\n      window.setTimeout(() => {\n        // Shaka tracks contain incomplete data and an updated version needs to be looked up:\n        const fullShakaTrack = (shakaPlayer.getTextTracks() || []).filter(updatedTrack => {\n          return isShakaTrackEqual(updatedTrack, shakaTrack);\n        })[0];\n        if (fullShakaTrack) {\n          shakaPlayer.selectTextTrack(fullShakaTrack);\n        } else {\n          shakaTrack && shakaPlayer.selectTextTrack(shakaTrack);\n        }\n        update(false);\n        shakaPlayer.addEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      }, 1);\n    } else {\n      if (shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(false);\n      }\n    }\n  }\n\n  function addTracks(tracks: Array<SourceTrack>) {\n    const supportedTracks = tracks.filter(isContentTypeSupported);\n\n    // We don't want updates to videoModel for each track during load.\n    shakaPlayer.removeEventListener('trackschanged', shakaEventHandlers.trackschanged);\n\n    // If the same source track was added earlier, and is readded, then just refurbish and un-blacklist the entry.\n    const freshTracks = ingestAndFilterEarlierAddedTracks(supportedTracks);\n    return updateManagedTrackListFromAddedTracks(\n      freshTracks.map(sourceTrack => {\n        let contentType = sourceTrack.contentType;\n        const charsetPos = contentType ? contentType.indexOf(';charset') : -1;\n        if (charsetPos > 0) {\n          contentType = contentType && contentType.substr(0, charsetPos);\n        }\n        return {\n          addPromise: shakaPlayer.addTextTrack(\n            sourceTrack.src,\n            sourceTrack.language,\n            sourceTrack.kind,\n            contentType,\n            null,\n            sourceTrack.label\n          ),\n          sourceTrack: sourceTrack\n        };\n      })\n    ).then(() => {\n      // Now we are ready again for other track change events coming from the stream etc.\n      shakaPlayer.addEventListener('trackschanged', shakaEventHandlers.trackschanged);\n      update(true);\n    });\n  }\n\n  function updateFromShakaTextTracks() {\n    const shakaTracks = shakaPlayer.getTextTracks() || [];\n    //logger.debug('trackschanged fired.', shakaTracks);\n    if (shakaTracks.length === 0) {\n      // Don't spend CPU cycles comparing the old and new track list when the new list is empty.\n      /*if (managedTextTracks.length === 0) {\n        logger.debug('No Shaka text tracks reported.');\n      } else {\n        logger.debug('No Shaka text tracks reported. Emptying the list.');\n      }*/\n      emptyManagedTextTrackList();\n    } else {\n      // Keep existing managed tracks untouched. This includes blacklisting.\n      const newManagedTrackList = managedTextTracks.filter(managedTrack => {\n        const equalTracks = shakaTracks.filter(shakaTrack => isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack));\n        return equalTracks.length === 1;\n      });\n\n      const isRemoving = newManagedTrackList.length < managedTextTracks.length;\n      const isAdding = shakaTracks.length > newManagedTrackList.length;\n\n      if (isAdding) {\n        const freshTracks = shakaTracks.filter(shakaTrack => {\n          const equalTracks = newManagedTrackList.filter(managedTrack =>\n            isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack)\n          );\n          return equalTracks.length === 0;\n        });\n        const newManagedTracks = freshTracks.map(shakaTrack => ({\n          sourceTrack: null,\n          shakaTrack: shakaTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(shakaTrack.id, 'in-stream', shakaTrack),\n          isLoaded: true,\n          error: null\n        }));\n        managedTextTracks = newManagedTrackList.concat(newManagedTracks);\n        update(true);\n      } else if (isRemoving) {\n        managedTextTracks = newManagedTrackList;\n        update(true);\n      }\n    }\n  }\n\n  function blacklistExistingSideLoadedTracks() {\n    const selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    managedTextTracks\n      .filter(managedTrack => {\n        return managedTrack.sourceTrack != null;\n      })\n      .forEach(managedTrack => {\n        if (managedTrack.selectableTrack) {\n          managedTrack.selectableTrack = null;\n        }\n        if (\n          selectedTrack &&\n          managedTrack.shakaTrack &&\n          managedTrack.shakaTrack.active &&\n          isShakaTrackEqual(selectedTrack, managedTrack.shakaTrack)\n        ) {\n          shakaPlayer.setTextTrackVisibility(false);\n        }\n        managedTrack.isBlacklisted = true;\n      });\n  }\n\n  function handleSourcePropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    const source = normalizeSource(props.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    blacklistExistingSideLoadedTracks();\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    blacklistExistingSideLoadedTracks();\n  }\n\n  function handleSelectedTextTrackChange(textTrack: ?AvailableTrack) {\n    const managedTrack = textTrack && managedTextTracks.filter(mt => mt.selectableTrack === textTrack)[0];\n    selectShakaTrack(managedTrack && managedTrack.shakaTrack);\n  }\n\n  const shakaEventHandlers = {\n    loading: emptyManagedTextTrackList,\n    trackschanged: updateFromShakaTextTracks,\n    texttrackvisibility: () => update(false)\n  };\n\n  function cleanup() {\n    emptyManagedTextTrackList();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n}\n\nexport default getShakaTextTrackManager;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { ShakaLanguageRole, ShakaPlayer, ShakaTrack } from './types';\nimport type { AudioTrackManager } from '../common/types';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedAudioTrack = {\n  language: string,\n  role: string,\n  selectableTrack: AvailableTrack\n};\n\nconst createManagedTrack = ({ language, role }: ShakaLanguageRole, index: number): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: language + role || index,\n      kind: role,\n      label: '',\n      language: language,\n      origin: 'in-stream'\n    },\n    language,\n    role\n  };\n};\n\nconst isTrackMatchingLanguageAndRole = (shakaTrack: ShakaTrack, { language, role }: ShakaLanguageRole) => {\n  return shakaTrack.language === language && (!role || (shakaTrack.roles && shakaTrack.roles.indexOf(role) >= 0));\n};\n\nconst getShakaAudioTrackManager = (\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function updateCurrentAudioTrack() {\n    const activeShakaTrack = shakaPlayer.getVariantTracks().filter(track => track.active)[0];\n    const currentAudioTrack =\n      activeShakaTrack &&\n      managedTracks.filter(mt => isTrackMatchingLanguageAndRole(activeShakaTrack, mt)).map(mt => mt.selectableTrack)[0];\n    updateStreamState({ currentAudioTrack });\n  }\n\n  function updateAudioTracks() {\n    managedTracks = shakaPlayer.getAudioLanguagesAndRoles().map(createManagedTrack);\n    const audioTracks = managedTracks.map(mt => mt.selectableTrack);\n    updateStreamState({\n      audioTracks\n    });\n    updateCurrentAudioTrack();\n  }\n\n  const shakaEventHandlers = {\n    loading: updateAudioTracks,\n    trackschanged: updateAudioTracks,\n    adaptation: updateCurrentAudioTrack\n  };\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      shakaPlayer.selectAudioLanguage(managedTrack.language, managedTrack.role);\n      updateCurrentAudioTrack();\n    }\n  }\n\n  function handleSourceChange() {\n    managedTracks.length = 0;\n  }\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getShakaAudioTrackManager;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport type { ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport { shakaSetup, shakaCleanup } from './shakaSetup';\nimport getStreamRangeHelper from './shakaStreamRangeHelper';\nimport getSourceChangeHandler from './shakaSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport getShakaEventHandlers from './shakaEventHandlers';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getShakaBitrateManager from './shakaBitrateManager';\nimport getShakaTextTrackManager from './shakaTextTrackManager';\nimport getShakaAudioTrackManager from './shakaAudioTrackManager';\nimport mapShakaError from './shakaErrorMapper';\n\nexport type ShakaVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  shakaPlayer?: ?{\n    installPolyfills?: boolean,\n    customConfiguration?: any // Actually the config structure that can be passed to shaka.Player::configure.\n  }\n};\n\nexport type ShakaVideoStreamerProps = VideoStreamerImplProps<ShakaVideoStreamerConfiguration> & {\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter\n};\n\nfunction resolveImplementation(\n  streamer: SimplifiedVideoStreamer<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps>,\n  configuration: ?ShakaVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement\n): Promise<StreamerImplementationParts<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps, ShakaPlayer>> {\n  let shakaPlayer;\n  try {\n    shakaPlayer = shakaSetup(videoElement, configuration);\n  } catch (e) {\n    return Promise.reject(mapShakaError(false, e));\n  }\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, shakaPlayer, configuration); // S\n  const handleSourceChange = getSourceChangeHandler(shakaPlayer); // S\n  const updateStreamState = getFilteredStreamStateUpdater(streamer); // G\n\n  const textTrackManager = getShakaTextTrackManager(shakaPlayer, updateStreamState);\n  const audioTrackManager = getShakaAudioTrackManager(shakaPlayer, updateStreamState);\n  const bitrateManager = getShakaBitrateManager(\n    streamer,\n    shakaPlayer,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const shakaEventHandlers = getShakaEventHandlers({\n    streamer,\n    videoElement,\n    shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = shakaEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    shakaEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    audioTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    shakaEventHandlers.cleanup();\n    bitrateManager.cleanup();\n    return shakaCleanup(shakaPlayer);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = shakaPlayer;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n}\n\nconst ShakaVideoStreamer = createVideoStreamerComponent('ShakaVideoStreamer', resolveImplementation);\n\nexport default ShakaVideoStreamer;\n","// @flow\nimport type { ShakaPlayer } from './types';\nimport shaka from 'shaka-player';\nimport type { ShakaVideoStreamerConfiguration } from './ShakaVideoStreamer';\nimport { PlaybackError } from '../types';\n\nexport function shakaSetup(\n  videoElement: HTMLVideoElement,\n  configuration: ?ShakaVideoStreamerConfiguration\n): ShakaPlayer {\n  if (!!window.MediaSource && !!MediaSource.isTypeSupported) {\n    const shakaPlayerConfig = configuration && configuration.shakaPlayer;\n    if (shakaPlayerConfig && shakaPlayerConfig.installPolyfills) {\n      shaka.polyfill.installAll();\n    }\n    const shakaPlayer = new shaka.Player(videoElement);\n    if (shakaPlayerConfig && shakaPlayerConfig.customConfiguration) {\n      shakaPlayer.configure(shakaPlayerConfig.customConfiguration);\n    }\n    return shakaPlayer;\n  } else {\n    throw new PlaybackError(\n      'STREAM_ERROR_TECHNOLOGY_UNSUPPORTED',\n      'shaka',\n      'MPEG-DASH playback with Shaka Player is not supported in this browser.'\n    );\n  }\n}\n\nexport function shakaCleanup(shakaPlayer: ShakaPlayer) {\n  return Promise.resolve(shakaPlayer && shakaPlayer.destroy());\n}\n"],"sourceRoot":""}